// @bun
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = import.meta.require;

// node_modules/node-fetch-native-with-agent/dist/native.mjs
var exports_native = {};
__export(exports_native, {
  fetch: () => l,
  default: () => l,
  Response: () => h,
  Request: () => t,
  Headers: () => s,
  FormData: () => a,
  File: () => o,
  Blob: () => e,
  AbortController: () => i
});
var e, o, a, s, t, h, i, l;
var init_native = __esm(() => {
  e = globalThis.Blob;
  o = globalThis.File;
  a = globalThis.FormData;
  s = globalThis.Headers;
  t = globalThis.Request;
  h = globalThis.Response;
  i = globalThis.AbortController;
  l = globalThis.fetch || (() => {
    throw new Error("[node-fetch-native] Failed to fetch: `globalThis.fetch` is not available!");
  });
});

// node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.61758d11.cjs
var require_node_fetch_native_with_agent_61758d11 = __commonJS((exports) => {
  var l2 = Object.defineProperty;
  var o2 = (e2, t2) => l2(e2, "name", { value: t2, configurable: true });
  var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
  function getDefaultExportFromCjs(e2) {
    return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
  }
  o2(getDefaultExportFromCjs, "getDefaultExportFromCjs"), exports.commonjsGlobal = commonjsGlobal, exports.getDefaultExportFromCjs = getDefaultExportFromCjs;
});

// node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.df7e6bd6.cjs
var require_node_fetch_native_with_agent_df7e6bd6 = __commonJS((exports) => {
  var Dt = Object.defineProperty;
  var Ft = (e2, A, t2) => (A in e2) ? Dt(e2, A, { enumerable: true, configurable: true, writable: true, value: t2 }) : e2[A] = t2;
  var o2 = (e2, A) => Dt(e2, "name", { value: A, configurable: true });
  var NA = (e2, A, t2) => (Ft(e2, typeof A != "symbol" ? A + "" : A, t2), t2);
  var ze = (e2, A, t2) => {
    if (!A.has(e2))
      throw TypeError("Cannot " + t2);
  };
  var yt = (e2, A) => {
    if (Object(A) !== A)
      throw TypeError('Cannot use the "in" operator on this value');
    return e2.has(A);
  };
  var p = (e2, A, t2) => (ze(e2, A, "read from private field"), t2 ? t2.call(e2) : A.get(e2));
  var CA = (e2, A, t2) => {
    if (A.has(e2))
      throw TypeError("Cannot add the same private member more than once");
    A instanceof WeakSet ? A.add(e2) : A.set(e2, t2);
  };
  var EA = (e2, A, t2, n) => (ze(e2, A, "write to private field"), n ? n.call(e2, t2) : A.set(e2, t2), t2);
  var kA = (e2, A, t2) => (ze(e2, A, "access private method"), t2);
  var ne;
  var se;
  var oe;
  var ie;
  var Qe;
  var Ee;
  var ge;
  var Be;
  var Ce;
  var Ie;
  var ae;
  var ce;
  var he;
  var le;
  var ue;
  var de;
  var fe;
  var De;
  var ye;
  var Re;
  var we;
  var ke;
  var _A;
  var Ne;
  var Fe;
  var pe;
  var Se;
  var Ue;
  var be;
  var me;
  var Le;
  var Me;
  var Ye;
  var Je;
  var Oe;
  var Rt;
  var Ge;
  var Ae;
  var Te;
  var require$$0 = __require("assert");
  var require$$4 = __require("net");
  var http$1 = __require("http");
  var Stream = __require("stream");
  var require$$6 = __require("buffer");
  var require$$0$1 = __require("util");
  var require$$8 = __require("querystring");
  var require$$0$2 = __require("diagnostics_channel");
  var require$$0$3 = __require("events");
  var _commonjsHelpers = require_node_fetch_native_with_agent_61758d11();
  var require$$4$1 = __require("tls");
  var zlib = __require("zlib");
  var require$$5 = __require("perf_hooks");
  var require$$8$1 = __require("util/types");
  var require$$0$4 = __require("os");
  var require$$1 = __require("url");
  var require$$5$1 = __require("async_hooks");
  __require("console");
  var require$$5$2 = __require("string_decoder");
  var require$$2 = __require("worker_threads");
  function _interopDefaultCompat(e2) {
    return e2 && typeof e2 == "object" && "default" in e2 ? e2.default : e2;
  }
  o2(_interopDefaultCompat, "_interopDefaultCompat");
  var require$$0__default = _interopDefaultCompat(require$$0);
  var require$$4__default = _interopDefaultCompat(require$$4);
  var http__default = _interopDefaultCompat(http$1);
  var Stream__default = _interopDefaultCompat(Stream);
  var require$$6__default = _interopDefaultCompat(require$$6);
  var require$$0__default$1 = _interopDefaultCompat(require$$0$1);
  var require$$8__default = _interopDefaultCompat(require$$8);
  var require$$0__default$2 = _interopDefaultCompat(require$$0$2);
  var require$$0__default$3 = _interopDefaultCompat(require$$0$3);
  var require$$4__default$1 = _interopDefaultCompat(require$$4$1);
  var zlib__default = _interopDefaultCompat(zlib);
  var require$$5__default = _interopDefaultCompat(require$$5);
  var require$$8__default$1 = _interopDefaultCompat(require$$8$1);
  var require$$0__default$4 = _interopDefaultCompat(require$$0$4);
  var require$$1__default = _interopDefaultCompat(require$$1);
  var require$$5__default$1 = _interopDefaultCompat(require$$5$1);
  var require$$5__default$2 = _interopDefaultCompat(require$$5$2);
  var require$$2__default = _interopDefaultCompat(require$$2);
  var symbols$4 = { kClose: Symbol("close"), kDestroy: Symbol("destroy"), kDispatch: Symbol("dispatch"), kUrl: Symbol("url"), kWriting: Symbol("writing"), kResuming: Symbol("resuming"), kQueue: Symbol("queue"), kConnect: Symbol("connect"), kConnecting: Symbol("connecting"), kHeadersList: Symbol("headers list"), kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"), kKeepAliveMaxTimeout: Symbol("max keep alive timeout"), kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"), kKeepAliveTimeoutValue: Symbol("keep alive timeout"), kKeepAlive: Symbol("keep alive"), kHeadersTimeout: Symbol("headers timeout"), kBodyTimeout: Symbol("body timeout"), kServerName: Symbol("server name"), kLocalAddress: Symbol("local address"), kHost: Symbol("host"), kNoRef: Symbol("no ref"), kBodyUsed: Symbol("used"), kRunning: Symbol("running"), kBlocking: Symbol("blocking"), kPending: Symbol("pending"), kSize: Symbol("size"), kBusy: Symbol("busy"), kQueued: Symbol("queued"), kFree: Symbol("free"), kConnected: Symbol("connected"), kClosed: Symbol("closed"), kNeedDrain: Symbol("need drain"), kReset: Symbol("reset"), kDestroyed: Symbol.for("nodejs.stream.destroyed"), kResume: Symbol("resume"), kOnError: Symbol("on error"), kMaxHeadersSize: Symbol("max headers size"), kRunningIdx: Symbol("running index"), kPendingIdx: Symbol("pending index"), kError: Symbol("error"), kClients: Symbol("clients"), kClient: Symbol("client"), kParser: Symbol("parser"), kOnDestroyed: Symbol("destroy callbacks"), kPipelining: Symbol("pipelining"), kSocket: Symbol("socket"), kHostHeader: Symbol("host header"), kConnector: Symbol("connector"), kStrictContentLength: Symbol("strict content length"), kMaxRedirections: Symbol("maxRedirections"), kMaxRequests: Symbol("maxRequestsPerClient"), kProxy: Symbol("proxy agent options"), kCounter: Symbol("socket request counter"), kInterceptors: Symbol("dispatch interceptors"), kMaxResponseSize: Symbol("max response size"), kHTTP2Session: Symbol("http2Session"), kHTTP2SessionState: Symbol("http2Session state"), kRetryHandlerDefaultRetry: Symbol("retry agent default retry"), kConstruct: Symbol("constructable"), kListeners: Symbol("listeners"), kHTTPContext: Symbol("http context"), kMaxConcurrentStreams: Symbol("max concurrent streams") };
  var UndiciError$1 = (ne = class extends Error {
    constructor(A) {
      super(A), this.name = "UndiciError", this.code = "UND_ERR";
    }
  }, o2(ne, "UndiciError"), ne);
  var ConnectTimeoutError$1 = (se = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "ConnectTimeoutError", this.message = A || "Connect Timeout Error", this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
  }, o2(se, "ConnectTimeoutError"), se);
  var HeadersTimeoutError$1 = (oe = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "HeadersTimeoutError", this.message = A || "Headers Timeout Error", this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  }, o2(oe, "HeadersTimeoutError"), oe);
  var HeadersOverflowError$1 = (ie = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "HeadersOverflowError", this.message = A || "Headers Overflow Error", this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
  }, o2(ie, "HeadersOverflowError"), ie);
  var BodyTimeoutError$1 = (Qe = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "BodyTimeoutError", this.message = A || "Body Timeout Error", this.code = "UND_ERR_BODY_TIMEOUT";
    }
  }, o2(Qe, "BodyTimeoutError"), Qe);
  var ResponseStatusCodeError$1 = (Ee = class extends UndiciError$1 {
    constructor(A, t2, n, r) {
      super(A), this.name = "ResponseStatusCodeError", this.message = A || "Response Status Code Error", this.code = "UND_ERR_RESPONSE_STATUS_CODE", this.body = r, this.status = t2, this.statusCode = t2, this.headers = n;
    }
  }, o2(Ee, "ResponseStatusCodeError"), Ee);
  var InvalidArgumentError$k = (ge = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "InvalidArgumentError", this.message = A || "Invalid Argument Error", this.code = "UND_ERR_INVALID_ARG";
    }
  }, o2(ge, "InvalidArgumentError"), ge);
  var InvalidReturnValueError$2 = (Be = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "InvalidReturnValueError", this.message = A || "Invalid Return Value Error", this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  }, o2(Be, "InvalidReturnValueError"), Be);
  var AbortError$1 = (Ce = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "AbortError", this.message = A || "The operation was aborted";
    }
  }, o2(Ce, "AbortError"), Ce);
  var RequestAbortedError$6 = (Ie = class extends AbortError$1 {
    constructor(A) {
      super(A), this.name = "AbortError", this.message = A || "Request aborted", this.code = "UND_ERR_ABORTED";
    }
  }, o2(Ie, "RequestAbortedError"), Ie);
  var InformationalError$3 = (ae = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "InformationalError", this.message = A || "Request information", this.code = "UND_ERR_INFO";
    }
  }, o2(ae, "InformationalError"), ae);
  var RequestContentLengthMismatchError$2 = (ce = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "RequestContentLengthMismatchError", this.message = A || "Request body length does not match content-length header", this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
  }, o2(ce, "RequestContentLengthMismatchError"), ce);
  var ResponseContentLengthMismatchError$1 = (he = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "ResponseContentLengthMismatchError", this.message = A || "Response body length does not match content-length header", this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
  }, o2(he, "ResponseContentLengthMismatchError"), he);
  var ClientDestroyedError$2 = (le = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "ClientDestroyedError", this.message = A || "The client is destroyed", this.code = "UND_ERR_DESTROYED";
    }
  }, o2(le, "ClientDestroyedError"), le);
  var ClientClosedError$1 = (ue = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "ClientClosedError", this.message = A || "The client is closed", this.code = "UND_ERR_CLOSED";
    }
  }, o2(ue, "ClientClosedError"), ue);
  var SocketError$4 = (de = class extends UndiciError$1 {
    constructor(A, t2) {
      super(A), this.name = "SocketError", this.message = A || "Socket error", this.code = "UND_ERR_SOCKET", this.socket = t2;
    }
  }, o2(de, "SocketError"), de);
  var NotSupportedError$2 = (fe = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "NotSupportedError", this.message = A || "Not supported error", this.code = "UND_ERR_NOT_SUPPORTED";
    }
  }, o2(fe, "NotSupportedError"), fe);
  var At = class At2 extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "MissingUpstreamError", this.message = A || "No upstream has been added to the BalancedPool", this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
  };
  o2(At, "BalancedPoolMissingUpstreamError");
  var BalancedPoolMissingUpstreamError = At;
  var HTTPParserError$1 = (De = class extends Error {
    constructor(A, t2, n) {
      super(A), this.name = "HTTPParserError", this.code = t2 ? `HPE_${t2}` : undefined, this.data = n ? n.toString() : undefined;
    }
  }, o2(De, "HTTPParserError"), De);
  var ResponseExceededMaxSizeError$1 = (ye = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "ResponseExceededMaxSizeError", this.message = A || "Response content exceeded max size", this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
  }, o2(ye, "ResponseExceededMaxSizeError"), ye);
  var et = class et2 extends UndiciError$1 {
    constructor(A, t2, { headers: n, data: r }) {
      super(A), this.name = "RequestRetryError", this.message = A || "Request retry error", this.code = "UND_ERR_REQ_RETRY", this.statusCode = t2, this.data = r, this.headers = n;
    }
  };
  o2(et, "RequestRetryError");
  var RequestRetryError = et;
  var SecureProxyConnectionError$1 = (Re = class extends UndiciError$1 {
    constructor(A, t2, n) {
      super(t2, { cause: A, ...n ?? {} }), this.name = "SecureProxyConnectionError", this.message = t2 || "Secure Proxy Connection failed", this.code = "UND_ERR_PRX_TLS", this.cause = A;
    }
  }, o2(Re, "SecureProxyConnectionError"), Re);
  var errors$1 = { AbortError: AbortError$1, HTTPParserError: HTTPParserError$1, UndiciError: UndiciError$1, HeadersTimeoutError: HeadersTimeoutError$1, HeadersOverflowError: HeadersOverflowError$1, BodyTimeoutError: BodyTimeoutError$1, RequestContentLengthMismatchError: RequestContentLengthMismatchError$2, ConnectTimeoutError: ConnectTimeoutError$1, ResponseStatusCodeError: ResponseStatusCodeError$1, InvalidArgumentError: InvalidArgumentError$k, InvalidReturnValueError: InvalidReturnValueError$2, RequestAbortedError: RequestAbortedError$6, ClientDestroyedError: ClientDestroyedError$2, ClientClosedError: ClientClosedError$1, InformationalError: InformationalError$3, SocketError: SocketError$4, NotSupportedError: NotSupportedError$2, ResponseContentLengthMismatchError: ResponseContentLengthMismatchError$1, BalancedPoolMissingUpstreamError, ResponseExceededMaxSizeError: ResponseExceededMaxSizeError$1, RequestRetryError, SecureProxyConnectionError: SecureProxyConnectionError$1 };
  var headerNameLowerCasedRecord$3 = {};
  var wellknownHeaderNames$1 = ["Accept", "Accept-Encoding", "Accept-Language", "Accept-Ranges", "Access-Control-Allow-Credentials", "Access-Control-Allow-Headers", "Access-Control-Allow-Methods", "Access-Control-Allow-Origin", "Access-Control-Expose-Headers", "Access-Control-Max-Age", "Access-Control-Request-Headers", "Access-Control-Request-Method", "Age", "Allow", "Alt-Svc", "Alt-Used", "Authorization", "Cache-Control", "Clear-Site-Data", "Connection", "Content-Disposition", "Content-Encoding", "Content-Language", "Content-Length", "Content-Location", "Content-Range", "Content-Security-Policy", "Content-Security-Policy-Report-Only", "Content-Type", "Cookie", "Cross-Origin-Embedder-Policy", "Cross-Origin-Opener-Policy", "Cross-Origin-Resource-Policy", "Date", "Device-Memory", "Downlink", "ECT", "ETag", "Expect", "Expect-CT", "Expires", "Forwarded", "From", "Host", "If-Match", "If-Modified-Since", "If-None-Match", "If-Range", "If-Unmodified-Since", "Keep-Alive", "Last-Modified", "Link", "Location", "Max-Forwards", "Origin", "Permissions-Policy", "Pragma", "Proxy-Authenticate", "Proxy-Authorization", "RTT", "Range", "Referer", "Referrer-Policy", "Refresh", "Retry-After", "Sec-WebSocket-Accept", "Sec-WebSocket-Extensions", "Sec-WebSocket-Key", "Sec-WebSocket-Protocol", "Sec-WebSocket-Version", "Server", "Server-Timing", "Service-Worker-Allowed", "Service-Worker-Navigation-Preload", "Set-Cookie", "SourceMap", "Strict-Transport-Security", "Supports-Loading-Mode", "TE", "Timing-Allow-Origin", "Trailer", "Transfer-Encoding", "Upgrade", "Upgrade-Insecure-Requests", "User-Agent", "Vary", "Via", "WWW-Authenticate", "X-Content-Type-Options", "X-DNS-Prefetch-Control", "X-Frame-Options", "X-Permitted-Cross-Domain-Policies", "X-Powered-By", "X-Requested-With", "X-XSS-Protection"];
  for (let e2 = 0;e2 < wellknownHeaderNames$1.length; ++e2) {
    const A = wellknownHeaderNames$1[e2], t2 = A.toLowerCase();
    headerNameLowerCasedRecord$3[A] = headerNameLowerCasedRecord$3[t2] = t2;
  }
  Object.setPrototypeOf(headerNameLowerCasedRecord$3, null);
  var constants$5 = { wellknownHeaderNames: wellknownHeaderNames$1, headerNameLowerCasedRecord: headerNameLowerCasedRecord$3 };
  var { wellknownHeaderNames, headerNameLowerCasedRecord: headerNameLowerCasedRecord$2 } = constants$5;
  var xA = class xA2 {
    constructor(A, t2, n) {
      NA(this, "value", null);
      NA(this, "left", null);
      NA(this, "middle", null);
      NA(this, "right", null);
      NA(this, "code");
      if (n === undefined || n >= A.length)
        throw new TypeError("Unreachable");
      if ((this.code = A.charCodeAt(n)) > 127)
        throw new TypeError("key must be ascii string");
      A.length !== ++n ? this.middle = new xA2(A, t2, n) : this.value = t2;
    }
    add(A, t2) {
      const n = A.length;
      if (n === 0)
        throw new TypeError("Unreachable");
      let r = 0, s2 = this;
      for (;; ) {
        const i2 = A.charCodeAt(r);
        if (i2 > 127)
          throw new TypeError("key must be ascii string");
        if (s2.code === i2)
          if (n === ++r) {
            s2.value = t2;
            break;
          } else if (s2.middle !== null)
            s2 = s2.middle;
          else {
            s2.middle = new xA2(A, t2, r);
            break;
          }
        else if (s2.code < i2)
          if (s2.left !== null)
            s2 = s2.left;
          else {
            s2.left = new xA2(A, t2, r);
            break;
          }
        else if (s2.right !== null)
          s2 = s2.right;
        else {
          s2.right = new xA2(A, t2, r);
          break;
        }
      }
    }
    search(A) {
      const t2 = A.length;
      let n = 0, r = this;
      for (;r !== null && n < t2; ) {
        let s2 = A[n];
        for (s2 <= 90 && s2 >= 65 && (s2 |= 32);r !== null; ) {
          if (s2 === r.code) {
            if (t2 === ++n)
              return r;
            r = r.middle;
            break;
          }
          r = r.code < s2 ? r.left : r.right;
        }
      }
      return null;
    }
  };
  o2(xA, "TstNode");
  var TstNode = xA;
  var tt = class tt2 {
    constructor() {
      NA(this, "node", null);
    }
    insert(A, t2) {
      this.node === null ? this.node = new TstNode(A, t2, 0) : this.node.add(A, t2);
    }
    lookup(A) {
      return this.node?.search(A)?.value ?? null;
    }
  };
  o2(tt, "TernarySearchTree");
  var TernarySearchTree = tt;
  var tree$1 = new TernarySearchTree;
  for (let e2 = 0;e2 < wellknownHeaderNames.length; ++e2) {
    const A = headerNameLowerCasedRecord$2[wellknownHeaderNames[e2]];
    tree$1.insert(A, A);
  }
  var tree_1 = { TernarySearchTree, tree: tree$1 };
  var assert$d = require$$0__default;
  var { kDestroyed: kDestroyed$1, kBodyUsed: kBodyUsed$1, kListeners } = symbols$4;
  var { IncomingMessage } = http__default;
  var stream$1 = Stream__default;
  var net$2 = require$$4__default;
  var { InvalidArgumentError: InvalidArgumentError$j } = errors$1;
  var { Blob: Blob$1 } = require$$6__default;
  var nodeUtil = require$$0__default$1;
  var { stringify } = require$$8__default;
  var { headerNameLowerCasedRecord: headerNameLowerCasedRecord$1 } = constants$5;
  var { tree } = tree_1;
  var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((e2) => Number(e2));
  function nop() {}
  o2(nop, "nop");
  function isStream$1(e2) {
    return e2 && typeof e2 == "object" && typeof e2.pipe == "function" && typeof e2.on == "function";
  }
  o2(isStream$1, "isStream$1");
  function isBlobLike$1(e2) {
    if (e2 === null)
      return false;
    if (e2 instanceof Blob$1)
      return true;
    if (typeof e2 != "object")
      return false;
    {
      const A = e2[Symbol.toStringTag];
      return (A === "Blob" || A === "File") && (("stream" in e2) && typeof e2.stream == "function" || ("arrayBuffer" in e2) && typeof e2.arrayBuffer == "function");
    }
  }
  o2(isBlobLike$1, "isBlobLike$1");
  function buildURL$3(e2, A) {
    if (e2.includes("?") || e2.includes("#"))
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    const t2 = stringify(A);
    return t2 && (e2 += "?" + t2), e2;
  }
  o2(buildURL$3, "buildURL$3");
  function parseURL(e2) {
    if (typeof e2 == "string") {
      if (e2 = new URL(e2), !/^https?:/.test(e2.origin || e2.protocol))
        throw new InvalidArgumentError$j("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      return e2;
    }
    if (!e2 || typeof e2 != "object")
      throw new InvalidArgumentError$j("Invalid URL: The URL argument must be a non-null object.");
    if (!/^https?:/.test(e2.origin || e2.protocol))
      throw new InvalidArgumentError$j("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    if (!(e2 instanceof URL)) {
      if (e2.port != null && e2.port !== "" && !Number.isFinite(parseInt(e2.port)))
        throw new InvalidArgumentError$j("Invalid URL: port must be a valid integer or a string representation of an integer.");
      if (e2.path != null && typeof e2.path != "string")
        throw new InvalidArgumentError$j("Invalid URL path: the path must be a string or null/undefined.");
      if (e2.pathname != null && typeof e2.pathname != "string")
        throw new InvalidArgumentError$j("Invalid URL pathname: the pathname must be a string or null/undefined.");
      if (e2.hostname != null && typeof e2.hostname != "string")
        throw new InvalidArgumentError$j("Invalid URL hostname: the hostname must be a string or null/undefined.");
      if (e2.origin != null && typeof e2.origin != "string")
        throw new InvalidArgumentError$j("Invalid URL origin: the origin must be a string or null/undefined.");
      const A = e2.port != null ? e2.port : e2.protocol === "https:" ? 443 : 80;
      let t2 = e2.origin != null ? e2.origin : `${e2.protocol}//${e2.hostname}:${A}`, n = e2.path != null ? e2.path : `${e2.pathname || ""}${e2.search || ""}`;
      t2.endsWith("/") && (t2 = t2.substring(0, t2.length - 1)), n && !n.startsWith("/") && (n = `/${n}`), e2 = new URL(t2 + n);
    }
    return e2;
  }
  o2(parseURL, "parseURL");
  function parseOrigin(e2) {
    if (e2 = parseURL(e2), e2.pathname !== "/" || e2.search || e2.hash)
      throw new InvalidArgumentError$j("invalid url");
    return e2;
  }
  o2(parseOrigin, "parseOrigin");
  function getHostname(e2) {
    if (e2[0] === "[") {
      const t2 = e2.indexOf("]");
      return assert$d(t2 !== -1), e2.substring(1, t2);
    }
    const A = e2.indexOf(":");
    return A === -1 ? e2 : e2.substring(0, A);
  }
  o2(getHostname, "getHostname");
  function getServerName$1(e2) {
    if (!e2)
      return null;
    assert$d.strictEqual(typeof e2, "string");
    const A = getHostname(e2);
    return net$2.isIP(A) ? "" : A;
  }
  o2(getServerName$1, "getServerName$1");
  function deepClone(e2) {
    return JSON.parse(JSON.stringify(e2));
  }
  o2(deepClone, "deepClone");
  function isAsyncIterable(e2) {
    return e2 != null && typeof e2[Symbol.asyncIterator] == "function";
  }
  o2(isAsyncIterable, "isAsyncIterable");
  function isIterable$1(e2) {
    return e2 != null && (typeof e2[Symbol.iterator] == "function" || typeof e2[Symbol.asyncIterator] == "function");
  }
  o2(isIterable$1, "isIterable$1");
  function bodyLength(e2) {
    if (e2 == null)
      return 0;
    if (isStream$1(e2)) {
      const A = e2._readableState;
      return A && A.objectMode === false && A.ended === true && Number.isFinite(A.length) ? A.length : null;
    } else {
      if (isBlobLike$1(e2))
        return e2.size != null ? e2.size : null;
      if (isBuffer$1(e2))
        return e2.byteLength;
    }
    return null;
  }
  o2(bodyLength, "bodyLength");
  function isDestroyed(e2) {
    return e2 && !!(e2.destroyed || e2[kDestroyed$1] || stream$1.isDestroyed?.(e2));
  }
  o2(isDestroyed, "isDestroyed");
  function isReadableAborted(e2) {
    const A = e2?._readableState;
    return isDestroyed(e2) && A && !A.endEmitted;
  }
  o2(isReadableAborted, "isReadableAborted");
  function destroy$1(e2, A) {
    e2 == null || !isStream$1(e2) || isDestroyed(e2) || (typeof e2.destroy == "function" ? (Object.getPrototypeOf(e2).constructor === IncomingMessage && (e2.socket = null), e2.destroy(A)) : A && queueMicrotask(() => {
      e2.emit("error", A);
    }), e2.destroyed !== true && (e2[kDestroyed$1] = true));
  }
  o2(destroy$1, "destroy$1");
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(e2) {
    const A = e2.toString().match(KEEPALIVE_TIMEOUT_EXPR);
    return A ? parseInt(A[1], 10) * 1000 : null;
  }
  o2(parseKeepAliveTimeout, "parseKeepAliveTimeout");
  function headerNameToString(e2) {
    return typeof e2 == "string" ? headerNameLowerCasedRecord$1[e2] ?? e2.toLowerCase() : tree.lookup(e2) ?? e2.toString("latin1").toLowerCase();
  }
  o2(headerNameToString, "headerNameToString");
  function bufferToLowerCasedHeaderName(e2) {
    return tree.lookup(e2) ?? e2.toString("latin1").toLowerCase();
  }
  o2(bufferToLowerCasedHeaderName, "bufferToLowerCasedHeaderName");
  function parseHeaders(e2, A) {
    A === undefined && (A = {});
    for (let t2 = 0;t2 < e2.length; t2 += 2) {
      const n = headerNameToString(e2[t2]);
      let r = A[n];
      if (r)
        typeof r == "string" && (r = [r], A[n] = r), r.push(e2[t2 + 1].toString("utf8"));
      else {
        const s2 = e2[t2 + 1];
        typeof s2 == "string" ? A[n] = s2 : A[n] = Array.isArray(s2) ? s2.map((i2) => i2.toString("utf8")) : s2.toString("utf8");
      }
    }
    return "content-length" in A && "content-disposition" in A && (A["content-disposition"] = Buffer.from(A["content-disposition"]).toString("latin1")), A;
  }
  o2(parseHeaders, "parseHeaders");
  function parseRawHeaders(e2) {
    const A = e2.length, t2 = new Array(A);
    let n = false, r = -1, s2, i2, E = 0;
    for (let Q = 0;Q < e2.length; Q += 2)
      s2 = e2[Q], i2 = e2[Q + 1], typeof s2 != "string" && (s2 = s2.toString()), typeof i2 != "string" && (i2 = i2.toString("utf8")), E = s2.length, E === 14 && s2[7] === "-" && (s2 === "content-length" || s2.toLowerCase() === "content-length") ? n = true : E === 19 && s2[7] === "-" && (s2 === "content-disposition" || s2.toLowerCase() === "content-disposition") && (r = Q + 1), t2[Q] = s2, t2[Q + 1] = i2;
    return n && r !== -1 && (t2[r] = Buffer.from(t2[r]).toString("latin1")), t2;
  }
  o2(parseRawHeaders, "parseRawHeaders");
  function isBuffer$1(e2) {
    return e2 instanceof Uint8Array || Buffer.isBuffer(e2);
  }
  o2(isBuffer$1, "isBuffer$1");
  function validateHandler$1(e2, A, t2) {
    if (!e2 || typeof e2 != "object")
      throw new InvalidArgumentError$j("handler must be an object");
    if (typeof e2.onConnect != "function")
      throw new InvalidArgumentError$j("invalid onConnect method");
    if (typeof e2.onError != "function")
      throw new InvalidArgumentError$j("invalid onError method");
    if (typeof e2.onBodySent != "function" && e2.onBodySent !== undefined)
      throw new InvalidArgumentError$j("invalid onBodySent method");
    if (t2 || A === "CONNECT") {
      if (typeof e2.onUpgrade != "function")
        throw new InvalidArgumentError$j("invalid onUpgrade method");
    } else {
      if (typeof e2.onHeaders != "function")
        throw new InvalidArgumentError$j("invalid onHeaders method");
      if (typeof e2.onData != "function")
        throw new InvalidArgumentError$j("invalid onData method");
      if (typeof e2.onComplete != "function")
        throw new InvalidArgumentError$j("invalid onComplete method");
    }
  }
  o2(validateHandler$1, "validateHandler$1");
  function isDisturbed(e2) {
    return !!(e2 && (stream$1.isDisturbed(e2) || e2[kBodyUsed$1]));
  }
  o2(isDisturbed, "isDisturbed");
  function isErrored(e2) {
    return !!(e2 && stream$1.isErrored(e2));
  }
  o2(isErrored, "isErrored");
  function isReadable(e2) {
    return !!(e2 && stream$1.isReadable(e2));
  }
  o2(isReadable, "isReadable");
  function getSocketInfo(e2) {
    return { localAddress: e2.localAddress, localPort: e2.localPort, remoteAddress: e2.remoteAddress, remotePort: e2.remotePort, remoteFamily: e2.remoteFamily, timeout: e2.timeout, bytesWritten: e2.bytesWritten, bytesRead: e2.bytesRead };
  }
  o2(getSocketInfo, "getSocketInfo");
  function ReadableStreamFrom$1(e2) {
    let A;
    return new ReadableStream({ async start() {
      A = e2[Symbol.asyncIterator]();
    }, async pull(t2) {
      const { done: n, value: r } = await A.next();
      if (n)
        queueMicrotask(() => {
          t2.close(), t2.byobRequest?.respond(0);
        });
      else {
        const s2 = Buffer.isBuffer(r) ? r : Buffer.from(r);
        s2.byteLength && t2.enqueue(new Uint8Array(s2));
      }
      return t2.desiredSize > 0;
    }, async cancel(t2) {
      await A.return();
    }, type: "bytes" });
  }
  o2(ReadableStreamFrom$1, "ReadableStreamFrom$1");
  function isFormDataLike$1(e2) {
    return e2 && typeof e2 == "object" && typeof e2.append == "function" && typeof e2.delete == "function" && typeof e2.get == "function" && typeof e2.getAll == "function" && typeof e2.has == "function" && typeof e2.set == "function" && e2[Symbol.toStringTag] === "FormData";
  }
  o2(isFormDataLike$1, "isFormDataLike$1");
  function addAbortListener$1(e2, A) {
    return "addEventListener" in e2 ? (e2.addEventListener("abort", A, { once: true }), () => e2.removeEventListener("abort", A)) : (e2.addListener("abort", A), () => e2.removeListener("abort", A));
  }
  o2(addAbortListener$1, "addAbortListener$1");
  var hasToWellFormed = typeof String.prototype.toWellFormed == "function";
  var hasIsWellFormed = typeof String.prototype.isWellFormed == "function";
  function toUSVString(e2) {
    return hasToWellFormed ? `${e2}`.toWellFormed() : nodeUtil.toUSVString(e2);
  }
  o2(toUSVString, "toUSVString");
  function isUSVString(e2) {
    return hasIsWellFormed ? `${e2}`.isWellFormed() : toUSVString(e2) === `${e2}`;
  }
  o2(isUSVString, "isUSVString");
  function isTokenCharCode(e2) {
    switch (e2) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return false;
      default:
        return e2 >= 33 && e2 <= 126;
    }
  }
  o2(isTokenCharCode, "isTokenCharCode");
  function isValidHTTPToken$1(e2) {
    if (e2.length === 0)
      return false;
    for (let A = 0;A < e2.length; ++A)
      if (!isTokenCharCode(e2.charCodeAt(A)))
        return false;
    return true;
  }
  o2(isValidHTTPToken$1, "isValidHTTPToken$1");
  var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function isValidHeaderChar$1(e2) {
    return !headerCharRegex.test(e2);
  }
  o2(isValidHeaderChar$1, "isValidHeaderChar$1");
  function parseRangeHeader(e2) {
    if (e2 == null || e2 === "")
      return { start: 0, end: null, size: null };
    const A = e2 ? e2.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return A ? { start: parseInt(A[1]), end: A[2] ? parseInt(A[2]) : null, size: A[3] ? parseInt(A[3]) : null } : null;
  }
  o2(parseRangeHeader, "parseRangeHeader");
  function addListener$1(e2, A, t2) {
    return (e2[kListeners] ?? (e2[kListeners] = [])).push([A, t2]), e2.on(A, t2), e2;
  }
  o2(addListener$1, "addListener$1");
  function removeAllListeners$1(e2) {
    for (const [A, t2] of e2[kListeners] ?? [])
      e2.removeListener(A, t2);
    e2[kListeners] = null;
  }
  o2(removeAllListeners$1, "removeAllListeners$1");
  function errorRequest(e2, A, t2) {
    try {
      A.onError(t2), assert$d(A.aborted);
    } catch (n) {
      e2.emit("error", n);
    }
  }
  o2(errorRequest, "errorRequest");
  var kEnumerableProperty = Object.create(null);
  kEnumerableProperty.enumerable = true;
  var util$m = { kEnumerableProperty, nop, isDisturbed, isErrored, isReadable, toUSVString, isUSVString, isReadableAborted, isBlobLike: isBlobLike$1, parseOrigin, parseURL, getServerName: getServerName$1, isStream: isStream$1, isIterable: isIterable$1, isAsyncIterable, isDestroyed, headerNameToString, bufferToLowerCasedHeaderName, addListener: addListener$1, removeAllListeners: removeAllListeners$1, errorRequest, parseRawHeaders, parseHeaders, parseKeepAliveTimeout, destroy: destroy$1, bodyLength, deepClone, ReadableStreamFrom: ReadableStreamFrom$1, isBuffer: isBuffer$1, validateHandler: validateHandler$1, getSocketInfo, isFormDataLike: isFormDataLike$1, buildURL: buildURL$3, addAbortListener: addAbortListener$1, isValidHTTPToken: isValidHTTPToken$1, isValidHeaderChar: isValidHeaderChar$1, isTokenCharCode, parseRangeHeader, nodeMajor, nodeMinor, nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13, safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"] };
  var diagnosticsChannel = require$$0__default$2;
  var util$l = require$$0__default$1;
  var undiciDebugLog = util$l.debuglog("undici");
  var fetchDebuglog = util$l.debuglog("fetch");
  var websocketDebuglog = util$l.debuglog("websocket");
  var isClientSet = false;
  var channels$3 = { beforeConnect: diagnosticsChannel.channel("undici:client:beforeConnect"), connected: diagnosticsChannel.channel("undici:client:connected"), connectError: diagnosticsChannel.channel("undici:client:connectError"), sendHeaders: diagnosticsChannel.channel("undici:client:sendHeaders"), create: diagnosticsChannel.channel("undici:request:create"), bodySent: diagnosticsChannel.channel("undici:request:bodySent"), headers: diagnosticsChannel.channel("undici:request:headers"), trailers: diagnosticsChannel.channel("undici:request:trailers"), error: diagnosticsChannel.channel("undici:request:error"), open: diagnosticsChannel.channel("undici:websocket:open"), close: diagnosticsChannel.channel("undici:websocket:close"), socketError: diagnosticsChannel.channel("undici:websocket:socket_error"), ping: diagnosticsChannel.channel("undici:websocket:ping"), pong: diagnosticsChannel.channel("undici:websocket:pong") };
  if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
    const e2 = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog;
    diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((A) => {
      const { connectParams: { version: t2, protocol: n, port: r, host: s2 } } = A;
      e2("connecting to %s using %s%s", `${s2}${r ? `:${r}` : ""}`, n, t2);
    }), diagnosticsChannel.channel("undici:client:connected").subscribe((A) => {
      const { connectParams: { version: t2, protocol: n, port: r, host: s2 } } = A;
      e2("connected to %s using %s%s", `${s2}${r ? `:${r}` : ""}`, n, t2);
    }), diagnosticsChannel.channel("undici:client:connectError").subscribe((A) => {
      const { connectParams: { version: t2, protocol: n, port: r, host: s2 }, error: i2 } = A;
      e2("connection to %s using %s%s errored - %s", `${s2}${r ? `:${r}` : ""}`, n, t2, i2.message);
    }), diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((A) => {
      const { request: { method: t2, path: n, origin: r } } = A;
      e2("sending request to %s %s/%s", t2, r, n);
    }), diagnosticsChannel.channel("undici:request:headers").subscribe((A) => {
      const { request: { method: t2, path: n, origin: r }, response: { statusCode: s2 } } = A;
      e2("received response to %s %s/%s - HTTP %d", t2, r, n, s2);
    }), diagnosticsChannel.channel("undici:request:trailers").subscribe((A) => {
      const { request: { method: t2, path: n, origin: r } } = A;
      e2("trailers received from %s %s/%s", t2, r, n);
    }), diagnosticsChannel.channel("undici:request:error").subscribe((A) => {
      const { request: { method: t2, path: n, origin: r }, error: s2 } = A;
      e2("request to %s %s/%s errored - %s", t2, r, n, s2.message);
    }), isClientSet = true;
  }
  if (websocketDebuglog.enabled) {
    if (!isClientSet) {
      const e2 = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog;
      diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((A) => {
        const { connectParams: { version: t2, protocol: n, port: r, host: s2 } } = A;
        e2("connecting to %s%s using %s%s", s2, r ? `:${r}` : "", n, t2);
      }), diagnosticsChannel.channel("undici:client:connected").subscribe((A) => {
        const { connectParams: { version: t2, protocol: n, port: r, host: s2 } } = A;
        e2("connected to %s%s using %s%s", s2, r ? `:${r}` : "", n, t2);
      }), diagnosticsChannel.channel("undici:client:connectError").subscribe((A) => {
        const { connectParams: { version: t2, protocol: n, port: r, host: s2 }, error: i2 } = A;
        e2("connection to %s%s using %s%s errored - %s", s2, r ? `:${r}` : "", n, t2, i2.message);
      }), diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((A) => {
        const { request: { method: t2, path: n, origin: r } } = A;
        e2("sending request to %s %s/%s", t2, r, n);
      });
    }
    diagnosticsChannel.channel("undici:websocket:open").subscribe((e2) => {
      const { address: { address: A, port: t2 } } = e2;
      websocketDebuglog("connection opened %s%s", A, t2 ? `:${t2}` : "");
    }), diagnosticsChannel.channel("undici:websocket:close").subscribe((e2) => {
      const { websocket: A, code: t2, reason: n } = e2;
      websocketDebuglog("closed connection to %s - %s %s", A.url, t2, n);
    }), diagnosticsChannel.channel("undici:websocket:socket_error").subscribe((e2) => {
      websocketDebuglog("connection errored - %s", e2.message);
    }), diagnosticsChannel.channel("undici:websocket:ping").subscribe((e2) => {
      websocketDebuglog("ping received");
    }), diagnosticsChannel.channel("undici:websocket:pong").subscribe((e2) => {
      websocketDebuglog("pong received");
    });
  }
  var diagnostics = { channels: channels$3 };
  var { InvalidArgumentError: InvalidArgumentError$i, NotSupportedError: NotSupportedError$1 } = errors$1;
  var assert$c = require$$0__default;
  var { isValidHTTPToken, isValidHeaderChar, isStream, destroy, isBuffer, isFormDataLike, isIterable, isBlobLike, buildURL: buildURL$2, validateHandler, getServerName } = util$m;
  var { channels: channels$2 } = diagnostics;
  var { headerNameLowerCasedRecord } = constants$5;
  var invalidPathRegex = /[^\u0021-\u00ff]/;
  var kHandler = Symbol("handler");
  var Request$1 = (we = class {
    constructor(A, { path: t2, method: n, body: r, headers: s2, query: i2, idempotent: E, blocking: Q, upgrade: C, headersTimeout: I, bodyTimeout: a2, reset: f, throwOnError: h2, expectContinue: L, servername: c }, l2) {
      if (typeof t2 != "string")
        throw new InvalidArgumentError$i("path must be a string");
      if (t2[0] !== "/" && !(t2.startsWith("http://") || t2.startsWith("https://")) && n !== "CONNECT")
        throw new InvalidArgumentError$i("path must be an absolute URL or start with a slash");
      if (invalidPathRegex.exec(t2) !== null)
        throw new InvalidArgumentError$i("invalid request path");
      if (typeof n != "string")
        throw new InvalidArgumentError$i("method must be a string");
      if (!isValidHTTPToken(n))
        throw new InvalidArgumentError$i("invalid request method");
      if (C && typeof C != "string")
        throw new InvalidArgumentError$i("upgrade must be a string");
      if (I != null && (!Number.isFinite(I) || I < 0))
        throw new InvalidArgumentError$i("invalid headersTimeout");
      if (a2 != null && (!Number.isFinite(a2) || a2 < 0))
        throw new InvalidArgumentError$i("invalid bodyTimeout");
      if (f != null && typeof f != "boolean")
        throw new InvalidArgumentError$i("invalid reset");
      if (L != null && typeof L != "boolean")
        throw new InvalidArgumentError$i("invalid expectContinue");
      if (this.headersTimeout = I, this.bodyTimeout = a2, this.throwOnError = h2 === true, this.method = n, this.abort = null, r == null)
        this.body = null;
      else if (isStream(r)) {
        this.body = r;
        const S = this.body._readableState;
        (!S || !S.autoDestroy) && (this.endHandler = o2(function() {
          destroy(this);
        }, "autoDestroy"), this.body.on("end", this.endHandler)), this.errorHandler = (k) => {
          this.abort ? this.abort(k) : this.error = k;
        }, this.body.on("error", this.errorHandler);
      } else if (isBuffer(r))
        this.body = r.byteLength ? r : null;
      else if (ArrayBuffer.isView(r))
        this.body = r.buffer.byteLength ? Buffer.from(r.buffer, r.byteOffset, r.byteLength) : null;
      else if (r instanceof ArrayBuffer)
        this.body = r.byteLength ? Buffer.from(r) : null;
      else if (typeof r == "string")
        this.body = r.length ? Buffer.from(r) : null;
      else if (isFormDataLike(r) || isIterable(r) || isBlobLike(r))
        this.body = r;
      else
        throw new InvalidArgumentError$i("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      if (this.completed = false, this.aborted = false, this.upgrade = C || null, this.path = i2 ? buildURL$2(t2, i2) : t2, this.origin = A, this.idempotent = E ?? (n === "HEAD" || n === "GET"), this.blocking = Q ?? false, this.reset = f ?? null, this.host = null, this.contentLength = null, this.contentType = null, this.headers = [], this.expectContinue = L ?? false, Array.isArray(s2)) {
        if (s2.length % 2 !== 0)
          throw new InvalidArgumentError$i("headers array must be even");
        for (let S = 0;S < s2.length; S += 2)
          processHeader(this, s2[S], s2[S + 1]);
      } else if (s2 && typeof s2 == "object")
        if (s2[Symbol.iterator])
          for (const S of s2) {
            if (!Array.isArray(S) || S.length !== 2)
              throw new InvalidArgumentError$i("headers must be in key-value pair format");
            processHeader(this, S[0], S[1]);
          }
        else {
          const S = Object.keys(s2);
          for (let k = 0;k < S.length; ++k)
            processHeader(this, S[k], s2[S[k]]);
        }
      else if (s2 != null)
        throw new InvalidArgumentError$i("headers must be an object or an array");
      validateHandler(l2, n, C), this.servername = c || getServerName(this.host), this[kHandler] = l2, channels$2.create.hasSubscribers && channels$2.create.publish({ request: this });
    }
    onBodySent(A) {
      if (this[kHandler].onBodySent)
        try {
          return this[kHandler].onBodySent(A);
        } catch (t2) {
          this.abort(t2);
        }
    }
    onRequestSent() {
      if (channels$2.bodySent.hasSubscribers && channels$2.bodySent.publish({ request: this }), this[kHandler].onRequestSent)
        try {
          return this[kHandler].onRequestSent();
        } catch (A) {
          this.abort(A);
        }
    }
    onConnect(A) {
      if (assert$c(!this.aborted), assert$c(!this.completed), this.error)
        A(this.error);
      else
        return this.abort = A, this[kHandler].onConnect(A);
    }
    onResponseStarted() {
      return this[kHandler].onResponseStarted?.();
    }
    onHeaders(A, t2, n, r) {
      assert$c(!this.aborted), assert$c(!this.completed), channels$2.headers.hasSubscribers && channels$2.headers.publish({ request: this, response: { statusCode: A, headers: t2, statusText: r } });
      try {
        return this[kHandler].onHeaders(A, t2, n, r);
      } catch (s2) {
        this.abort(s2);
      }
    }
    onData(A) {
      assert$c(!this.aborted), assert$c(!this.completed);
      try {
        return this[kHandler].onData(A);
      } catch (t2) {
        return this.abort(t2), false;
      }
    }
    onUpgrade(A, t2, n) {
      return assert$c(!this.aborted), assert$c(!this.completed), this[kHandler].onUpgrade(A, t2, n);
    }
    onComplete(A) {
      this.onFinally(), assert$c(!this.aborted), this.completed = true, channels$2.trailers.hasSubscribers && channels$2.trailers.publish({ request: this, trailers: A });
      try {
        return this[kHandler].onComplete(A);
      } catch (t2) {
        this.onError(t2);
      }
    }
    onError(A) {
      if (this.onFinally(), channels$2.error.hasSubscribers && channels$2.error.publish({ request: this, error: A }), !this.aborted)
        return this.aborted = true, this[kHandler].onError(A);
    }
    onFinally() {
      this.errorHandler && (this.body.off("error", this.errorHandler), this.errorHandler = null), this.endHandler && (this.body.off("end", this.endHandler), this.endHandler = null);
    }
    addHeader(A, t2) {
      return processHeader(this, A, t2), this;
    }
  }, o2(we, "Request"), we);
  function processHeader(e2, A, t2) {
    if (t2 && typeof t2 == "object" && !Array.isArray(t2))
      throw new InvalidArgumentError$i(`invalid ${A} header`);
    if (t2 === undefined)
      return;
    let n = headerNameLowerCasedRecord[A];
    if (n === undefined && (n = A.toLowerCase(), headerNameLowerCasedRecord[n] === undefined && !isValidHTTPToken(n)))
      throw new InvalidArgumentError$i("invalid header key");
    if (Array.isArray(t2)) {
      const r = [];
      for (let s2 = 0;s2 < t2.length; s2++)
        if (typeof t2[s2] == "string") {
          if (!isValidHeaderChar(t2[s2]))
            throw new InvalidArgumentError$i(`invalid ${A} header`);
          r.push(t2[s2]);
        } else if (t2[s2] === null)
          r.push("");
        else {
          if (typeof t2[s2] == "object")
            throw new InvalidArgumentError$i(`invalid ${A} header`);
          r.push(`${t2[s2]}`);
        }
      t2 = r;
    } else if (typeof t2 == "string") {
      if (!isValidHeaderChar(t2))
        throw new InvalidArgumentError$i(`invalid ${A} header`);
    } else if (t2 === null)
      t2 = "";
    else {
      if (typeof t2 == "object")
        throw new InvalidArgumentError$i(`invalid ${A} header`);
      t2 = `${t2}`;
    }
    if (e2.host === null && n === "host") {
      if (typeof t2 != "string")
        throw new InvalidArgumentError$i("invalid host header");
      e2.host = t2;
    } else if (e2.contentLength === null && n === "content-length") {
      if (e2.contentLength = parseInt(t2, 10), !Number.isFinite(e2.contentLength))
        throw new InvalidArgumentError$i("invalid content-length header");
    } else if (e2.contentType === null && n === "content-type")
      e2.contentType = t2, e2.headers.push(A, t2);
    else {
      if (n === "transfer-encoding" || n === "keep-alive" || n === "upgrade")
        throw new InvalidArgumentError$i(`invalid ${n} header`);
      if (n === "connection") {
        const r = typeof t2 == "string" ? t2.toLowerCase() : null;
        if (r !== "close" && r !== "keep-alive")
          throw new InvalidArgumentError$i("invalid connection header");
        r === "close" && (e2.reset = true);
      } else {
        if (n === "expect")
          throw new NotSupportedError$1("expect header not supported");
        e2.headers.push(A, t2);
      }
    }
  }
  o2(processHeader, "processHeader");
  var request$2 = Request$1;
  var EventEmitter = require$$0__default$3;
  var Dispatcher$2 = (ke = class extends EventEmitter {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
    compose(...A) {
      const t2 = Array.isArray(A[0]) ? A[0] : A;
      let n = this.dispatch.bind(this);
      for (const r of t2)
        if (r != null) {
          if (typeof r != "function")
            throw new TypeError(`invalid interceptor, expected function received ${typeof r}`);
          if (n = r(n), n == null || typeof n != "function" || n.length !== 2)
            throw new TypeError("invalid interceptor");
        }
      return new ComposedDispatcher(this, n);
    }
  }, o2(ke, "Dispatcher"), ke);
  var rt = class rt2 extends Dispatcher$2 {
    constructor(t2, n) {
      super();
      CA(this, _A, null);
      CA(this, Ne, null);
      EA(this, _A, t2), EA(this, Ne, n);
    }
    dispatch(...t2) {
      p(this, Ne).call(this, ...t2);
    }
    close(...t2) {
      return p(this, _A).close(...t2);
    }
    destroy(...t2) {
      return p(this, _A).destroy(...t2);
    }
  };
  _A = new WeakMap, Ne = new WeakMap, o2(rt, "ComposedDispatcher");
  var ComposedDispatcher = rt;
  var dispatcher = Dispatcher$2;
  var Dispatcher$1 = dispatcher;
  var { ClientDestroyedError: ClientDestroyedError$1, ClientClosedError, InvalidArgumentError: InvalidArgumentError$h } = errors$1;
  var { kDestroy: kDestroy$4, kClose: kClose$6, kDispatch: kDispatch$3, kInterceptors: kInterceptors$4 } = symbols$4;
  var kDestroyed = Symbol("destroyed");
  var kClosed = Symbol("closed");
  var kOnDestroyed = Symbol("onDestroyed");
  var kOnClosed = Symbol("onClosed");
  var kInterceptedDispatch = Symbol("Intercepted Dispatch");
  var DispatcherBase$4 = (Fe = class extends Dispatcher$1 {
    constructor() {
      super(), this[kDestroyed] = false, this[kOnDestroyed] = null, this[kClosed] = false, this[kOnClosed] = [];
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    get interceptors() {
      return this[kInterceptors$4];
    }
    set interceptors(A) {
      if (A) {
        for (let t2 = A.length - 1;t2 >= 0; t2--)
          if (typeof this[kInterceptors$4][t2] != "function")
            throw new InvalidArgumentError$h("interceptor must be an function");
      }
      this[kInterceptors$4] = A;
    }
    close(A) {
      if (A === undefined)
        return new Promise((n, r) => {
          this.close((s2, i2) => s2 ? r(s2) : n(i2));
        });
      if (typeof A != "function")
        throw new InvalidArgumentError$h("invalid callback");
      if (this[kDestroyed]) {
        queueMicrotask(() => A(new ClientDestroyedError$1, null));
        return;
      }
      if (this[kClosed]) {
        this[kOnClosed] ? this[kOnClosed].push(A) : queueMicrotask(() => A(null, null));
        return;
      }
      this[kClosed] = true, this[kOnClosed].push(A);
      const t2 = o2(() => {
        const n = this[kOnClosed];
        this[kOnClosed] = null;
        for (let r = 0;r < n.length; r++)
          n[r](null, null);
      }, "onClosed");
      this[kClose$6]().then(() => this.destroy()).then(() => {
        queueMicrotask(t2);
      });
    }
    destroy(A, t2) {
      if (typeof A == "function" && (t2 = A, A = null), t2 === undefined)
        return new Promise((r, s2) => {
          this.destroy(A, (i2, E) => i2 ? s2(i2) : r(E));
        });
      if (typeof t2 != "function")
        throw new InvalidArgumentError$h("invalid callback");
      if (this[kDestroyed]) {
        this[kOnDestroyed] ? this[kOnDestroyed].push(t2) : queueMicrotask(() => t2(null, null));
        return;
      }
      A || (A = new ClientDestroyedError$1), this[kDestroyed] = true, this[kOnDestroyed] = this[kOnDestroyed] || [], this[kOnDestroyed].push(t2);
      const n = o2(() => {
        const r = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let s2 = 0;s2 < r.length; s2++)
          r[s2](null, null);
      }, "onDestroyed");
      this[kDestroy$4](A).then(() => {
        queueMicrotask(n);
      });
    }
    [kInterceptedDispatch](A, t2) {
      if (!this[kInterceptors$4] || this[kInterceptors$4].length === 0)
        return this[kInterceptedDispatch] = this[kDispatch$3], this[kDispatch$3](A, t2);
      let n = this[kDispatch$3].bind(this);
      for (let r = this[kInterceptors$4].length - 1;r >= 0; r--)
        n = this[kInterceptors$4][r](n);
      return this[kInterceptedDispatch] = n, n(A, t2);
    }
    dispatch(A, t2) {
      if (!t2 || typeof t2 != "object")
        throw new InvalidArgumentError$h("handler must be an object");
      try {
        if (!A || typeof A != "object")
          throw new InvalidArgumentError$h("opts must be an object.");
        if (this[kDestroyed] || this[kOnDestroyed])
          throw new ClientDestroyedError$1;
        if (this[kClosed])
          throw new ClientClosedError;
        return this[kInterceptedDispatch](A, t2);
      } catch (n) {
        if (typeof t2.onError != "function")
          throw new InvalidArgumentError$h("invalid onError method");
        return t2.onError(n), false;
      }
    }
  }, o2(Fe, "DispatcherBase"), Fe);
  var dispatcherBase = DispatcherBase$4;
  var net$1 = require$$4__default;
  var assert$b = require$$0__default;
  var util$k = util$m;
  var { InvalidArgumentError: InvalidArgumentError$g, ConnectTimeoutError } = errors$1;
  var tls;
  var SessionCache;
  _commonjsHelpers.commonjsGlobal.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG) ? SessionCache = (pe = class {
    constructor(A) {
      this._maxCachedSessions = A, this._sessionCache = new Map, this._sessionRegistry = new _commonjsHelpers.commonjsGlobal.FinalizationRegistry((t2) => {
        if (this._sessionCache.size < this._maxCachedSessions)
          return;
        const n = this._sessionCache.get(t2);
        n !== undefined && n.deref() === undefined && this._sessionCache.delete(t2);
      });
    }
    get(A) {
      const t2 = this._sessionCache.get(A);
      return t2 ? t2.deref() : null;
    }
    set(A, t2) {
      this._maxCachedSessions !== 0 && (this._sessionCache.set(A, new WeakRef(t2)), this._sessionRegistry.register(t2, A));
    }
  }, o2(pe, "WeakSessionCache"), pe) : SessionCache = (Se = class {
    constructor(A) {
      this._maxCachedSessions = A, this._sessionCache = new Map;
    }
    get(A) {
      return this._sessionCache.get(A);
    }
    set(A, t2) {
      if (this._maxCachedSessions !== 0) {
        if (this._sessionCache.size >= this._maxCachedSessions) {
          const { value: n } = this._sessionCache.keys().next();
          this._sessionCache.delete(n);
        }
        this._sessionCache.set(A, t2);
      }
    }
  }, o2(Se, "SimpleSessionCache"), Se);
  function buildConnector$3({ allowH2: e2, maxCachedSessions: A, socketPath: t2, timeout: n, ...r }) {
    if (A != null && (!Number.isInteger(A) || A < 0))
      throw new InvalidArgumentError$g("maxCachedSessions must be a positive integer or zero");
    const s2 = { path: t2, ...r }, i2 = new SessionCache(A ?? 100);
    return n = n ?? 1e4, e2 = e2 ?? false, o2(function({ hostname: Q, host: C, protocol: I, port: a2, servername: f, localAddress: h2, httpSocket: L }, c) {
      let l2;
      if (I === "https:") {
        tls || (tls = require$$4__default$1), f = f || s2.servername || util$k.getServerName(C) || null;
        const k = f || Q, w = i2.get(k) || null;
        assert$b(k), l2 = tls.connect({ highWaterMark: 16384, ...s2, servername: f, session: w, localAddress: h2, ALPNProtocols: e2 ? ["http/1.1", "h2"] : ["http/1.1"], socket: L, port: a2 || 443, host: Q }), l2.on("session", function(U) {
          i2.set(k, U);
        });
      } else
        assert$b(!L, "httpSocket can only be sent on TLS update"), l2 = net$1.connect({ highWaterMark: 64 * 1024, ...s2, localAddress: h2, port: a2 || 80, host: Q });
      if (s2.keepAlive == null || s2.keepAlive) {
        const k = s2.keepAliveInitialDelay === undefined ? 60000 : s2.keepAliveInitialDelay;
        l2.setKeepAlive(true, k);
      }
      const S = setupTimeout(() => onConnectTimeout(l2), n);
      return l2.setNoDelay(true).once(I === "https:" ? "secureConnect" : "connect", function() {
        if (S(), c) {
          const k = c;
          c = null, k(null, this);
        }
      }).on("error", function(k) {
        if (S(), c) {
          const w = c;
          c = null, w(k);
        }
      }), l2;
    }, "connect");
  }
  o2(buildConnector$3, "buildConnector$3");
  function setupTimeout(e2, A) {
    if (!A)
      return () => {};
    let t2 = null, n = null;
    const r = setTimeout(() => {
      t2 = setImmediate(() => {
        process.platform === "win32" ? n = setImmediate(() => e2()) : e2();
      });
    }, A);
    return () => {
      clearTimeout(r), clearImmediate(t2), clearImmediate(n);
    };
  }
  o2(setupTimeout, "setupTimeout");
  function onConnectTimeout(e2) {
    let A = "Connect Timeout Error";
    Array.isArray(e2.autoSelectFamilyAttemptedAddresses) && (A += ` (attempted addresses: ${e2.autoSelectFamilyAttemptedAddresses.join(", ")})`), util$k.destroy(e2, new ConnectTimeoutError(A));
  }
  o2(onConnectTimeout, "onConnectTimeout");
  var connect$2 = buildConnector$3;
  var fastNow = Date.now();
  var fastNowTimeout;
  var fastTimers = [];
  function onTimeout() {
    fastNow = Date.now();
    let e2 = fastTimers.length, A = 0;
    for (;A < e2; ) {
      const t2 = fastTimers[A];
      t2.state === 0 ? t2.state = fastNow + t2.delay : t2.state > 0 && fastNow >= t2.state && (t2.state = -1, t2.callback(t2.opaque)), t2.state === -1 ? (t2.state = -2, A !== e2 - 1 ? fastTimers[A] = fastTimers.pop() : fastTimers.pop(), e2 -= 1) : A += 1;
    }
    fastTimers.length > 0 && refreshTimeout();
  }
  o2(onTimeout, "onTimeout");
  function refreshTimeout() {
    fastNowTimeout?.refresh ? fastNowTimeout.refresh() : (clearTimeout(fastNowTimeout), fastNowTimeout = setTimeout(onTimeout, 1000), fastNowTimeout.unref && fastNowTimeout.unref());
  }
  o2(refreshTimeout, "refreshTimeout");
  var nt = class nt2 {
    constructor(A, t2, n) {
      this.callback = A, this.delay = t2, this.opaque = n, this.state = -2, this.refresh();
    }
    refresh() {
      this.state === -2 && (fastTimers.push(this), (!fastNowTimeout || fastTimers.length === 1) && refreshTimeout()), this.state = 0;
    }
    clear() {
      this.state = -1;
    }
  };
  o2(nt, "Timeout");
  var Timeout = nt;
  var timers$1 = { setTimeout(e2, A, t2) {
    return A < 1000 ? setTimeout(e2, A, t2) : new Timeout(e2, A, t2);
  }, clearTimeout(e2) {
    e2 instanceof Timeout ? e2.clear() : clearTimeout(e2);
  } };
  var constants$4 = {};
  var utils = {};
  Object.defineProperty(utils, "__esModule", { value: true }), utils.enumToMap = undefined;
  function enumToMap(e2) {
    const A = {};
    return Object.keys(e2).forEach((t2) => {
      const n = e2[t2];
      typeof n == "number" && (A[t2] = n);
    }), A;
  }
  o2(enumToMap, "enumToMap"), utils.enumToMap = enumToMap, function(e2) {
    Object.defineProperty(e2, "__esModule", { value: true }), e2.SPECIAL_HEADERS = e2.HEADER_STATE = e2.MINOR = e2.MAJOR = e2.CONNECTION_TOKEN_CHARS = e2.HEADER_CHARS = e2.TOKEN = e2.STRICT_TOKEN = e2.HEX = e2.URL_CHAR = e2.STRICT_URL_CHAR = e2.USERINFO_CHARS = e2.MARK = e2.ALPHANUM = e2.NUM = e2.HEX_MAP = e2.NUM_MAP = e2.ALPHA = e2.FINISH = e2.H_METHOD_MAP = e2.METHOD_MAP = e2.METHODS_RTSP = e2.METHODS_ICE = e2.METHODS_HTTP = e2.METHODS = e2.LENIENT_FLAGS = e2.FLAGS = e2.TYPE = e2.ERROR = undefined;
    const A = utils;
    (function(r) {
      r[r.OK = 0] = "OK", r[r.INTERNAL = 1] = "INTERNAL", r[r.STRICT = 2] = "STRICT", r[r.LF_EXPECTED = 3] = "LF_EXPECTED", r[r.UNEXPECTED_CONTENT_LENGTH = 4] = "UNEXPECTED_CONTENT_LENGTH", r[r.CLOSED_CONNECTION = 5] = "CLOSED_CONNECTION", r[r.INVALID_METHOD = 6] = "INVALID_METHOD", r[r.INVALID_URL = 7] = "INVALID_URL", r[r.INVALID_CONSTANT = 8] = "INVALID_CONSTANT", r[r.INVALID_VERSION = 9] = "INVALID_VERSION", r[r.INVALID_HEADER_TOKEN = 10] = "INVALID_HEADER_TOKEN", r[r.INVALID_CONTENT_LENGTH = 11] = "INVALID_CONTENT_LENGTH", r[r.INVALID_CHUNK_SIZE = 12] = "INVALID_CHUNK_SIZE", r[r.INVALID_STATUS = 13] = "INVALID_STATUS", r[r.INVALID_EOF_STATE = 14] = "INVALID_EOF_STATE", r[r.INVALID_TRANSFER_ENCODING = 15] = "INVALID_TRANSFER_ENCODING", r[r.CB_MESSAGE_BEGIN = 16] = "CB_MESSAGE_BEGIN", r[r.CB_HEADERS_COMPLETE = 17] = "CB_HEADERS_COMPLETE", r[r.CB_MESSAGE_COMPLETE = 18] = "CB_MESSAGE_COMPLETE", r[r.CB_CHUNK_HEADER = 19] = "CB_CHUNK_HEADER", r[r.CB_CHUNK_COMPLETE = 20] = "CB_CHUNK_COMPLETE", r[r.PAUSED = 21] = "PAUSED", r[r.PAUSED_UPGRADE = 22] = "PAUSED_UPGRADE", r[r.PAUSED_H2_UPGRADE = 23] = "PAUSED_H2_UPGRADE", r[r.USER = 24] = "USER";
    })(e2.ERROR || (e2.ERROR = {})), function(r) {
      r[r.BOTH = 0] = "BOTH", r[r.REQUEST = 1] = "REQUEST", r[r.RESPONSE = 2] = "RESPONSE";
    }(e2.TYPE || (e2.TYPE = {})), function(r) {
      r[r.CONNECTION_KEEP_ALIVE = 1] = "CONNECTION_KEEP_ALIVE", r[r.CONNECTION_CLOSE = 2] = "CONNECTION_CLOSE", r[r.CONNECTION_UPGRADE = 4] = "CONNECTION_UPGRADE", r[r.CHUNKED = 8] = "CHUNKED", r[r.UPGRADE = 16] = "UPGRADE", r[r.CONTENT_LENGTH = 32] = "CONTENT_LENGTH", r[r.SKIPBODY = 64] = "SKIPBODY", r[r.TRAILING = 128] = "TRAILING", r[r.TRANSFER_ENCODING = 512] = "TRANSFER_ENCODING";
    }(e2.FLAGS || (e2.FLAGS = {})), function(r) {
      r[r.HEADERS = 1] = "HEADERS", r[r.CHUNKED_LENGTH = 2] = "CHUNKED_LENGTH", r[r.KEEP_ALIVE = 4] = "KEEP_ALIVE";
    }(e2.LENIENT_FLAGS || (e2.LENIENT_FLAGS = {}));
    var t2;
    (function(r) {
      r[r.DELETE = 0] = "DELETE", r[r.GET = 1] = "GET", r[r.HEAD = 2] = "HEAD", r[r.POST = 3] = "POST", r[r.PUT = 4] = "PUT", r[r.CONNECT = 5] = "CONNECT", r[r.OPTIONS = 6] = "OPTIONS", r[r.TRACE = 7] = "TRACE", r[r.COPY = 8] = "COPY", r[r.LOCK = 9] = "LOCK", r[r.MKCOL = 10] = "MKCOL", r[r.MOVE = 11] = "MOVE", r[r.PROPFIND = 12] = "PROPFIND", r[r.PROPPATCH = 13] = "PROPPATCH", r[r.SEARCH = 14] = "SEARCH", r[r.UNLOCK = 15] = "UNLOCK", r[r.BIND = 16] = "BIND", r[r.REBIND = 17] = "REBIND", r[r.UNBIND = 18] = "UNBIND", r[r.ACL = 19] = "ACL", r[r.REPORT = 20] = "REPORT", r[r.MKACTIVITY = 21] = "MKACTIVITY", r[r.CHECKOUT = 22] = "CHECKOUT", r[r.MERGE = 23] = "MERGE", r[r["M-SEARCH"] = 24] = "M-SEARCH", r[r.NOTIFY = 25] = "NOTIFY", r[r.SUBSCRIBE = 26] = "SUBSCRIBE", r[r.UNSUBSCRIBE = 27] = "UNSUBSCRIBE", r[r.PATCH = 28] = "PATCH", r[r.PURGE = 29] = "PURGE", r[r.MKCALENDAR = 30] = "MKCALENDAR", r[r.LINK = 31] = "LINK", r[r.UNLINK = 32] = "UNLINK", r[r.SOURCE = 33] = "SOURCE", r[r.PRI = 34] = "PRI", r[r.DESCRIBE = 35] = "DESCRIBE", r[r.ANNOUNCE = 36] = "ANNOUNCE", r[r.SETUP = 37] = "SETUP", r[r.PLAY = 38] = "PLAY", r[r.PAUSE = 39] = "PAUSE", r[r.TEARDOWN = 40] = "TEARDOWN", r[r.GET_PARAMETER = 41] = "GET_PARAMETER", r[r.SET_PARAMETER = 42] = "SET_PARAMETER", r[r.REDIRECT = 43] = "REDIRECT", r[r.RECORD = 44] = "RECORD", r[r.FLUSH = 45] = "FLUSH";
    })(t2 = e2.METHODS || (e2.METHODS = {})), e2.METHODS_HTTP = [t2.DELETE, t2.GET, t2.HEAD, t2.POST, t2.PUT, t2.CONNECT, t2.OPTIONS, t2.TRACE, t2.COPY, t2.LOCK, t2.MKCOL, t2.MOVE, t2.PROPFIND, t2.PROPPATCH, t2.SEARCH, t2.UNLOCK, t2.BIND, t2.REBIND, t2.UNBIND, t2.ACL, t2.REPORT, t2.MKACTIVITY, t2.CHECKOUT, t2.MERGE, t2["M-SEARCH"], t2.NOTIFY, t2.SUBSCRIBE, t2.UNSUBSCRIBE, t2.PATCH, t2.PURGE, t2.MKCALENDAR, t2.LINK, t2.UNLINK, t2.PRI, t2.SOURCE], e2.METHODS_ICE = [t2.SOURCE], e2.METHODS_RTSP = [t2.OPTIONS, t2.DESCRIBE, t2.ANNOUNCE, t2.SETUP, t2.PLAY, t2.PAUSE, t2.TEARDOWN, t2.GET_PARAMETER, t2.SET_PARAMETER, t2.REDIRECT, t2.RECORD, t2.FLUSH, t2.GET, t2.POST], e2.METHOD_MAP = A.enumToMap(t2), e2.H_METHOD_MAP = {}, Object.keys(e2.METHOD_MAP).forEach((r) => {
      /^H/.test(r) && (e2.H_METHOD_MAP[r] = e2.METHOD_MAP[r]);
    }), function(r) {
      r[r.SAFE = 0] = "SAFE", r[r.SAFE_WITH_CB = 1] = "SAFE_WITH_CB", r[r.UNSAFE = 2] = "UNSAFE";
    }(e2.FINISH || (e2.FINISH = {})), e2.ALPHA = [];
    for (let r = 65;r <= 90; r++)
      e2.ALPHA.push(String.fromCharCode(r)), e2.ALPHA.push(String.fromCharCode(r + 32));
    e2.NUM_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9 }, e2.HEX_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, e2.NUM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], e2.ALPHANUM = e2.ALPHA.concat(e2.NUM), e2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"], e2.USERINFO_CHARS = e2.ALPHANUM.concat(e2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]), e2.STRICT_URL_CHAR = ["!", '"', "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~"].concat(e2.ALPHANUM), e2.URL_CHAR = e2.STRICT_URL_CHAR.concat(["\t", "\f"]);
    for (let r = 128;r <= 255; r++)
      e2.URL_CHAR.push(r);
    e2.HEX = e2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]), e2.STRICT_TOKEN = ["!", "#", "$", "%", "&", "'", "*", "+", "-", ".", "^", "_", "`", "|", "~"].concat(e2.ALPHANUM), e2.TOKEN = e2.STRICT_TOKEN.concat([" "]), e2.HEADER_CHARS = ["\t"];
    for (let r = 32;r <= 255; r++)
      r !== 127 && e2.HEADER_CHARS.push(r);
    e2.CONNECTION_TOKEN_CHARS = e2.HEADER_CHARS.filter((r) => r !== 44), e2.MAJOR = e2.NUM_MAP, e2.MINOR = e2.MAJOR;
    var n;
    (function(r) {
      r[r.GENERAL = 0] = "GENERAL", r[r.CONNECTION = 1] = "CONNECTION", r[r.CONTENT_LENGTH = 2] = "CONTENT_LENGTH", r[r.TRANSFER_ENCODING = 3] = "TRANSFER_ENCODING", r[r.UPGRADE = 4] = "UPGRADE", r[r.CONNECTION_KEEP_ALIVE = 5] = "CONNECTION_KEEP_ALIVE", r[r.CONNECTION_CLOSE = 6] = "CONNECTION_CLOSE", r[r.CONNECTION_UPGRADE = 7] = "CONNECTION_UPGRADE", r[r.TRANSFER_ENCODING_CHUNKED = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(n = e2.HEADER_STATE || (e2.HEADER_STATE = {})), e2.SPECIAL_HEADERS = { connection: n.CONNECTION, "content-length": n.CONTENT_LENGTH, "proxy-connection": n.CONNECTION, "transfer-encoding": n.TRANSFER_ENCODING, upgrade: n.UPGRADE };
  }(constants$4);
  var llhttpWasm;
  var hasRequiredLlhttpWasm;
  function requireLlhttpWasm() {
    if (hasRequiredLlhttpWasm)
      return llhttpWasm;
    hasRequiredLlhttpWasm = 1;
    const { Buffer: e2 } = require$$6__default;
    return llhttpWasm = e2.from("AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=", "base64"), llhttpWasm;
  }
  o2(requireLlhttpWasm, "requireLlhttpWasm");
  var llhttp_simdWasm;
  var hasRequiredLlhttp_simdWasm;
  function requireLlhttp_simdWasm() {
    if (hasRequiredLlhttp_simdWasm)
      return llhttp_simdWasm;
    hasRequiredLlhttp_simdWasm = 1;
    const { Buffer: e2 } = require$$6__default;
    return llhttp_simdWasm = e2.from("AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB4fICEjJSg/QEFERUZHSElKS0xNT1BRUlPeA1dZW1xdYGJlZmdoaWprbG1vcHFyc3R1dnd4eXp7fH1+gAGCAYUBhgGHAYkBiwGMAY0BjgGPAZABkQGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMBmQKkArAC/gL+AgsgASIEIAJHDfMBQd0BIRAM/wMLIAEiECACRw3dAUHDASEQDP4DCyABIgEgAkcNkAFB9wAhEAz9AwsgASIBIAJHDYYBQe8AIRAM/AMLIAEiASACRw1/QeoAIRAM+wMLIAEiASACRw17QegAIRAM+gMLIAEiASACRw14QeYAIRAM+QMLIAEiASACRw0aQRghEAz4AwsgASIBIAJHDRRBEiEQDPcDCyABIgEgAkcNWUHFACEQDPYDCyABIgEgAkcNSkE/IRAM9QMLIAEiASACRw1IQTwhEAz0AwsgASIBIAJHDUFBMSEQDPMDCyAALQAuQQFGDesDDIcCCyAAIAEiASACEMCAgIAAQQFHDeYBIABCADcDIAznAQsgACABIgEgAhC0gICAACIQDecBIAEhAQz1AgsCQCABIgEgAkcNAEEGIRAM8AMLIAAgAUEBaiIBIAIQu4CAgAAiEA3oASABIQEMMQsgAEIANwMgQRIhEAzVAwsgASIQIAJHDStBHSEQDO0DCwJAIAEiASACRg0AIAFBAWohAUEQIRAM1AMLQQchEAzsAwsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3lAUEIIRAM6wMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQRQhEAzSAwtBCSEQDOoDCyABIQEgACkDIFAN5AEgASEBDPICCwJAIAEiASACRw0AQQshEAzpAwsgACABQQFqIgEgAhC2gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeYBIAEhAQwNCyAAIAEiASACELqAgIAAIhAN5wEgASEBDPACCwJAIAEiASACRw0AQQ8hEAzlAwsgAS0AACIQQTtGDQggEEENRw3oASABQQFqIQEM7wILIAAgASIBIAIQuoCAgAAiEA3oASABIQEM8gILA0ACQCABLQAAQfC1gIAAai0AACIQQQFGDQAgEEECRw3rASAAKAIEIRAgAEEANgIEIAAgECABQQFqIgEQuYCAgAAiEA3qASABIQEM9AILIAFBAWoiASACRw0AC0ESIRAM4gMLIAAgASIBIAIQuoCAgAAiEA3pASABIQEMCgsgASIBIAJHDQZBGyEQDOADCwJAIAEiASACRw0AQRYhEAzgAwsgAEGKgICAADYCCCAAIAE2AgQgACABIAIQuICAgAAiEA3qASABIQFBICEQDMYDCwJAIAEiASACRg0AA0ACQCABLQAAQfC3gIAAai0AACIQQQJGDQACQCAQQX9qDgTlAewBAOsB7AELIAFBAWohAUEIIRAMyAMLIAFBAWoiASACRw0AC0EVIRAM3wMLQRUhEAzeAwsDQAJAIAEtAABB8LmAgABqLQAAIhBBAkYNACAQQX9qDgTeAewB4AHrAewBCyABQQFqIgEgAkcNAAtBGCEQDN0DCwJAIAEiASACRg0AIABBi4CAgAA2AgggACABNgIEIAEhAUEHIRAMxAMLQRkhEAzcAwsgAUEBaiEBDAILAkAgASIUIAJHDQBBGiEQDNsDCyAUIQECQCAULQAAQXNqDhTdAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAgDuAgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQM2gMLAkAgAS0AACIQQTtGDQAgEEENRw3oASABQQFqIQEM5QILIAFBAWohAQtBIiEQDL8DCwJAIAEiECACRw0AQRwhEAzYAwtCACERIBAhASAQLQAAQVBqDjfnAeYBAQIDBAUGBwgAAAAAAAAACQoLDA0OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPEBESExQAC0EeIRAMvQMLQgIhEQzlAQtCAyERDOQBC0IEIREM4wELQgUhEQziAQtCBiERDOEBC0IHIREM4AELQgghEQzfAQtCCSERDN4BC0IKIREM3QELQgshEQzcAQtCDCERDNsBC0INIREM2gELQg4hEQzZAQtCDyERDNgBC0IKIREM1wELQgshEQzWAQtCDCERDNUBC0INIREM1AELQg4hEQzTAQtCDyERDNIBC0IAIRECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAtAABBUGoON+UB5AEAAQIDBAUGB+YB5gHmAeYB5gHmAeYBCAkKCwwN5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAQ4PEBESE+YBC0ICIREM5AELQgMhEQzjAQtCBCERDOIBC0IFIREM4QELQgYhEQzgAQtCByERDN8BC0IIIREM3gELQgkhEQzdAQtCCiERDNwBC0ILIREM2wELQgwhEQzaAQtCDSERDNkBC0IOIREM2AELQg8hEQzXAQtCCiERDNYBC0ILIREM1QELQgwhEQzUAQtCDSERDNMBC0IOIREM0gELQg8hEQzRAQsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3SAUEfIRAMwAMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQSQhEAynAwtBICEQDL8DCyAAIAEiECACEL6AgIAAQX9qDgW2AQDFAgHRAdIBC0ERIRAMpAMLIABBAToALyAQIQEMuwMLIAEiASACRw3SAUEkIRAMuwMLIAEiDSACRw0eQcYAIRAMugMLIAAgASIBIAIQsoCAgAAiEA3UASABIQEMtQELIAEiECACRw0mQdAAIRAMuAMLAkAgASIBIAJHDQBBKCEQDLgDCyAAQQA2AgQgAEGMgICAADYCCCAAIAEgARCxgICAACIQDdMBIAEhAQzYAQsCQCABIhAgAkcNAEEpIRAMtwMLIBAtAAAiAUEgRg0UIAFBCUcN0wEgEEEBaiEBDBULAkAgASIBIAJGDQAgAUEBaiEBDBcLQSohEAy1AwsCQCABIhAgAkcNAEErIRAMtQMLAkAgEC0AACIBQQlGDQAgAUEgRw3VAQsgAC0ALEEIRg3TASAQIQEMkQMLAkAgASIBIAJHDQBBLCEQDLQDCyABLQAAQQpHDdUBIAFBAWohAQzJAgsgASIOIAJHDdUBQS8hEAyyAwsDQAJAIAEtAAAiEEEgRg0AAkAgEEF2ag4EANwB3AEA2gELIAEhAQzgAQsgAUEBaiIBIAJHDQALQTEhEAyxAwtBMiEQIAEiFCACRg2wAyACIBRrIAAoAgAiAWohFSAUIAFrQQNqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB8LuAgABqLQAARw0BAkAgAUEDRw0AQQYhAQyWAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMsQMLIABBADYCACAUIQEM2QELQTMhECABIhQgAkYNrwMgAiAUayAAKAIAIgFqIRUgFCABa0EIaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfS7gIAAai0AAEcNAQJAIAFBCEcNAEEFIQEMlQMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLADCyAAQQA2AgAgFCEBDNgBC0E0IRAgASIUIAJGDa4DIAIgFGsgACgCACIBaiEVIBQgAWtBBWohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUHQwoCAAGotAABHDQECQCABQQVHDQBBByEBDJQDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAyvAwsgAEEANgIAIBQhAQzXAQsCQCABIgEgAkYNAANAAkAgAS0AAEGAvoCAAGotAAAiEEEBRg0AIBBBAkYNCiABIQEM3QELIAFBAWoiASACRw0AC0EwIRAMrgMLQTAhEAytAwsCQCABIgEgAkYNAANAAkAgAS0AACIQQSBGDQAgEEF2ag4E2QHaAdoB2QHaAQsgAUEBaiIBIAJHDQALQTghEAytAwtBOCEQDKwDCwNAAkAgAS0AACIQQSBGDQAgEEEJRw0DCyABQQFqIgEgAkcNAAtBPCEQDKsDCwNAAkAgAS0AACIQQSBGDQACQAJAIBBBdmoOBNoBAQHaAQALIBBBLEYN2wELIAEhAQwECyABQQFqIgEgAkcNAAtBPyEQDKoDCyABIQEM2wELQcAAIRAgASIUIAJGDagDIAIgFGsgACgCACIBaiEWIBQgAWtBBmohFwJAA0AgFC0AAEEgciABQYDAgIAAai0AAEcNASABQQZGDY4DIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADKkDCyAAQQA2AgAgFCEBC0E2IRAMjgMLAkAgASIPIAJHDQBBwQAhEAynAwsgAEGMgICAADYCCCAAIA82AgQgDyEBIAAtACxBf2oOBM0B1QHXAdkBhwMLIAFBAWohAQzMAQsCQCABIgEgAkYNAANAAkAgAS0AACIQQSByIBAgEEG/f2pB/wFxQRpJG0H/AXEiEEEJRg0AIBBBIEYNAAJAAkACQAJAIBBBnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQTEhEAyRAwsgAUEBaiEBQTIhEAyQAwsgAUEBaiEBQTMhEAyPAwsgASEBDNABCyABQQFqIgEgAkcNAAtBNSEQDKUDC0E1IRAMpAMLAkAgASIBIAJGDQADQAJAIAEtAABBgLyAgABqLQAAQQFGDQAgASEBDNMBCyABQQFqIgEgAkcNAAtBPSEQDKQDC0E9IRAMowMLIAAgASIBIAIQsICAgAAiEA3WASABIQEMAQsgEEEBaiEBC0E8IRAMhwMLAkAgASIBIAJHDQBBwgAhEAygAwsCQANAAkAgAS0AAEF3ag4YAAL+Av4ChAP+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gIA/gILIAFBAWoiASACRw0AC0HCACEQDKADCyABQQFqIQEgAC0ALUEBcUUNvQEgASEBC0EsIRAMhQMLIAEiASACRw3TAUHEACEQDJ0DCwNAAkAgAS0AAEGQwICAAGotAABBAUYNACABIQEMtwILIAFBAWoiASACRw0AC0HFACEQDJwDCyANLQAAIhBBIEYNswEgEEE6Rw2BAyAAKAIEIQEgAEEANgIEIAAgASANEK+AgIAAIgEN0AEgDUEBaiEBDLMCC0HHACEQIAEiDSACRg2aAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQZDCgIAAai0AAEcNgAMgAUEFRg30AiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyaAwtByAAhECABIg0gAkYNmQMgAiANayAAKAIAIgFqIRYgDSABa0EJaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGWwoCAAGotAABHDf8CAkAgAUEJRw0AQQIhAQz1AgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmQMLAkAgASINIAJHDQBByQAhEAyZAwsCQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZJ/ag4HAIADgAOAA4ADgAMBgAMLIA1BAWohAUE+IRAMgAMLIA1BAWohAUE/IRAM/wILQcoAIRAgASINIAJGDZcDIAIgDWsgACgCACIBaiEWIA0gAWtBAWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBoMKAgABqLQAARw39AiABQQFGDfACIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJcDC0HLACEQIAEiDSACRg2WAyACIA1rIAAoAgAiAWohFiANIAFrQQ5qIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaLCgIAAai0AAEcN/AIgAUEORg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyWAwtBzAAhECABIg0gAkYNlQMgAiANayAAKAIAIgFqIRYgDSABa0EPaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUHAwoCAAGotAABHDfsCAkAgAUEPRw0AQQMhAQzxAgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlQMLQc0AIRAgASINIAJGDZQDIAIgDWsgACgCACIBaiEWIA0gAWtBBWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw36AgJAIAFBBUcNAEEEIQEM8AILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJQDCwJAIAEiDSACRw0AQc4AIRAMlAMLAkACQAJAAkAgDS0AACIBQSByIAEgAUG/f2pB/wFxQRpJG0H/AXFBnX9qDhMA/QL9Av0C/QL9Av0C/QL9Av0C/QL9Av0CAf0C/QL9AgID/QILIA1BAWohAUHBACEQDP0CCyANQQFqIQFBwgAhEAz8AgsgDUEBaiEBQcMAIRAM+wILIA1BAWohAUHEACEQDPoCCwJAIAEiASACRg0AIABBjYCAgAA2AgggACABNgIEIAEhAUHFACEQDPoCC0HPACEQDJIDCyAQIQECQAJAIBAtAABBdmoOBAGoAqgCAKgCCyAQQQFqIQELQSchEAz4AgsCQCABIgEgAkcNAEHRACEQDJEDCwJAIAEtAABBIEYNACABIQEMjQELIAFBAWohASAALQAtQQFxRQ3HASABIQEMjAELIAEiFyACRw3IAUHSACEQDI8DC0HTACEQIAEiFCACRg2OAyACIBRrIAAoAgAiAWohFiAUIAFrQQFqIRcDQCAULQAAIAFB1sKAgABqLQAARw3MASABQQFGDccBIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADI4DCwJAIAEiASACRw0AQdUAIRAMjgMLIAEtAABBCkcNzAEgAUEBaiEBDMcBCwJAIAEiASACRw0AQdYAIRAMjQMLAkACQCABLQAAQXZqDgQAzQHNAQHNAQsgAUEBaiEBDMcBCyABQQFqIQFBygAhEAzzAgsgACABIgEgAhCugICAACIQDcsBIAEhAUHNACEQDPICCyAALQApQSJGDYUDDKYCCwJAIAEiASACRw0AQdsAIRAMigMLQQAhFEEBIRdBASEWQQAhEAJAAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgrUAdMBAAECAwQFBgjVAQtBAiEQDAYLQQMhEAwFC0EEIRAMBAtBBSEQDAMLQQYhEAwCC0EHIRAMAQtBCCEQC0EAIRdBACEWQQAhFAzMAQtBCSEQQQEhFEEAIRdBACEWDMsBCwJAIAEiASACRw0AQd0AIRAMiQMLIAEtAABBLkcNzAEgAUEBaiEBDKYCCyABIgEgAkcNzAFB3wAhEAyHAwsCQCABIgEgAkYNACAAQY6AgIAANgIIIAAgATYCBCABIQFB0AAhEAzuAgtB4AAhEAyGAwtB4QAhECABIgEgAkYNhQMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQeLCgIAAai0AAEcNzQEgFEEDRg3MASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyFAwtB4gAhECABIgEgAkYNhAMgAiABayAAKAIAIhRqIRYgASAUa0ECaiEXA0AgAS0AACAUQebCgIAAai0AAEcNzAEgFEECRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyEAwtB4wAhECABIgEgAkYNgwMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQenCgIAAai0AAEcNywEgFEEDRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyDAwsCQCABIgEgAkcNAEHlACEQDIMDCyAAIAFBAWoiASACEKiAgIAAIhANzQEgASEBQdYAIRAM6QILAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AAkACQAJAIBBBuH9qDgsAAc8BzwHPAc8BzwHPAc8BzwECzwELIAFBAWohAUHSACEQDO0CCyABQQFqIQFB0wAhEAzsAgsgAUEBaiEBQdQAIRAM6wILIAFBAWoiASACRw0AC0HkACEQDIIDC0HkACEQDIEDCwNAAkAgAS0AAEHwwoCAAGotAAAiEEEBRg0AIBBBfmoOA88B0AHRAdIBCyABQQFqIgEgAkcNAAtB5gAhEAyAAwsCQCABIgEgAkYNACABQQFqIQEMAwtB5wAhEAz/AgsDQAJAIAEtAABB8MSAgABqLQAAIhBBAUYNAAJAIBBBfmoOBNIB0wHUAQDVAQsgASEBQdcAIRAM5wILIAFBAWoiASACRw0AC0HoACEQDP4CCwJAIAEiASACRw0AQekAIRAM/gILAkAgAS0AACIQQXZqDhq6AdUB1QG8AdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAcoB1QHVAQDTAQsgAUEBaiEBC0EGIRAM4wILA0ACQCABLQAAQfDGgIAAai0AAEEBRg0AIAEhAQyeAgsgAUEBaiIBIAJHDQALQeoAIRAM+wILAkAgASIBIAJGDQAgAUEBaiEBDAMLQesAIRAM+gILAkAgASIBIAJHDQBB7AAhEAz6AgsgAUEBaiEBDAELAkAgASIBIAJHDQBB7QAhEAz5AgsgAUEBaiEBC0EEIRAM3gILAkAgASIUIAJHDQBB7gAhEAz3AgsgFCEBAkACQAJAIBQtAABB8MiAgABqLQAAQX9qDgfUAdUB1gEAnAIBAtcBCyAUQQFqIQEMCgsgFEEBaiEBDM0BC0EAIRAgAEEANgIcIABBm5KAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAz2AgsCQANAAkAgAS0AAEHwyICAAGotAAAiEEEERg0AAkACQCAQQX9qDgfSAdMB1AHZAQAEAdkBCyABIQFB2gAhEAzgAgsgAUEBaiEBQdwAIRAM3wILIAFBAWoiASACRw0AC0HvACEQDPYCCyABQQFqIQEMywELAkAgASIUIAJHDQBB8AAhEAz1AgsgFC0AAEEvRw3UASAUQQFqIQEMBgsCQCABIhQgAkcNAEHxACEQDPQCCwJAIBQtAAAiAUEvRw0AIBRBAWohAUHdACEQDNsCCyABQXZqIgRBFksN0wFBASAEdEGJgIACcUUN0wEMygILAkAgASIBIAJGDQAgAUEBaiEBQd4AIRAM2gILQfIAIRAM8gILAkAgASIUIAJHDQBB9AAhEAzyAgsgFCEBAkAgFC0AAEHwzICAAGotAABBf2oOA8kClAIA1AELQeEAIRAM2AILAkAgASIUIAJGDQADQAJAIBQtAABB8MqAgABqLQAAIgFBA0YNAAJAIAFBf2oOAssCANUBCyAUIQFB3wAhEAzaAgsgFEEBaiIUIAJHDQALQfMAIRAM8QILQfMAIRAM8AILAkAgASIBIAJGDQAgAEGPgICAADYCCCAAIAE2AgQgASEBQeAAIRAM1wILQfUAIRAM7wILAkAgASIBIAJHDQBB9gAhEAzvAgsgAEGPgICAADYCCCAAIAE2AgQgASEBC0EDIRAM1AILA0AgAS0AAEEgRw3DAiABQQFqIgEgAkcNAAtB9wAhEAzsAgsCQCABIgEgAkcNAEH4ACEQDOwCCyABLQAAQSBHDc4BIAFBAWohAQzvAQsgACABIgEgAhCsgICAACIQDc4BIAEhAQyOAgsCQCABIgQgAkcNAEH6ACEQDOoCCyAELQAAQcwARw3RASAEQQFqIQFBEyEQDM8BCwJAIAEiBCACRw0AQfsAIRAM6QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEANAIAQtAAAgAUHwzoCAAGotAABHDdABIAFBBUYNzgEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBB+wAhEAzoAgsCQCABIgQgAkcNAEH8ACEQDOgCCwJAAkAgBC0AAEG9f2oODADRAdEB0QHRAdEB0QHRAdEB0QHRAQHRAQsgBEEBaiEBQeYAIRAMzwILIARBAWohAUHnACEQDM4CCwJAIAEiBCACRw0AQf0AIRAM5wILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNzwEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf0AIRAM5wILIABBADYCACAQQQFqIQFBECEQDMwBCwJAIAEiBCACRw0AQf4AIRAM5gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQfbOgIAAai0AAEcNzgEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf4AIRAM5gILIABBADYCACAQQQFqIQFBFiEQDMsBCwJAIAEiBCACRw0AQf8AIRAM5QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQfzOgIAAai0AAEcNzQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf8AIRAM5QILIABBADYCACAQQQFqIQFBBSEQDMoBCwJAIAEiBCACRw0AQYABIRAM5AILIAQtAABB2QBHDcsBIARBAWohAUEIIRAMyQELAkAgASIEIAJHDQBBgQEhEAzjAgsCQAJAIAQtAABBsn9qDgMAzAEBzAELIARBAWohAUHrACEQDMoCCyAEQQFqIQFB7AAhEAzJAgsCQCABIgQgAkcNAEGCASEQDOICCwJAAkAgBC0AAEG4f2oOCADLAcsBywHLAcsBywEBywELIARBAWohAUHqACEQDMkCCyAEQQFqIQFB7QAhEAzIAgsCQCABIgQgAkcNAEGDASEQDOECCyACIARrIAAoAgAiAWohECAEIAFrQQJqIRQCQANAIAQtAAAgAUGAz4CAAGotAABHDckBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgEDYCAEGDASEQDOECC0EAIRAgAEEANgIAIBRBAWohAQzGAQsCQCABIgQgAkcNAEGEASEQDOACCyACIARrIAAoAgAiAWohFCAEIAFrQQRqIRACQANAIAQtAAAgAUGDz4CAAGotAABHDcgBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGEASEQDOACCyAAQQA2AgAgEEEBaiEBQSMhEAzFAQsCQCABIgQgAkcNAEGFASEQDN8CCwJAAkAgBC0AAEG0f2oOCADIAcgByAHIAcgByAEByAELIARBAWohAUHvACEQDMYCCyAEQQFqIQFB8AAhEAzFAgsCQCABIgQgAkcNAEGGASEQDN4CCyAELQAAQcUARw3FASAEQQFqIQEMgwILAkAgASIEIAJHDQBBhwEhEAzdAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBiM+AgABqLQAARw3FASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhwEhEAzdAgsgAEEANgIAIBBBAWohAUEtIRAMwgELAkAgASIEIAJHDQBBiAEhEAzcAgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw3EASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiAEhEAzcAgsgAEEANgIAIBBBAWohAUEpIRAMwQELAkAgASIBIAJHDQBBiQEhEAzbAgtBASEQIAEtAABB3wBHDcABIAFBAWohAQyBAgsCQCABIgQgAkcNAEGKASEQDNoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRADQCAELQAAIAFBjM+AgABqLQAARw3BASABQQFGDa8CIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYoBIRAM2QILAkAgASIEIAJHDQBBiwEhEAzZAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBjs+AgABqLQAARw3BASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiwEhEAzZAgsgAEEANgIAIBBBAWohAUECIRAMvgELAkAgASIEIAJHDQBBjAEhEAzYAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw3AASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjAEhEAzYAgsgAEEANgIAIBBBAWohAUEfIRAMvQELAkAgASIEIAJHDQBBjQEhEAzXAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8s+AgABqLQAARw2/ASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjQEhEAzXAgsgAEEANgIAIBBBAWohAUEJIRAMvAELAkAgASIEIAJHDQBBjgEhEAzWAgsCQAJAIAQtAABBt39qDgcAvwG/Ab8BvwG/AQG/AQsgBEEBaiEBQfgAIRAMvQILIARBAWohAUH5ACEQDLwCCwJAIAEiBCACRw0AQY8BIRAM1QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQZHPgIAAai0AAEcNvQEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY8BIRAM1QILIABBADYCACAQQQFqIQFBGCEQDLoBCwJAIAEiBCACRw0AQZABIRAM1AILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQZfPgIAAai0AAEcNvAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZABIRAM1AILIABBADYCACAQQQFqIQFBFyEQDLkBCwJAIAEiBCACRw0AQZEBIRAM0wILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQZrPgIAAai0AAEcNuwEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZEBIRAM0wILIABBADYCACAQQQFqIQFBFSEQDLgBCwJAIAEiBCACRw0AQZIBIRAM0gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQaHPgIAAai0AAEcNugEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZIBIRAM0gILIABBADYCACAQQQFqIQFBHiEQDLcBCwJAIAEiBCACRw0AQZMBIRAM0QILIAQtAABBzABHDbgBIARBAWohAUEKIRAMtgELAkAgBCACRw0AQZQBIRAM0AILAkACQCAELQAAQb9/ag4PALkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AbkBAbkBCyAEQQFqIQFB/gAhEAy3AgsgBEEBaiEBQf8AIRAMtgILAkAgBCACRw0AQZUBIRAMzwILAkACQCAELQAAQb9/ag4DALgBAbgBCyAEQQFqIQFB/QAhEAy2AgsgBEEBaiEEQYABIRAMtQILAkAgBCACRw0AQZYBIRAMzgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQafPgIAAai0AAEcNtgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZYBIRAMzgILIABBADYCACAQQQFqIQFBCyEQDLMBCwJAIAQgAkcNAEGXASEQDM0CCwJAAkACQAJAIAQtAABBU2oOIwC4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBAbgBuAG4AbgBuAECuAG4AbgBA7gBCyAEQQFqIQFB+wAhEAy2AgsgBEEBaiEBQfwAIRAMtQILIARBAWohBEGBASEQDLQCCyAEQQFqIQRBggEhEAyzAgsCQCAEIAJHDQBBmAEhEAzMAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBqc+AgABqLQAARw20ASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmAEhEAzMAgsgAEEANgIAIBBBAWohAUEZIRAMsQELAkAgBCACRw0AQZkBIRAMywILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQa7PgIAAai0AAEcNswEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZkBIRAMywILIABBADYCACAQQQFqIQFBBiEQDLABCwJAIAQgAkcNAEGaASEQDMoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG0z4CAAGotAABHDbIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGaASEQDMoCCyAAQQA2AgAgEEEBaiEBQRwhEAyvAQsCQCAEIAJHDQBBmwEhEAzJAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBts+AgABqLQAARw2xASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmwEhEAzJAgsgAEEANgIAIBBBAWohAUEnIRAMrgELAkAgBCACRw0AQZwBIRAMyAILAkACQCAELQAAQax/ag4CAAGxAQsgBEEBaiEEQYYBIRAMrwILIARBAWohBEGHASEQDK4CCwJAIAQgAkcNAEGdASEQDMcCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG4z4CAAGotAABHDa8BIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGdASEQDMcCCyAAQQA2AgAgEEEBaiEBQSYhEAysAQsCQCAEIAJHDQBBngEhEAzGAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBus+AgABqLQAARw2uASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBngEhEAzGAgsgAEEANgIAIBBBAWohAUEDIRAMqwELAkAgBCACRw0AQZ8BIRAMxQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNrQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ8BIRAMxQILIABBADYCACAQQQFqIQFBDCEQDKoBCwJAIAQgAkcNAEGgASEQDMQCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUG8z4CAAGotAABHDawBIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGgASEQDMQCCyAAQQA2AgAgEEEBaiEBQQ0hEAypAQsCQCAEIAJHDQBBoQEhEAzDAgsCQAJAIAQtAABBun9qDgsArAGsAawBrAGsAawBrAGsAawBAawBCyAEQQFqIQRBiwEhEAyqAgsgBEEBaiEEQYwBIRAMqQILAkAgBCACRw0AQaIBIRAMwgILIAQtAABB0ABHDakBIARBAWohBAzpAQsCQCAEIAJHDQBBowEhEAzBAgsCQAJAIAQtAABBt39qDgcBqgGqAaoBqgGqAQCqAQsgBEEBaiEEQY4BIRAMqAILIARBAWohAUEiIRAMpgELAkAgBCACRw0AQaQBIRAMwAILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQcDPgIAAai0AAEcNqAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaQBIRAMwAILIABBADYCACAQQQFqIQFBHSEQDKUBCwJAIAQgAkcNAEGlASEQDL8CCwJAAkAgBC0AAEGuf2oOAwCoAQGoAQsgBEEBaiEEQZABIRAMpgILIARBAWohAUEEIRAMpAELAkAgBCACRw0AQaYBIRAMvgILAkACQAJAAkACQCAELQAAQb9/ag4VAKoBqgGqAaoBqgGqAaoBqgGqAaoBAaoBqgECqgGqAQOqAaoBBKoBCyAEQQFqIQRBiAEhEAyoAgsgBEEBaiEEQYkBIRAMpwILIARBAWohBEGKASEQDKYCCyAEQQFqIQRBjwEhEAylAgsgBEEBaiEEQZEBIRAMpAILAkAgBCACRw0AQacBIRAMvQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNpQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQacBIRAMvQILIABBADYCACAQQQFqIQFBESEQDKIBCwJAIAQgAkcNAEGoASEQDLwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHCz4CAAGotAABHDaQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGoASEQDLwCCyAAQQA2AgAgEEEBaiEBQSwhEAyhAQsCQCAEIAJHDQBBqQEhEAy7AgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBxc+AgABqLQAARw2jASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqQEhEAy7AgsgAEEANgIAIBBBAWohAUErIRAMoAELAkAgBCACRw0AQaoBIRAMugILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQcrPgIAAai0AAEcNogEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaoBIRAMugILIABBADYCACAQQQFqIQFBFCEQDJ8BCwJAIAQgAkcNAEGrASEQDLkCCwJAAkACQAJAIAQtAABBvn9qDg8AAQKkAaQBpAGkAaQBpAGkAaQBpAGkAaQBA6QBCyAEQQFqIQRBkwEhEAyiAgsgBEEBaiEEQZQBIRAMoQILIARBAWohBEGVASEQDKACCyAEQQFqIQRBlgEhEAyfAgsCQCAEIAJHDQBBrAEhEAy4AgsgBC0AAEHFAEcNnwEgBEEBaiEEDOABCwJAIAQgAkcNAEGtASEQDLcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHNz4CAAGotAABHDZ8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGtASEQDLcCCyAAQQA2AgAgEEEBaiEBQQ4hEAycAQsCQCAEIAJHDQBBrgEhEAy2AgsgBC0AAEHQAEcNnQEgBEEBaiEBQSUhEAybAQsCQCAEIAJHDQBBrwEhEAy1AgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw2dASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrwEhEAy1AgsgAEEANgIAIBBBAWohAUEqIRAMmgELAkAgBCACRw0AQbABIRAMtAILAkACQCAELQAAQat/ag4LAJ0BnQGdAZ0BnQGdAZ0BnQGdAQGdAQsgBEEBaiEEQZoBIRAMmwILIARBAWohBEGbASEQDJoCCwJAIAQgAkcNAEGxASEQDLMCCwJAAkAgBC0AAEG/f2oOFACcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAEBnAELIARBAWohBEGZASEQDJoCCyAEQQFqIQRBnAEhEAyZAgsCQCAEIAJHDQBBsgEhEAyyAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFB2c+AgABqLQAARw2aASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBsgEhEAyyAgsgAEEANgIAIBBBAWohAUEhIRAMlwELAkAgBCACRw0AQbMBIRAMsQILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQd3PgIAAai0AAEcNmQEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbMBIRAMsQILIABBADYCACAQQQFqIQFBGiEQDJYBCwJAIAQgAkcNAEG0ASEQDLACCwJAAkACQCAELQAAQbt/ag4RAJoBmgGaAZoBmgGaAZoBmgGaAQGaAZoBmgGaAZoBApoBCyAEQQFqIQRBnQEhEAyYAgsgBEEBaiEEQZ4BIRAMlwILIARBAWohBEGfASEQDJYCCwJAIAQgAkcNAEG1ASEQDK8CCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUHkz4CAAGotAABHDZcBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG1ASEQDK8CCyAAQQA2AgAgEEEBaiEBQSghEAyUAQsCQCAEIAJHDQBBtgEhEAyuAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB6s+AgABqLQAARw2WASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtgEhEAyuAgsgAEEANgIAIBBBAWohAUEHIRAMkwELAkAgBCACRw0AQbcBIRAMrQILAkACQCAELQAAQbt/ag4OAJYBlgGWAZYBlgGWAZYBlgGWAZYBlgGWAQGWAQsgBEEBaiEEQaEBIRAMlAILIARBAWohBEGiASEQDJMCCwJAIAQgAkcNAEG4ASEQDKwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDZQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG4ASEQDKwCCyAAQQA2AgAgEEEBaiEBQRIhEAyRAQsCQCAEIAJHDQBBuQEhEAyrAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw2TASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuQEhEAyrAgsgAEEANgIAIBBBAWohAUEgIRAMkAELAkAgBCACRw0AQboBIRAMqgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNkgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQboBIRAMqgILIABBADYCACAQQQFqIQFBDyEQDI8BCwJAIAQgAkcNAEG7ASEQDKkCCwJAAkAgBC0AAEG3f2oOBwCSAZIBkgGSAZIBAZIBCyAEQQFqIQRBpQEhEAyQAgsgBEEBaiEEQaYBIRAMjwILAkAgBCACRw0AQbwBIRAMqAILIAIgBGsgACgCACIBaiEUIAQgAWtBB2ohEAJAA0AgBC0AACABQfTPgIAAai0AAEcNkAEgAUEHRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbwBIRAMqAILIABBADYCACAQQQFqIQFBGyEQDI0BCwJAIAQgAkcNAEG9ASEQDKcCCwJAAkACQCAELQAAQb5/ag4SAJEBkQGRAZEBkQGRAZEBkQGRAQGRAZEBkQGRAZEBkQECkQELIARBAWohBEGkASEQDI8CCyAEQQFqIQRBpwEhEAyOAgsgBEEBaiEEQagBIRAMjQILAkAgBCACRw0AQb4BIRAMpgILIAQtAABBzgBHDY0BIARBAWohBAzPAQsCQCAEIAJHDQBBvwEhEAylAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAELQAAQb9/ag4VAAECA5wBBAUGnAGcAZwBBwgJCgucAQwNDg+cAQsgBEEBaiEBQegAIRAMmgILIARBAWohAUHpACEQDJkCCyAEQQFqIQFB7gAhEAyYAgsgBEEBaiEBQfIAIRAMlwILIARBAWohAUHzACEQDJYCCyAEQQFqIQFB9gAhEAyVAgsgBEEBaiEBQfcAIRAMlAILIARBAWohAUH6ACEQDJMCCyAEQQFqIQRBgwEhEAySAgsgBEEBaiEEQYQBIRAMkQILIARBAWohBEGFASEQDJACCyAEQQFqIQRBkgEhEAyPAgsgBEEBaiEEQZgBIRAMjgILIARBAWohBEGgASEQDI0CCyAEQQFqIQRBowEhEAyMAgsgBEEBaiEEQaoBIRAMiwILAkAgBCACRg0AIABBkICAgAA2AgggACAENgIEQasBIRAMiwILQcABIRAMowILIAAgBSACEKqAgIAAIgENiwEgBSEBDFwLAkAgBiACRg0AIAZBAWohBQyNAQtBwgEhEAyhAgsDQAJAIBAtAABBdmoOBIwBAACPAQALIBBBAWoiECACRw0AC0HDASEQDKACCwJAIAcgAkYNACAAQZGAgIAANgIIIAAgBzYCBCAHIQFBASEQDIcCC0HEASEQDJ8CCwJAIAcgAkcNAEHFASEQDJ8CCwJAAkAgBy0AAEF2ag4EAc4BzgEAzgELIAdBAWohBgyNAQsgB0EBaiEFDIkBCwJAIAcgAkcNAEHGASEQDJ4CCwJAAkAgBy0AAEF2ag4XAY8BjwEBjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAI8BCyAHQQFqIQcLQbABIRAMhAILAkAgCCACRw0AQcgBIRAMnQILIAgtAABBIEcNjQEgAEEAOwEyIAhBAWohAUGzASEQDIMCCyABIRcCQANAIBciByACRg0BIActAABBUGpB/wFxIhBBCk8NzAECQCAALwEyIhRBmTNLDQAgACAUQQpsIhQ7ATIgEEH//wNzIBRB/v8DcUkNACAHQQFqIRcgACAUIBBqIhA7ATIgEEH//wNxQegHSQ0BCwtBACEQIABBADYCHCAAQcGJgIAANgIQIABBDTYCDCAAIAdBAWo2AhQMnAILQccBIRAMmwILIAAgCCACEK6AgIAAIhBFDcoBIBBBFUcNjAEgAEHIATYCHCAAIAg2AhQgAEHJl4CAADYCECAAQRU2AgxBACEQDJoCCwJAIAkgAkcNAEHMASEQDJoCC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgCS0AAEFQag4KlgGVAQABAgMEBQYIlwELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMjgELQQkhEEEBIRRBACEXQQAhFgyNAQsCQCAKIAJHDQBBzgEhEAyZAgsgCi0AAEEuRw2OASAKQQFqIQkMygELIAsgAkcNjgFB0AEhEAyXAgsCQCALIAJGDQAgAEGOgICAADYCCCAAIAs2AgRBtwEhEAz+AQtB0QEhEAyWAgsCQCAEIAJHDQBB0gEhEAyWAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EEaiELA0AgBC0AACAQQfzPgIAAai0AAEcNjgEgEEEERg3pASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHSASEQDJUCCyAAIAwgAhCsgICAACIBDY0BIAwhAQy4AQsCQCAEIAJHDQBB1AEhEAyUAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EBaiEMA0AgBC0AACAQQYHQgIAAai0AAEcNjwEgEEEBRg2OASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHUASEQDJMCCwJAIAQgAkcNAEHWASEQDJMCCyACIARrIAAoAgAiEGohFCAEIBBrQQJqIQsDQCAELQAAIBBBg9CAgABqLQAARw2OASAQQQJGDZABIBBBAWohECAEQQFqIgQgAkcNAAsgACAUNgIAQdYBIRAMkgILAkAgBCACRw0AQdcBIRAMkgILAkACQCAELQAAQbt/ag4QAI8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwEBjwELIARBAWohBEG7ASEQDPkBCyAEQQFqIQRBvAEhEAz4AQsCQCAEIAJHDQBB2AEhEAyRAgsgBC0AAEHIAEcNjAEgBEEBaiEEDMQBCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEG+ASEQDPcBC0HZASEQDI8CCwJAIAQgAkcNAEHaASEQDI8CCyAELQAAQcgARg3DASAAQQE6ACgMuQELIABBAjoALyAAIAQgAhCmgICAACIQDY0BQcIBIRAM9AELIAAtAChBf2oOArcBuQG4AQsDQAJAIAQtAABBdmoOBACOAY4BAI4BCyAEQQFqIgQgAkcNAAtB3QEhEAyLAgsgAEEAOgAvIAAtAC1BBHFFDYQCCyAAQQA6AC8gAEEBOgA0IAEhAQyMAQsgEEEVRg3aASAAQQA2AhwgACABNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAyIAgsCQCAAIBAgAhC0gICAACIEDQAgECEBDIECCwJAIARBFUcNACAAQQM2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAyIAgsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMhwILIBBBFUYN1gEgAEEANgIcIAAgATYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMhgILIAAoAgQhFyAAQQA2AgQgECARp2oiFiEBIAAgFyAQIBYgFBsiEBC1gICAACIURQ2NASAAQQc2AhwgACAQNgIUIAAgFDYCDEEAIRAMhQILIAAgAC8BMEGAAXI7ATAgASEBC0EqIRAM6gELIBBBFUYN0QEgAEEANgIcIAAgATYCFCAAQYOMgIAANgIQIABBEzYCDEEAIRAMggILIBBBFUYNzwEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAMgQILIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDI0BCyAAQQw2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMgAILIBBBFUYNzAEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM/wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIwBCyAAQQ02AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/gELIBBBFUYNyQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM/QELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIsBCyAAQQ42AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/AELIABBADYCHCAAIAE2AhQgAEHAlYCAADYCECAAQQI2AgxBACEQDPsBCyAQQRVGDcUBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPoBCyAAQRA2AhwgACABNgIUIAAgEDYCDEEAIRAM+QELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDPEBCyAAQRE2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM+AELIBBBFUYNwQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM9wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIgBCyAAQRM2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM9gELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDO0BCyAAQRQ2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM9QELIBBBFUYNvQEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM9AELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIYBCyAAQRY2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM8wELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC3gICAACIEDQAgAUEBaiEBDOkBCyAAQRc2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM8gELIABBADYCHCAAIAE2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDPEBC0IBIRELIBBBAWohAQJAIAApAyAiEkL//////////w9WDQAgACASQgSGIBGENwMgIAEhAQyEAQsgAEEANgIcIAAgATYCFCAAQa2JgIAANgIQIABBDDYCDEEAIRAM7wELIABBADYCHCAAIBA2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDO4BCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNcyAAQQU2AhwgACAQNgIUIAAgFDYCDEEAIRAM7QELIABBADYCHCAAIBA2AhQgAEGqnICAADYCECAAQQ82AgxBACEQDOwBCyAAIBAgAhC0gICAACIBDQEgECEBC0EOIRAM0QELAkAgAUEVRw0AIABBAjYCHCAAIBA2AhQgAEGwmICAADYCECAAQRU2AgxBACEQDOoBCyAAQQA2AhwgACAQNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAzpAQsgAUEBaiEQAkAgAC8BMCIBQYABcUUNAAJAIAAgECACELuAgIAAIgENACAQIQEMcAsgAUEVRw26ASAAQQU2AhwgACAQNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAzpAQsCQCABQaAEcUGgBEcNACAALQAtQQJxDQAgAEEANgIcIAAgEDYCFCAAQZaTgIAANgIQIABBBDYCDEEAIRAM6QELIAAgECACEL2AgIAAGiAQIQECQAJAAkACQAJAIAAgECACELOAgIAADhYCAQAEBAQEBAQEBAQEBAQEBAQEBAQDBAsgAEEBOgAuCyAAIAAvATBBwAByOwEwIBAhAQtBJiEQDNEBCyAAQSM2AhwgACAQNgIUIABBpZaAgAA2AhAgAEEVNgIMQQAhEAzpAQsgAEEANgIcIAAgEDYCFCAAQdWLgIAANgIQIABBETYCDEEAIRAM6AELIAAtAC1BAXFFDQFBwwEhEAzOAQsCQCANIAJGDQADQAJAIA0tAABBIEYNACANIQEMxAELIA1BAWoiDSACRw0AC0ElIRAM5wELQSUhEAzmAQsgACgCBCEEIABBADYCBCAAIAQgDRCvgICAACIERQ2tASAAQSY2AhwgACAENgIMIAAgDUEBajYCFEEAIRAM5QELIBBBFUYNqwEgAEEANgIcIAAgATYCFCAAQf2NgIAANgIQIABBHTYCDEEAIRAM5AELIABBJzYCHCAAIAE2AhQgACAQNgIMQQAhEAzjAQsgECEBQQEhFAJAAkACQAJAAkACQAJAIAAtACxBfmoOBwYFBQMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0ErIRAMygELIABBADYCHCAAIBA2AhQgAEGrkoCAADYCECAAQQs2AgxBACEQDOIBCyAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMQQAhEAzhAQsgAEEAOgAsIBAhAQy9AQsgECEBQQEhFAJAAkACQAJAAkAgAC0ALEF7ag4EAwECAAULIAAgAC8BMEEIcjsBMAwDC0ECIRQMAQtBBCEUCyAAQQE6ACwgACAALwEwIBRyOwEwCyAQIQELQSkhEAzFAQsgAEEANgIcIAAgATYCFCAAQfCUgIAANgIQIABBAzYCDEEAIRAM3QELAkAgDi0AAEENRw0AIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHULIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzdAQsgAC0ALUEBcUUNAUHEASEQDMMBCwJAIA4gAkcNAEEtIRAM3AELAkACQANAAkAgDi0AAEF2ag4EAgAAAwALIA5BAWoiDiACRw0AC0EtIRAM3QELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDiEBDHQLIABBLDYCHCAAIA42AhQgACABNgIMQQAhEAzcAQsgACgCBCEBIABBADYCBAJAIAAgASAOELGAgIAAIgENACAOQQFqIQEMcwsgAEEsNgIcIAAgATYCDCAAIA5BAWo2AhRBACEQDNsBCyAAKAIEIQQgAEEANgIEIAAgBCAOELGAgIAAIgQNoAEgDiEBDM4BCyAQQSxHDQEgAUEBaiEQQQEhAQJAAkACQAJAAkAgAC0ALEF7ag4EAwECBAALIBAhAQwEC0ECIQEMAQtBBCEBCyAAQQE6ACwgACAALwEwIAFyOwEwIBAhAQwBCyAAIAAvATBBCHI7ATAgECEBC0E5IRAMvwELIABBADoALCABIQELQTQhEAy9AQsgACAALwEwQSByOwEwIAEhAQwCCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBA0AIAEhAQzHAQsgAEE3NgIcIAAgATYCFCAAIAQ2AgxBACEQDNQBCyAAQQg6ACwgASEBC0EwIRAMuQELAkAgAC0AKEEBRg0AIAEhAQwECyAALQAtQQhxRQ2TASABIQEMAwsgAC0AMEEgcQ2UAUHFASEQDLcBCwJAIA8gAkYNAAJAA0ACQCAPLQAAQVBqIgFB/wFxQQpJDQAgDyEBQTUhEAy6AQsgACkDICIRQpmz5syZs+bMGVYNASAAIBFCCn4iETcDICARIAGtQv8BgyISQn+FVg0BIAAgESASfDcDICAPQQFqIg8gAkcNAAtBOSEQDNEBCyAAKAIEIQIgAEEANgIEIAAgAiAPQQFqIgQQsYCAgAAiAg2VASAEIQEMwwELQTkhEAzPAQsCQCAALwEwIgFBCHFFDQAgAC0AKEEBRw0AIAAtAC1BCHFFDZABCyAAIAFB9/sDcUGABHI7ATAgDyEBC0E3IRAMtAELIAAgAC8BMEEQcjsBMAyrAQsgEEEVRg2LASAAQQA2AhwgACABNgIUIABB8I6AgAA2AhAgAEEcNgIMQQAhEAzLAQsgAEHDADYCHCAAIAE2AgwgACANQQFqNgIUQQAhEAzKAQsCQCABLQAAQTpHDQAgACgCBCEQIABBADYCBAJAIAAgECABEK+AgIAAIhANACABQQFqIQEMYwsgAEHDADYCHCAAIBA2AgwgACABQQFqNgIUQQAhEAzKAQsgAEEANgIcIAAgATYCFCAAQbGRgIAANgIQIABBCjYCDEEAIRAMyQELIABBADYCHCAAIAE2AhQgAEGgmYCAADYCECAAQR42AgxBACEQDMgBCyAAQQA2AgALIABBgBI7ASogACAXQQFqIgEgAhCogICAACIQDQEgASEBC0HHACEQDKwBCyAQQRVHDYMBIABB0QA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAzEAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAzDAQsgAEEANgIcIAAgFDYCFCAAQcGogIAANgIQIABBBzYCDCAAQQA2AgBBACEQDMIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxdCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDMEBC0EAIRAgAEEANgIcIAAgATYCFCAAQYCRgIAANgIQIABBCTYCDAzAAQsgEEEVRg19IABBADYCHCAAIAE2AhQgAEGUjYCAADYCECAAQSE2AgxBACEQDL8BC0EBIRZBACEXQQAhFEEBIRALIAAgEDoAKyABQQFqIQECQAJAIAAtAC1BEHENAAJAAkACQCAALQAqDgMBAAIECyAWRQ0DDAILIBQNAQwCCyAXRQ0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQrYCAgAAiEA0AIAEhAQxcCyAAQdgANgIcIAAgATYCFCAAIBA2AgxBACEQDL4BCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQytAQsgAEHZADYCHCAAIAE2AhQgACAENgIMQQAhEAy9AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMqwELIABB2gA2AhwgACABNgIUIAAgBDYCDEEAIRAMvAELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKkBCyAAQdwANgIcIAAgATYCFCAAIAQ2AgxBACEQDLsBCwJAIAEtAABBUGoiEEH/AXFBCk8NACAAIBA6ACogAUEBaiEBQc8AIRAMogELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKcBCyAAQd4ANgIcIAAgATYCFCAAIAQ2AgxBACEQDLoBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKUEjTw0AIAEhAQxZCyAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMQQAhEAy5AQsgAEEANgIAC0EAIRAgAEEANgIcIAAgATYCFCAAQZCzgIAANgIQIABBCDYCDAy3AQsgAEEANgIAIBdBAWohAQJAIAAtAClBIUcNACABIQEMVgsgAEEANgIcIAAgATYCFCAAQZuKgIAANgIQIABBCDYCDEEAIRAMtgELIABBADYCACAXQQFqIQECQCAALQApIhBBXWpBC08NACABIQEMVQsCQCAQQQZLDQBBASAQdEHKAHFFDQAgASEBDFULQQAhECAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMDLUBCyAQQRVGDXEgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMtAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFQLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMswELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMsgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMsQELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFELIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMsAELIABBADYCHCAAIAE2AhQgAEHGioCAADYCECAAQQc2AgxBACEQDK8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDK4BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDK0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDKwBCyAAQQA2AhwgACABNgIUIABB3IiAgAA2AhAgAEEHNgIMQQAhEAyrAQsgEEE/Rw0BIAFBAWohAQtBBSEQDJABC0EAIRAgAEEANgIcIAAgATYCFCAAQf2SgIAANgIQIABBBzYCDAyoAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAynAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAymAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMRgsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAylAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHSADYCHCAAIBQ2AhQgACABNgIMQQAhEAykAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHTADYCHCAAIBQ2AhQgACABNgIMQQAhEAyjAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMQwsgAEHlADYCHCAAIBQ2AhQgACABNgIMQQAhEAyiAQsgAEEANgIcIAAgFDYCFCAAQcOPgIAANgIQIABBBzYCDEEAIRAMoQELIABBADYCHCAAIAE2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKABC0EAIRAgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDAyfAQsgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDEEAIRAMngELIABBADYCHCAAIBQ2AhQgAEH+kYCAADYCECAAQQc2AgxBACEQDJ0BCyAAQQA2AhwgACABNgIUIABBjpuAgAA2AhAgAEEGNgIMQQAhEAycAQsgEEEVRg1XIABBADYCHCAAIAE2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDJsBCyAAQQA2AgAgEEEBaiEBQSQhEAsgACAQOgApIAAoAgQhECAAQQA2AgQgACAQIAEQq4CAgAAiEA1UIAEhAQw+CyAAQQA2AgALQQAhECAAQQA2AhwgACAENgIUIABB8ZuAgAA2AhAgAEEGNgIMDJcBCyABQRVGDVAgAEEANgIcIAAgBTYCFCAAQfCMgIAANgIQIABBGzYCDEEAIRAMlgELIAAoAgQhBSAAQQA2AgQgACAFIBAQqYCAgAAiBQ0BIBBBAWohBQtBrQEhEAx7CyAAQcEBNgIcIAAgBTYCDCAAIBBBAWo2AhRBACEQDJMBCyAAKAIEIQYgAEEANgIEIAAgBiAQEKmAgIAAIgYNASAQQQFqIQYLQa4BIRAMeAsgAEHCATYCHCAAIAY2AgwgACAQQQFqNgIUQQAhEAyQAQsgAEEANgIcIAAgBzYCFCAAQZeLgIAANgIQIABBDTYCDEEAIRAMjwELIABBADYCHCAAIAg2AhQgAEHjkICAADYCECAAQQk2AgxBACEQDI4BCyAAQQA2AhwgACAINgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAyNAQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgCUEBaiEIAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBCAAIBAgCBCtgICAACIQRQ09IABByQE2AhwgACAINgIUIAAgEDYCDEEAIRAMjAELIAAoAgQhBCAAQQA2AgQgACAEIAgQrYCAgAAiBEUNdiAAQcoBNgIcIAAgCDYCFCAAIAQ2AgxBACEQDIsBCyAAKAIEIQQgAEEANgIEIAAgBCAJEK2AgIAAIgRFDXQgAEHLATYCHCAAIAk2AhQgACAENgIMQQAhEAyKAQsgACgCBCEEIABBADYCBCAAIAQgChCtgICAACIERQ1yIABBzQE2AhwgACAKNgIUIAAgBDYCDEEAIRAMiQELAkAgCy0AAEFQaiIQQf8BcUEKTw0AIAAgEDoAKiALQQFqIQpBtgEhEAxwCyAAKAIEIQQgAEEANgIEIAAgBCALEK2AgIAAIgRFDXAgAEHPATYCHCAAIAs2AhQgACAENgIMQQAhEAyIAQsgAEEANgIcIAAgBDYCFCAAQZCzgIAANgIQIABBCDYCDCAAQQA2AgBBACEQDIcBCyABQRVGDT8gAEEANgIcIAAgDDYCFCAAQcyOgIAANgIQIABBIDYCDEEAIRAMhgELIABBgQQ7ASggACgCBCEQIABCADcDACAAIBAgDEEBaiIMEKuAgIAAIhBFDTggAEHTATYCHCAAIAw2AhQgACAQNgIMQQAhEAyFAQsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQdibgIAANgIQIABBCDYCDAyDAQsgACgCBCEQIABCADcDACAAIBAgC0EBaiILEKuAgIAAIhANAUHGASEQDGkLIABBAjoAKAxVCyAAQdUBNgIcIAAgCzYCFCAAIBA2AgxBACEQDIABCyAQQRVGDTcgAEEANgIcIAAgBDYCFCAAQaSMgIAANgIQIABBEDYCDEEAIRAMfwsgAC0ANEEBRw00IAAgBCACELyAgIAAIhBFDTQgEEEVRw01IABB3AE2AhwgACAENgIUIABB1ZaAgAA2AhAgAEEVNgIMQQAhEAx+C0EAIRAgAEEANgIcIABBr4uAgAA2AhAgAEECNgIMIAAgFEEBajYCFAx9C0EAIRAMYwtBAiEQDGILQQ0hEAxhC0EPIRAMYAtBJSEQDF8LQRMhEAxeC0EVIRAMXQtBFiEQDFwLQRchEAxbC0EYIRAMWgtBGSEQDFkLQRohEAxYC0EbIRAMVwtBHCEQDFYLQR0hEAxVC0EfIRAMVAtBISEQDFMLQSMhEAxSC0HGACEQDFELQS4hEAxQC0EvIRAMTwtBOyEQDE4LQT0hEAxNC0HIACEQDEwLQckAIRAMSwtBywAhEAxKC0HMACEQDEkLQc4AIRAMSAtB0QAhEAxHC0HVACEQDEYLQdgAIRAMRQtB2QAhEAxEC0HbACEQDEMLQeQAIRAMQgtB5QAhEAxBC0HxACEQDEALQfQAIRAMPwtBjQEhEAw+C0GXASEQDD0LQakBIRAMPAtBrAEhEAw7C0HAASEQDDoLQbkBIRAMOQtBrwEhEAw4C0GxASEQDDcLQbIBIRAMNgtBtAEhEAw1C0G1ASEQDDQLQboBIRAMMwtBvQEhEAwyC0G/ASEQDDELQcEBIRAMMAsgAEEANgIcIAAgBDYCFCAAQemLgIAANgIQIABBHzYCDEEAIRAMSAsgAEHbATYCHCAAIAQ2AhQgAEH6loCAADYCECAAQRU2AgxBACEQDEcLIABB+AA2AhwgACAMNgIUIABBypiAgAA2AhAgAEEVNgIMQQAhEAxGCyAAQdEANgIcIAAgBTYCFCAAQbCXgIAANgIQIABBFTYCDEEAIRAMRQsgAEH5ADYCHCAAIAE2AhQgACAQNgIMQQAhEAxECyAAQfgANgIcIAAgATYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMQwsgAEHkADYCHCAAIAE2AhQgAEHjl4CAADYCECAAQRU2AgxBACEQDEILIABB1wA2AhwgACABNgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAxBCyAAQQA2AhwgACABNgIUIABBuY2AgAA2AhAgAEEaNgIMQQAhEAxACyAAQcIANgIcIAAgATYCFCAAQeOYgIAANgIQIABBFTYCDEEAIRAMPwsgAEEANgIEIAAgDyAPELGAgIAAIgRFDQEgAEE6NgIcIAAgBDYCDCAAIA9BAWo2AhRBACEQDD4LIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCxgICAACIERQ0AIABBOzYCHCAAIAQ2AgwgACABQQFqNgIUQQAhEAw+CyABQQFqIQEMLQsgD0EBaiEBDC0LIABBADYCHCAAIA82AhQgAEHkkoCAADYCECAAQQQ2AgxBACEQDDsLIABBNjYCHCAAIAQ2AhQgACACNgIMQQAhEAw6CyAAQS42AhwgACAONgIUIAAgBDYCDEEAIRAMOQsgAEHQADYCHCAAIAE2AhQgAEGRmICAADYCECAAQRU2AgxBACEQDDgLIA1BAWohAQwsCyAAQRU2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAw2CyAAQRs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw1CyAAQQ82AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw0CyAAQQs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAwzCyAAQRo2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwyCyAAQQs2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwxCyAAQQo2AhwgACABNgIUIABB5JaAgAA2AhAgAEEVNgIMQQAhEAwwCyAAQR42AhwgACABNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAwvCyAAQQA2AhwgACAQNgIUIABB2o2AgAA2AhAgAEEUNgIMQQAhEAwuCyAAQQQ2AhwgACABNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAwtCyAAQQA2AgAgC0EBaiELC0G4ASEQDBILIABBADYCACAQQQFqIQFB9QAhEAwRCyABIQECQCAALQApQQVHDQBB4wAhEAwRC0HiACEQDBALQQAhECAAQQA2AhwgAEHkkYCAADYCECAAQQc2AgwgACAUQQFqNgIUDCgLIABBADYCACAXQQFqIQFBwAAhEAwOC0EBIQELIAAgAToALCAAQQA2AgAgF0EBaiEBC0EoIRAMCwsgASEBC0E4IRAMCQsCQCABIg8gAkYNAANAAkAgDy0AAEGAvoCAAGotAAAiAUEBRg0AIAFBAkcNAyAPQQFqIQEMBAsgD0EBaiIPIAJHDQALQT4hEAwiC0E+IRAMIQsgAEEAOgAsIA8hAQwBC0ELIRAMBgtBOiEQDAULIAFBAWohAUEtIRAMBAsgACABOgAsIABBADYCACAWQQFqIQFBDCEQDAMLIABBADYCACAXQQFqIQFBCiEQDAILIABBADYCAAsgAEEAOgAsIA0hAUEJIRAMAAsLQQAhECAAQQA2AhwgACALNgIUIABBzZCAgAA2AhAgAEEJNgIMDBcLQQAhECAAQQA2AhwgACAKNgIUIABB6YqAgAA2AhAgAEEJNgIMDBYLQQAhECAAQQA2AhwgACAJNgIUIABBt5CAgAA2AhAgAEEJNgIMDBULQQAhECAAQQA2AhwgACAINgIUIABBnJGAgAA2AhAgAEEJNgIMDBQLQQAhECAAQQA2AhwgACABNgIUIABBzZCAgAA2AhAgAEEJNgIMDBMLQQAhECAAQQA2AhwgACABNgIUIABB6YqAgAA2AhAgAEEJNgIMDBILQQAhECAAQQA2AhwgACABNgIUIABBt5CAgAA2AhAgAEEJNgIMDBELQQAhECAAQQA2AhwgACABNgIUIABBnJGAgAA2AhAgAEEJNgIMDBALQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA8LQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA4LQQAhECAAQQA2AhwgACABNgIUIABBwJKAgAA2AhAgAEELNgIMDA0LQQAhECAAQQA2AhwgACABNgIUIABBlYmAgAA2AhAgAEELNgIMDAwLQQAhECAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMDAsLQQAhECAAQQA2AhwgACABNgIUIABB+4+AgAA2AhAgAEEKNgIMDAoLQQAhECAAQQA2AhwgACABNgIUIABB8ZmAgAA2AhAgAEECNgIMDAkLQQAhECAAQQA2AhwgACABNgIUIABBxJSAgAA2AhAgAEECNgIMDAgLQQAhECAAQQA2AhwgACABNgIUIABB8pWAgAA2AhAgAEECNgIMDAcLIABBAjYCHCAAIAE2AhQgAEGcmoCAADYCECAAQRY2AgxBACEQDAYLQQEhEAwFC0HUACEQIAEiBCACRg0EIANBCGogACAEIAJB2MKAgABBChDFgICAACADKAIMIQQgAygCCA4DAQQCAAsQyoCAgAAACyAAQQA2AhwgAEG1moCAADYCECAAQRc2AgwgACAEQQFqNgIUQQAhEAwCCyAAQQA2AhwgACAENgIUIABBypqAgAA2AhAgAEEJNgIMQQAhEAwBCwJAIAEiBCACRw0AQSIhEAwBCyAAQYmAgIAANgIIIAAgBDYCBEEhIRALIANBEGokgICAgAAgEAuvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAEMeAgIAAC/I2AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKg0ICAAA0AQQAQy4CAgABBgNSEgABrIgJB2QBJDQBBACEDAkBBACgC4NOAgAAiBA0AQQBCfzcC7NOAgABBAEKAgISAgIDAADcC5NOAgABBACABQQhqQXBxQdiq1aoFcyIENgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgAALQQAgAjYCzNOAgABBAEGA1ISAADYCyNOAgABBAEGA1ISAADYCmNCAgABBACAENgKs0ICAAEEAQX82AqjQgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgNSEgABBeEGA1ISAAGtBD3FBAEGA1ISAAEEIakEPcRsiA2oiBEEEaiACQUhqIgUgA2siA0EBcjYCAEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgABBgNSEgAAgBWpBODYCBAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAUsNAAJAQQAoAojQgIAAIgZBECAAQRNqQXBxIABBC0kbIgJBA3YiBHYiA0EDcUUNAAJAAkAgA0EBcSAEckEBcyIFQQN0IgRBsNCAgABqIgMgBEG40ICAAGooAgAiBCgCCCICRw0AQQAgBkF+IAV3cTYCiNCAgAAMAQsgAyACNgIIIAIgAzYCDAsgBEEIaiEDIAQgBUEDdCIFQQNyNgIEIAQgBWoiBCAEKAIEQQFyNgIEDAwLIAJBACgCkNCAgAAiB00NAQJAIANFDQACQAJAIAMgBHRBAiAEdCIDQQAgA2tycSIDQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmoiBEEDdCIDQbDQgIAAaiIFIANBuNCAgABqKAIAIgMoAggiAEcNAEEAIAZBfiAEd3EiBjYCiNCAgAAMAQsgBSAANgIIIAAgBTYCDAsgAyACQQNyNgIEIAMgBEEDdCIEaiAEIAJrIgU2AgAgAyACaiIAIAVBAXI2AgQCQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhBAJAAkAgBkEBIAdBA3Z0IghxDQBBACAGIAhyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAQ2AgwgAiAENgIIIAQgAjYCDCAEIAg2AggLIANBCGohA0EAIAA2ApzQgIAAQQAgBTYCkNCAgAAMDAtBACgCjNCAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRBuNKAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNACAAKAIIIgNBACgCmNCAgABJGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCjNCAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRBuNKAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0QbjSgIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoApDQgIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AIAgoAggiA0EAKAKY0ICAAEkaIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoApDQgIAAIgMgAkkNAEEAKAKc0ICAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ApDQgIAAQQAgADYCnNCAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgBCADaiIDIAMoAgRBAXI2AgRBAEEANgKc0ICAAEEAQQA2ApDQgIAACyAEQQhqIQMMCgsCQEEAKAKU0ICAACIAIAJNDQBBACgCoNCAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ApTQgIAAQQAgBDYCoNCAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgC4NOAgABFDQBBACgC6NOAgAAhBAwBC0EAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEMakFwcUHYqtWqBXM2AuDTgIAAQQBBADYC9NOAgABBAEEANgLE04CAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYC+NOAgAAMCgsCQEEAKALA04CAACIDRQ0AAkBBACgCuNOAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgL404CAAAwKC0EALQDE04CAAEEEcQ0EAkACQAJAQQAoAqDQgIAAIgRFDQBByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQy4CAgAAiAEF/Rg0FIAghBgJAQQAoAuTTgIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgCwNOAgAAiA0UNAEEAKAK404CAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQy4CAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEMuAgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAujTgIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBDLgICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxDLgICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALE04CAAEEEcjYCxNOAgAALIAhB/v///wdLDQEgCBDLgICAACEAQQAQy4CAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKAK404CAACAGaiIDNgK404CAAAJAIANBACgCvNOAgABNDQBBACADNgK804CAAAsCQAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCmNCAgAAiA0UNACAAIANPDQELQQAgADYCmNCAgAALQQAhA0EAIAY2AszTgIAAQQAgADYCyNOAgABBAEF/NgKo0ICAAEEAQQAoAuDTgIAANgKs0ICAAEEAQQA2AtTTgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGQUhqIgUgA2siA0EBcjYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgAAgACAFakE4NgIEDAILIAMtAAxBCHENACAEIAVJDQAgBCAATw0AIARBeCAEa0EPcUEAIARBCGpBD3EbIgVqIgBBACgClNCAgAAgBmoiCyAFayIFQQFyNgIEIAMgCCAGajYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAU2ApTQgIAAQQAgADYCoNCAgAAgBCALakE4NgIEDAELAkAgAEEAKAKY0ICAACIITw0AQQAgADYCmNCAgAAgACEICyAAIAZqIQVByNOAgAAhAwJAAkACQAJAAkACQAJAA0AgAygCACAFRg0BIAMoAggiAw0ADAILCyADLQAMQQhxRQ0BC0HI04CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIgUgBEsNAwsgAygCCCEDDAALCyADIAA2AgAgAyADKAIEIAZqNgIEIABBeCAAa0EPcUEAIABBCGpBD3EbaiILIAJBA3I2AgQgBUF4IAVrQQ9xQQAgBUEIakEPcRtqIgYgCyACaiICayEDAkAgBiAERw0AQQAgAjYCoNCAgABBAEEAKAKU0ICAACADaiIDNgKU0ICAACACIANBAXI2AgQMAwsCQCAGQQAoApzQgIAARw0AQQAgAjYCnNCAgABBAEEAKAKQ0ICAACADaiIDNgKQ0ICAACACIANBAXI2AgQgAiADaiADNgIADAMLAkAgBigCBCIEQQNxQQFHDQAgBEF4cSEHAkACQCAEQf8BSw0AIAYoAggiBSAEQQN2IghBA3RBsNCAgABqIgBGGgJAIAYoAgwiBCAFRw0AQQBBACgCiNCAgABBfiAId3E2AojQgIAADAILIAQgAEYaIAQgBTYCCCAFIAQ2AgwMAQsgBigCGCEJAkACQCAGKAIMIgAgBkYNACAGKAIIIgQgCEkaIAAgBDYCCCAEIAA2AgwMAQsCQCAGQRRqIgQoAgAiBQ0AIAZBEGoiBCgCACIFDQBBACEADAELA0AgBCEIIAUiAEEUaiIEKAIAIgUNACAAQRBqIQQgACgCECIFDQALIAhBADYCAAsgCUUNAAJAAkAgBiAGKAIcIgVBAnRBuNKAgABqIgQoAgBHDQAgBCAANgIAIAANAUEAQQAoAozQgIAAQX4gBXdxNgKM0ICAAAwCCyAJQRBBFCAJKAIQIAZGG2ogADYCACAARQ0BCyAAIAk2AhgCQCAGKAIQIgRFDQAgACAENgIQIAQgADYCGAsgBigCFCIERQ0AIABBFGogBDYCACAEIAA2AhgLIAcgA2ohAyAGIAdqIgYoAgQhBAsgBiAEQX5xNgIEIAIgA2ogAzYCACACIANBAXI2AgQCQCADQf8BSw0AIANBeHFBsNCAgABqIQQCQAJAQQAoAojQgIAAIgVBASADQQN2dCIDcQ0AQQAgBSADcjYCiNCAgAAgBCEDDAELIAQoAgghAwsgAyACNgIMIAQgAjYCCCACIAQ2AgwgAiADNgIIDAMLQR8hBAJAIANB////B0sNACADQQh2IgQgBEGA/j9qQRB2QQhxIgR0IgUgBUGA4B9qQRB2QQRxIgV0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAQgBXIgAHJrIgRBAXQgAyAEQRVqdkEBcXJBHGohBAsgAiAENgIcIAJCADcCECAEQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiAEEBIAR0IghxDQAgBSACNgIAQQAgACAIcjYCjNCAgAAgAiAFNgIYIAIgAjYCCCACIAI2AgwMAwsgA0EAQRkgBEEBdmsgBEEfRht0IQQgBSgCACEAA0AgACIFKAIEQXhxIANGDQIgBEEddiEAIARBAXQhBCAFIABBBHFqQRBqIggoAgAiAA0ACyAIIAI2AgAgAiAFNgIYIAIgAjYCDCACIAI2AggMAgsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiCyAGQUhqIgggA2siA0EBcjYCBCAAIAhqQTg2AgQgBCAFQTcgBWtBD3FBACAFQUlqQQ9xG2pBQWoiCCAIIARBEGpJGyIIQSM2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAs2AqDQgIAAIAhBEGpBACkC0NOAgAA3AgAgCEEAKQLI04CAADcCCEEAIAhBCGo2AtDTgIAAQQAgBjYCzNOAgABBACAANgLI04CAAEEAQQA2AtTTgIAAIAhBJGohAwNAIANBBzYCACADQQRqIgMgBUkNAAsgCCAERg0DIAggCCgCBEF+cTYCBCAIIAggBGsiADYCACAEIABBAXI2AgQCQCAAQf8BSw0AIABBeHFBsNCAgABqIQMCQAJAQQAoAojQgIAAIgVBASAAQQN2dCIAcQ0AQQAgBSAAcjYCiNCAgAAgAyEFDAELIAMoAgghBQsgBSAENgIMIAMgBDYCCCAEIAM2AgwgBCAFNgIIDAQLQR8hAwJAIABB////B0sNACAAQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgggCEGAgA9qQRB2QQJxIgh0QQ92IAMgBXIgCHJrIgNBAXQgACADQRVqdkEBcXJBHGohAwsgBCADNgIcIARCADcCECADQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiCEEBIAN0IgZxDQAgBSAENgIAQQAgCCAGcjYCjNCAgAAgBCAFNgIYIAQgBDYCCCAEIAQ2AgwMBAsgAEEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEIA0AgCCIFKAIEQXhxIABGDQMgA0EddiEIIANBAXQhAyAFIAhBBHFqQRBqIgYoAgAiCA0ACyAGIAQ2AgAgBCAFNgIYIAQgBDYCDCAEIAQ2AggMAwsgBSgCCCIDIAI2AgwgBSACNgIIIAJBADYCGCACIAU2AgwgAiADNgIICyALQQhqIQMMBQsgBSgCCCIDIAQ2AgwgBSAENgIIIARBADYCGCAEIAU2AgwgBCADNgIIC0EAKAKU0ICAACIDIAJNDQBBACgCoNCAgAAiBCACaiIFIAMgAmsiA0EBcjYCBEEAIAM2ApTQgIAAQQAgBTYCoNCAgAAgBCACQQNyNgIEIARBCGohAwwDC0EAIQNBAEEwNgL404CAAAwCCwJAIAtFDQACQAJAIAggCCgCHCIFQQJ0QbjSgIAAaiIDKAIARw0AIAMgADYCACAADQFBACAHQX4gBXdxIgc2AozQgIAADAILIAtBEEEUIAsoAhAgCEYbaiAANgIAIABFDQELIAAgCzYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIQRRqKAIAIgNFDQAgAEEUaiADNgIAIAMgADYCGAsCQAJAIARBD0sNACAIIAQgAmoiA0EDcjYCBCAIIANqIgMgAygCBEEBcjYCBAwBCyAIIAJqIgAgBEEBcjYCBCAIIAJBA3I2AgQgACAEaiAENgIAAkAgBEH/AUsNACAEQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgBEEDdnQiBHENAEEAIAUgBHI2AojQgIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEG40oCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2AozQgIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCjNCAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAAgA2oiAyADKAIEQQFyNgIEDAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhAwJAAkBBASAHQQN2dCIIIAZxDQBBACAIIAZyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAM2AgwgAiADNgIIIAMgAjYCDCADIAg2AggLQQAgBTYCnNCAgABBACAENgKQ0ICAAAsgAEEIaiEDCyABQRBqJICAgIAAIAMLCgAgABDJgICAAAviDQEHfwJAIABFDQAgAEF4aiIBIABBfGooAgAiAkF4cSIAaiEDAkAgAkEBcQ0AIAJBA3FFDQEgASABKAIAIgJrIgFBACgCmNCAgAAiBEkNASACIABqIQACQCABQQAoApzQgIAARg0AAkAgAkH/AUsNACABKAIIIgQgAkEDdiIFQQN0QbDQgIAAaiIGRhoCQCABKAIMIgIgBEcNAEEAQQAoAojQgIAAQX4gBXdxNgKI0ICAAAwDCyACIAZGGiACIAQ2AgggBCACNgIMDAILIAEoAhghBwJAAkAgASgCDCIGIAFGDQAgASgCCCICIARJGiAGIAI2AgggAiAGNgIMDAELAkAgAUEUaiICKAIAIgQNACABQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQECQAJAIAEgASgCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAwsgB0EQQRQgBygCECABRhtqIAY2AgAgBkUNAgsgBiAHNgIYAkAgASgCECICRQ0AIAYgAjYCECACIAY2AhgLIAEoAhQiAkUNASAGQRRqIAI2AgAgAiAGNgIYDAELIAMoAgQiAkEDcUEDRw0AIAMgAkF+cTYCBEEAIAA2ApDQgIAAIAEgAGogADYCACABIABBAXI2AgQPCyABIANPDQAgAygCBCICQQFxRQ0AAkACQCACQQJxDQACQCADQQAoAqDQgIAARw0AQQAgATYCoNCAgABBAEEAKAKU0ICAACAAaiIANgKU0ICAACABIABBAXI2AgQgAUEAKAKc0ICAAEcNA0EAQQA2ApDQgIAAQQBBADYCnNCAgAAPCwJAIANBACgCnNCAgABHDQBBACABNgKc0ICAAEEAQQAoApDQgIAAIABqIgA2ApDQgIAAIAEgAEEBcjYCBCABIABqIAA2AgAPCyACQXhxIABqIQACQAJAIAJB/wFLDQAgAygCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgAygCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAgsgAiAGRhogAiAENgIIIAQgAjYCDAwBCyADKAIYIQcCQAJAIAMoAgwiBiADRg0AIAMoAggiAkEAKAKY0ICAAEkaIAYgAjYCCCACIAY2AgwMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAAJAAkAgAyADKAIcIgRBAnRBuNKAgABqIgIoAgBHDQAgAiAGNgIAIAYNAUEAQQAoAozQgIAAQX4gBHdxNgKM0ICAAAwCCyAHQRBBFCAHKAIQIANGG2ogBjYCACAGRQ0BCyAGIAc2AhgCQCADKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgAygCFCICRQ0AIAZBFGogAjYCACACIAY2AhgLIAEgAGogADYCACABIABBAXI2AgQgAUEAKAKc0ICAAEcNAUEAIAA2ApDQgIAADwsgAyACQX5xNgIEIAEgAGogADYCACABIABBAXI2AgQLAkAgAEH/AUsNACAAQXhxQbDQgIAAaiECAkACQEEAKAKI0ICAACIEQQEgAEEDdnQiAHENAEEAIAQgAHI2AojQgIAAIAIhAAwBCyACKAIIIQALIAAgATYCDCACIAE2AgggASACNgIMIAEgADYCCA8LQR8hAgJAIABB////B0sNACAAQQh2IgIgAkGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgYgBkGAgA9qQRB2QQJxIgZ0QQ92IAIgBHIgBnJrIgJBAXQgACACQRVqdkEBcXJBHGohAgsgASACNgIcIAFCADcCECACQQJ0QbjSgIAAaiEEAkACQEEAKAKM0ICAACIGQQEgAnQiA3ENACAEIAE2AgBBACAGIANyNgKM0ICAACABIAQ2AhggASABNgIIIAEgATYCDAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAEgBDYCGCABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQQA2AhggASAENgIMIAEgADYCCAtBAEEAKAKo0ICAAEF/aiIBQX8gARs2AqjQgIAACwsEAAAAC04AAkAgAA0APwBBEHQPCwJAIABB//8DcQ0AIABBf0wNAAJAIABBEHZAACIAQX9HDQBBAEEwNgL404CAAEF/DwsgAEEQdA8LEMqAgIAAAAvyAgIDfwF+AkAgAkUNACAAIAE6AAAgAiAAaiIDQX9qIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0F9aiABOgAAIANBfmogAToAACACQQdJDQAgACABOgADIANBfGogAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkF8aiABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBeGogATYCACACQXRqIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQXBqIAE2AgAgAkFsaiABNgIAIAJBaGogATYCACACQWRqIAE2AgAgBCADQQRxQRhyIgVrIgJBIEkNACABrUKBgICAEH4hBiADIAVqIQEDQCABIAY3AxggASAGNwMQIAEgBjcDCCABIAY3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAsLjkgBAEGACAuGSAEAAAACAAAAAwAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==", "base64"), llhttp_simdWasm;
  }
  o2(requireLlhttp_simdWasm, "requireLlhttp_simdWasm");
  var constants$3;
  var hasRequiredConstants$2;
  function requireConstants$2() {
    if (hasRequiredConstants$2)
      return constants$3;
    hasRequiredConstants$2 = 1;
    const e2 = ["GET", "HEAD", "POST"], A = new Set(e2), t2 = [101, 204, 205, 304], n = [301, 302, 303, 307, 308], r = new Set(n), s2 = ["1", "7", "9", "11", "13", "15", "17", "19", "20", "21", "22", "23", "25", "37", "42", "43", "53", "69", "77", "79", "87", "95", "101", "102", "103", "104", "109", "110", "111", "113", "115", "117", "119", "123", "135", "137", "139", "143", "161", "179", "389", "427", "465", "512", "513", "514", "515", "526", "530", "531", "532", "540", "548", "554", "556", "563", "587", "601", "636", "989", "990", "993", "995", "1719", "1720", "1723", "2049", "3659", "4045", "4190", "5060", "5061", "6000", "6566", "6665", "6666", "6667", "6668", "6669", "6679", "6697", "10080"], i2 = new Set(s2), E = ["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"], Q = new Set(E), C = ["follow", "manual", "error"], I = ["GET", "HEAD", "OPTIONS", "TRACE"], a2 = new Set(I), f = ["navigate", "same-origin", "no-cors", "cors"], h2 = ["omit", "same-origin", "include"], L = ["default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"], c = ["content-encoding", "content-language", "content-location", "content-type", "content-length"], l2 = ["half"], S = ["CONNECT", "TRACE", "TRACK"], k = new Set(S), w = ["audio", "audioworklet", "font", "image", "manifest", "paintworklet", "script", "style", "track", "video", "xslt", ""], U = new Set(w);
    return constants$3 = { subresource: w, forbiddenMethods: S, requestBodyHeader: c, referrerPolicy: E, requestRedirect: C, requestMode: f, requestCredentials: h2, requestCache: L, redirectStatus: n, corsSafeListedMethods: e2, nullBodyStatus: t2, safeMethods: I, badPorts: s2, requestDuplex: l2, subresourceSet: U, badPortsSet: i2, redirectStatusSet: r, corsSafeListedMethodsSet: A, safeMethodsSet: a2, forbiddenMethodsSet: k, referrerPolicySet: Q }, constants$3;
  }
  o2(requireConstants$2, "requireConstants$2");
  var global$1;
  var hasRequiredGlobal;
  function requireGlobal() {
    if (hasRequiredGlobal)
      return global$1;
    hasRequiredGlobal = 1;
    const e2 = Symbol.for("undici.globalOrigin.1");
    function A() {
      return globalThis[e2];
    }
    o2(A, "getGlobalOrigin");
    function t2(n) {
      if (n === undefined) {
        Object.defineProperty(globalThis, e2, { value: undefined, writable: true, enumerable: false, configurable: false });
        return;
      }
      const r = new URL(n);
      if (r.protocol !== "http:" && r.protocol !== "https:")
        throw new TypeError(`Only http & https urls are allowed, received ${r.protocol}`);
      Object.defineProperty(globalThis, e2, { value: r, writable: true, enumerable: false, configurable: false });
    }
    return o2(t2, "setGlobalOrigin"), global$1 = { getGlobalOrigin: A, setGlobalOrigin: t2 }, global$1;
  }
  o2(requireGlobal, "requireGlobal");
  var dataUrl;
  var hasRequiredDataUrl;
  function requireDataUrl() {
    if (hasRequiredDataUrl)
      return dataUrl;
    hasRequiredDataUrl = 1;
    const e2 = require$$0__default, A = new TextEncoder, t2 = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/, n = /[\u000A\u000D\u0009\u0020]/, r = /[\u0009\u000A\u000C\u000D\u0020]/g, s2 = /[\u0009\u0020-\u007E\u0080-\u00FF]/;
    function i2(g) {
      e2(g.protocol === "data:");
      let d = E(g, true);
      d = d.slice(5);
      const F = { position: 0 };
      let N = C(",", d, F);
      const u = N.length;
      if (N = M(N, true, true), F.position >= d.length)
        return "failure";
      F.position++;
      const b = d.slice(u + 1);
      let m = I(b);
      if (/;(\u0020){0,}base64$/i.test(N)) {
        const v = D(m);
        if (m = c(v), m === "failure")
          return "failure";
        N = N.slice(0, -6), N = N.replace(/(\u0020)+$/, ""), N = N.slice(0, -1);
      }
      N.startsWith(";") && (N = "text/plain" + N);
      let T = L(N);
      return T === "failure" && (T = L("text/plain;charset=US-ASCII")), { mimeType: T, body: m };
    }
    o2(i2, "dataURLProcessor");
    function E(g, d = false) {
      if (!d)
        return g.href;
      const F = g.href, N = g.hash.length, u = N === 0 ? F : F.substring(0, F.length - N);
      return !N && F.endsWith("#") ? u.slice(0, -1) : u;
    }
    o2(E, "URLSerializer");
    function Q(g, d, F) {
      let N = "";
      for (;F.position < d.length && g(d[F.position]); )
        N += d[F.position], F.position++;
      return N;
    }
    o2(Q, "collectASequenceOfCodePoints");
    function C(g, d, F) {
      const N = d.indexOf(g, F.position), u = F.position;
      return N === -1 ? (F.position = d.length, d.slice(u)) : (F.position = N, d.slice(u, F.position));
    }
    o2(C, "collectASequenceOfCodePointsFast");
    function I(g) {
      const d = A.encode(g);
      return h2(d);
    }
    o2(I, "stringPercentDecode");
    function a2(g) {
      return g >= 48 && g <= 57 || g >= 65 && g <= 70 || g >= 97 && g <= 102;
    }
    o2(a2, "isHexCharByte");
    function f(g) {
      return g >= 48 && g <= 57 ? g - 48 : (g & 223) - 55;
    }
    o2(f, "hexByteToNumber");
    function h2(g) {
      const d = g.length, F = new Uint8Array(d);
      let N = 0;
      for (let u = 0;u < d; ++u) {
        const b = g[u];
        b !== 37 ? F[N++] = b : b === 37 && !(a2(g[u + 1]) && a2(g[u + 2])) ? F[N++] = 37 : (F[N++] = f(g[u + 1]) << 4 | f(g[u + 2]), u += 2);
      }
      return d === N ? F : F.subarray(0, N);
    }
    o2(h2, "percentDecode");
    function L(g) {
      g = w(g, true, true);
      const d = { position: 0 }, F = C("/", g, d);
      if (F.length === 0 || !t2.test(F) || d.position > g.length)
        return "failure";
      d.position++;
      let N = C(";", g, d);
      if (N = w(N, false, true), N.length === 0 || !t2.test(N))
        return "failure";
      const u = F.toLowerCase(), b = N.toLowerCase(), m = { type: u, subtype: b, parameters: new Map, essence: `${u}/${b}` };
      for (;d.position < g.length; ) {
        d.position++, Q((Z) => n.test(Z), g, d);
        let T = Q((Z) => Z !== ";" && Z !== "=", g, d);
        if (T = T.toLowerCase(), d.position < g.length) {
          if (g[d.position] === ";")
            continue;
          d.position++;
        }
        if (d.position > g.length)
          break;
        let v = null;
        if (g[d.position] === '"')
          v = l2(g, d, true), C(";", g, d);
        else if (v = C(";", g, d), v = w(v, false, true), v.length === 0)
          continue;
        T.length !== 0 && t2.test(T) && (v.length === 0 || s2.test(v)) && !m.parameters.has(T) && m.parameters.set(T, v);
      }
      return m;
    }
    o2(L, "parseMIMEType");
    function c(g) {
      g = g.replace(r, "");
      let d = g.length;
      if (d % 4 === 0 && g.charCodeAt(d - 1) === 61 && (--d, g.charCodeAt(d - 1) === 61 && --d), d % 4 === 1 || /[^+/0-9A-Za-z]/.test(g.length === d ? g : g.substring(0, d)))
        return "failure";
      const F = Buffer.from(g, "base64");
      return new Uint8Array(F.buffer, F.byteOffset, F.byteLength);
    }
    o2(c, "forgivingBase64");
    function l2(g, d, F) {
      const N = d.position;
      let u = "";
      for (e2(g[d.position] === '"'), d.position++;u += Q((m) => m !== '"' && m !== "\\", g, d), !(d.position >= g.length); ) {
        const b = g[d.position];
        if (d.position++, b === "\\") {
          if (d.position >= g.length) {
            u += "\\";
            break;
          }
          u += g[d.position], d.position++;
        } else {
          e2(b === '"');
          break;
        }
      }
      return F ? u : g.slice(N, d.position);
    }
    o2(l2, "collectAnHTTPQuotedString");
    function S(g) {
      e2(g !== "failure");
      const { parameters: d, essence: F } = g;
      let N = F;
      for (let [u, b] of d.entries())
        N += ";", N += u, N += "=", t2.test(b) || (b = b.replace(/(\\|")/g, "\\$1"), b = '"' + b, b += '"'), N += b;
      return N;
    }
    o2(S, "serializeAMimeType");
    function k(g) {
      return g === 13 || g === 10 || g === 9 || g === 32;
    }
    o2(k, "isHTTPWhiteSpace");
    function w(g, d = true, F = true) {
      return B(g, d, F, k);
    }
    o2(w, "removeHTTPWhitespace");
    function U(g) {
      return g === 13 || g === 10 || g === 9 || g === 12 || g === 32;
    }
    o2(U, "isASCIIWhitespace");
    function M(g, d = true, F = true) {
      return B(g, d, F, U);
    }
    o2(M, "removeASCIIWhitespace");
    function B(g, d, F, N) {
      let u = 0, b = g.length - 1;
      if (d)
        for (;u < g.length && N(g.charCodeAt(u)); )
          u++;
      if (F)
        for (;b > 0 && N(g.charCodeAt(b)); )
          b--;
      return u === 0 && b === g.length - 1 ? g : g.slice(u, b + 1);
    }
    o2(B, "removeChars");
    function D(g) {
      const d = g.length;
      if (65535 > d)
        return String.fromCharCode.apply(null, g);
      let F = "", N = 0, u = 65535;
      for (;N < d; )
        N + u > d && (u = d - N), F += String.fromCharCode.apply(null, g.subarray(N, N += u));
      return F;
    }
    o2(D, "isomorphicDecode");
    function G(g) {
      switch (g.essence) {
        case "application/ecmascript":
        case "application/javascript":
        case "application/x-ecmascript":
        case "application/x-javascript":
        case "text/ecmascript":
        case "text/javascript":
        case "text/javascript1.0":
        case "text/javascript1.1":
        case "text/javascript1.2":
        case "text/javascript1.3":
        case "text/javascript1.4":
        case "text/javascript1.5":
        case "text/jscript":
        case "text/livescript":
        case "text/x-ecmascript":
        case "text/x-javascript":
          return "text/javascript";
        case "application/json":
        case "text/json":
          return "application/json";
        case "image/svg+xml":
          return "image/svg+xml";
        case "text/xml":
        case "application/xml":
          return "application/xml";
      }
      return g.subtype.endsWith("+json") ? "application/json" : g.subtype.endsWith("+xml") ? "application/xml" : "";
    }
    return o2(G, "minimizeSupportedMimeType"), dataUrl = { dataURLProcessor: i2, URLSerializer: E, collectASequenceOfCodePoints: Q, collectASequenceOfCodePointsFast: C, stringPercentDecode: I, parseMIMEType: L, collectAnHTTPQuotedString: l2, serializeAMimeType: S, removeChars: B, minimizeSupportedMimeType: G, HTTP_TOKEN_CODEPOINTS: t2, isomorphicDecode: D }, dataUrl;
  }
  o2(requireDataUrl, "requireDataUrl");
  var webidl_1;
  var hasRequiredWebidl;
  function requireWebidl() {
    if (hasRequiredWebidl)
      return webidl_1;
    hasRequiredWebidl = 1;
    const { types: e2, inspect: A } = require$$0__default$1, { toUSVString: t2 } = util$m, n = {};
    return n.converters = {}, n.util = {}, n.errors = {}, n.errors.exception = function(r) {
      return new TypeError(`${r.header}: ${r.message}`);
    }, n.errors.conversionFailed = function(r) {
      const s2 = r.types.length === 1 ? "" : " one of", i2 = `${r.argument} could not be converted to${s2}: ${r.types.join(", ")}.`;
      return n.errors.exception({ header: r.prefix, message: i2 });
    }, n.errors.invalidArgument = function(r) {
      return n.errors.exception({ header: r.prefix, message: `"${r.value}" is an invalid ${r.type}.` });
    }, n.brandCheck = function(r, s2, i2 = undefined) {
      if (i2?.strict !== false) {
        if (!(r instanceof s2))
          throw new TypeError("Illegal invocation");
      } else if (r?.[Symbol.toStringTag] !== s2.prototype[Symbol.toStringTag])
        throw new TypeError("Illegal invocation");
    }, n.argumentLengthCheck = function({ length: r }, s2, i2) {
      if (r < s2)
        throw n.errors.exception({ message: `${s2} argument${s2 !== 1 ? "s" : ""} required, but${r ? " only" : ""} ${r} found.`, ...i2 });
    }, n.illegalConstructor = function() {
      throw n.errors.exception({ header: "TypeError", message: "Illegal constructor" });
    }, n.util.Type = function(r) {
      switch (typeof r) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object":
          return r === null ? "Null" : "Object";
      }
    }, n.util.ConvertToInt = function(r, s2, i2, E = {}) {
      let Q, C;
      s2 === 64 ? (Q = Math.pow(2, 53) - 1, i2 === "unsigned" ? C = 0 : C = Math.pow(-2, 53) + 1) : i2 === "unsigned" ? (C = 0, Q = Math.pow(2, s2) - 1) : (C = Math.pow(-2, s2) - 1, Q = Math.pow(2, s2 - 1) - 1);
      let I = Number(r);
      if (I === 0 && (I = 0), E.enforceRange === true) {
        if (Number.isNaN(I) || I === Number.POSITIVE_INFINITY || I === Number.NEGATIVE_INFINITY)
          throw n.errors.exception({ header: "Integer conversion", message: `Could not convert ${n.util.Stringify(r)} to an integer.` });
        if (I = n.util.IntegerPart(I), I < C || I > Q)
          throw n.errors.exception({ header: "Integer conversion", message: `Value must be between ${C}-${Q}, got ${I}.` });
        return I;
      }
      return !Number.isNaN(I) && E.clamp === true ? (I = Math.min(Math.max(I, C), Q), Math.floor(I) % 2 === 0 ? I = Math.floor(I) : I = Math.ceil(I), I) : Number.isNaN(I) || I === 0 && Object.is(0, I) || I === Number.POSITIVE_INFINITY || I === Number.NEGATIVE_INFINITY ? 0 : (I = n.util.IntegerPart(I), I = I % Math.pow(2, s2), i2 === "signed" && I >= Math.pow(2, s2) - 1 ? I - Math.pow(2, s2) : I);
    }, n.util.IntegerPart = function(r) {
      const s2 = Math.floor(Math.abs(r));
      return r < 0 ? -1 * s2 : s2;
    }, n.util.Stringify = function(r) {
      switch (n.util.Type(r)) {
        case "Symbol":
          return `Symbol(${r.description})`;
        case "Object":
          return A(r);
        case "String":
          return `"${r}"`;
        default:
          return `${r}`;
      }
    }, n.sequenceConverter = function(r) {
      return (s2, i2) => {
        if (n.util.Type(s2) !== "Object")
          throw n.errors.exception({ header: "Sequence", message: `Value of type ${n.util.Type(s2)} is not an Object.` });
        const E = typeof i2 == "function" ? i2() : s2?.[Symbol.iterator]?.(), Q = [];
        if (E === undefined || typeof E.next != "function")
          throw n.errors.exception({ header: "Sequence", message: "Object is not an iterator." });
        for (;; ) {
          const { done: C, value: I } = E.next();
          if (C)
            break;
          Q.push(r(I));
        }
        return Q;
      };
    }, n.recordConverter = function(r, s2) {
      return (i2) => {
        if (n.util.Type(i2) !== "Object")
          throw n.errors.exception({ header: "Record", message: `Value of type ${n.util.Type(i2)} is not an Object.` });
        const E = {};
        if (!e2.isProxy(i2)) {
          const C = [...Object.getOwnPropertyNames(i2), ...Object.getOwnPropertySymbols(i2)];
          for (const I of C) {
            const a2 = r(I), f = s2(i2[I]);
            E[a2] = f;
          }
          return E;
        }
        const Q = Reflect.ownKeys(i2);
        for (const C of Q)
          if (Reflect.getOwnPropertyDescriptor(i2, C)?.enumerable) {
            const a2 = r(C), f = s2(i2[C]);
            E[a2] = f;
          }
        return E;
      };
    }, n.interfaceConverter = function(r) {
      return (s2, i2 = {}) => {
        if (i2.strict !== false && !(s2 instanceof r))
          throw n.errors.exception({ header: r.name, message: `Expected ${n.util.Stringify(s2)} to be an instance of ${r.name}.` });
        return s2;
      };
    }, n.dictionaryConverter = function(r) {
      return (s2) => {
        const i2 = n.util.Type(s2), E = {};
        if (i2 === "Null" || i2 === "Undefined")
          return E;
        if (i2 !== "Object")
          throw n.errors.exception({ header: "Dictionary", message: `Expected ${s2} to be one of: Null, Undefined, Object.` });
        for (const Q of r) {
          const { key: C, defaultValue: I, required: a2, converter: f } = Q;
          if (a2 === true && !Object.hasOwn(s2, C))
            throw n.errors.exception({ header: "Dictionary", message: `Missing required key "${C}".` });
          let h2 = s2[C];
          const L = Object.hasOwn(Q, "defaultValue");
          if (L && h2 !== null && (h2 = h2 ?? I), a2 || L || h2 !== undefined) {
            if (h2 = f(h2), Q.allowedValues && !Q.allowedValues.includes(h2))
              throw n.errors.exception({ header: "Dictionary", message: `${h2} is not an accepted type. Expected one of ${Q.allowedValues.join(", ")}.` });
            E[C] = h2;
          }
        }
        return E;
      };
    }, n.nullableConverter = function(r) {
      return (s2) => s2 === null ? s2 : r(s2);
    }, n.converters.DOMString = function(r, s2 = {}) {
      if (r === null && s2.legacyNullToEmptyString)
        return "";
      if (typeof r == "symbol")
        throw new TypeError("Could not convert argument of type symbol to string.");
      return String(r);
    }, n.converters.ByteString = function(r) {
      const s2 = n.converters.DOMString(r);
      for (let i2 = 0;i2 < s2.length; i2++)
        if (s2.charCodeAt(i2) > 255)
          throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${i2} has a value of ${s2.charCodeAt(i2)} which is greater than 255.`);
      return s2;
    }, n.converters.USVString = t2, n.converters.boolean = function(r) {
      return !!r;
    }, n.converters.any = function(r) {
      return r;
    }, n.converters["long long"] = function(r) {
      return n.util.ConvertToInt(r, 64, "signed");
    }, n.converters["unsigned long long"] = function(r) {
      return n.util.ConvertToInt(r, 64, "unsigned");
    }, n.converters["unsigned long"] = function(r) {
      return n.util.ConvertToInt(r, 32, "unsigned");
    }, n.converters["unsigned short"] = function(r, s2) {
      return n.util.ConvertToInt(r, 16, "unsigned", s2);
    }, n.converters.ArrayBuffer = function(r, s2 = {}) {
      if (n.util.Type(r) !== "Object" || !e2.isAnyArrayBuffer(r))
        throw n.errors.conversionFailed({ prefix: n.util.Stringify(r), argument: n.util.Stringify(r), types: ["ArrayBuffer"] });
      if (s2.allowShared === false && e2.isSharedArrayBuffer(r))
        throw n.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
      if (r.resizable || r.growable)
        throw n.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
      return r;
    }, n.converters.TypedArray = function(r, s2, i2 = {}) {
      if (n.util.Type(r) !== "Object" || !e2.isTypedArray(r) || r.constructor.name !== s2.name)
        throw n.errors.conversionFailed({ prefix: `${s2.name}`, argument: n.util.Stringify(r), types: [s2.name] });
      if (i2.allowShared === false && e2.isSharedArrayBuffer(r.buffer))
        throw n.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
      if (r.buffer.resizable || r.buffer.growable)
        throw n.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
      return r;
    }, n.converters.DataView = function(r, s2 = {}) {
      if (n.util.Type(r) !== "Object" || !e2.isDataView(r))
        throw n.errors.exception({ header: "DataView", message: "Object is not a DataView." });
      if (s2.allowShared === false && e2.isSharedArrayBuffer(r.buffer))
        throw n.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
      if (r.buffer.resizable || r.buffer.growable)
        throw n.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
      return r;
    }, n.converters.BufferSource = function(r, s2 = {}) {
      if (e2.isAnyArrayBuffer(r))
        return n.converters.ArrayBuffer(r, { ...s2, allowShared: false });
      if (e2.isTypedArray(r))
        return n.converters.TypedArray(r, r.constructor, { ...s2, allowShared: false });
      if (e2.isDataView(r))
        return n.converters.DataView(r, s2, { ...s2, allowShared: false });
      throw new TypeError(`Could not convert ${n.util.Stringify(r)} to a BufferSource.`);
    }, n.converters["sequence<ByteString>"] = n.sequenceConverter(n.converters.ByteString), n.converters["sequence<sequence<ByteString>>"] = n.sequenceConverter(n.converters["sequence<ByteString>"]), n.converters["record<ByteString, ByteString>"] = n.recordConverter(n.converters.ByteString, n.converters.ByteString), webidl_1 = { webidl: n }, webidl_1;
  }
  o2(requireWebidl, "requireWebidl");
  var util$j;
  var hasRequiredUtil$5;
  function requireUtil$5() {
    if (hasRequiredUtil$5)
      return util$j;
    hasRequiredUtil$5 = 1;
    const { Transform: e2 } = Stream__default, A = zlib__default, { redirectStatusSet: t2, referrerPolicySet: n, badPortsSet: r } = requireConstants$2(), { getGlobalOrigin: s2 } = requireGlobal(), { collectASequenceOfCodePoints: i2, collectAnHTTPQuotedString: E, removeChars: Q, parseMIMEType: C } = requireDataUrl(), { performance: I } = require$$5__default, { isBlobLike: a2, ReadableStreamFrom: f, isValidHTTPToken: h2 } = util$m, L = require$$0__default, { isUint8Array: c } = require$$8__default$1, { webidl: l2 } = requireWebidl();
    let S = [], k;
    try {
      k = __require("crypto");
      const y = ["sha256", "sha384", "sha512"];
      S = k.getHashes().filter((Y) => y.includes(Y));
    } catch {}
    function w(y) {
      const Y = y.urlList, W = Y.length;
      return W === 0 ? null : Y[W - 1].toString();
    }
    o2(w, "responseURL");
    function U(y, Y) {
      if (!t2.has(y.status))
        return null;
      let W = y.headersList.get("location", true);
      return W !== null && N(W) && (M(W) || (W = B(W)), W = new URL(W, w(y))), W && !W.hash && (W.hash = Y), W;
    }
    o2(U, "responseLocationURL");
    function M(y) {
      for (const Y of y) {
        const W = Y.charCodeAt(0);
        if (W >= 128 || W >= 0 && W <= 31 || W === 127)
          return false;
      }
      return true;
    }
    o2(M, "isValidEncodedURL");
    function B(y) {
      return Buffer.from(y, "binary").toString("utf8");
    }
    o2(B, "normalizeBinaryStringToUtf8");
    function D(y) {
      return y.urlList[y.urlList.length - 1];
    }
    o2(D, "requestCurrentURL");
    function G(y) {
      const Y = D(y);
      return ZA(Y) && r.has(Y.port) ? "blocked" : "allowed";
    }
    o2(G, "requestBadPort");
    function g(y) {
      return y instanceof Error || y?.constructor?.name === "Error" || y?.constructor?.name === "DOMException";
    }
    o2(g, "isErrorLike");
    function d(y) {
      for (let Y = 0;Y < y.length; ++Y) {
        const W = y.charCodeAt(Y);
        if (!(W === 9 || W >= 32 && W <= 126 || W >= 128 && W <= 255))
          return false;
      }
      return true;
    }
    o2(d, "isValidReasonPhrase");
    const F = h2;
    function N(y) {
      return !(y.startsWith("\t") || y.startsWith(" ") || y.endsWith("\t") || y.endsWith(" ") || y.includes("\x00") || y.includes("\r") || y.includes(`
`));
    }
    o2(N, "isValidHeaderValue");
    function u(y, Y) {
      const { headersList: W } = Y, j = (W.get("referrer-policy", true) ?? "").split(",");
      let nA = "";
      if (j.length > 0)
        for (let R = j.length;R !== 0; R--) {
          const O = j[R - 1].trim();
          if (n.has(O)) {
            nA = O;
            break;
          }
        }
      nA !== "" && (y.referrerPolicy = nA);
    }
    o2(u, "setRequestReferrerPolicyOnRedirect");
    function b() {
      return "allowed";
    }
    o2(b, "crossOriginResourcePolicyCheck");
    function m() {
      return "success";
    }
    o2(m, "corsCheck");
    function T() {
      return "success";
    }
    o2(T, "TAOCheck");
    function v(y) {
      let Y = null;
      Y = y.mode, y.headersList.set("sec-fetch-mode", Y, true);
    }
    o2(v, "appendFetchMetadata");
    function Z(y) {
      let Y = y.origin;
      if (y.responseTainting === "cors" || y.mode === "websocket")
        Y && y.headersList.append("origin", Y, true);
      else if (y.method !== "GET" && y.method !== "HEAD") {
        switch (y.referrerPolicy) {
          case "no-referrer":
            Y = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            y.origin && ee(y.origin) && !ee(D(y)) && (Y = null);
            break;
          case "same-origin":
            yA(y, D(y)) || (Y = null);
            break;
        }
        Y && y.headersList.append("origin", Y, true);
      }
    }
    o2(Z, "appendRequestOriginHeader");
    function P(y, Y) {
      return y;
    }
    o2(P, "coarsenTime");
    function AA(y, Y, W) {
      return !y?.startTime || y.startTime < Y ? { domainLookupStartTime: Y, domainLookupEndTime: Y, connectionStartTime: Y, connectionEndTime: Y, secureConnectionStartTime: Y, ALPNNegotiatedProtocol: y?.ALPNNegotiatedProtocol } : { domainLookupStartTime: P(y.domainLookupStartTime), domainLookupEndTime: P(y.domainLookupEndTime), connectionStartTime: P(y.connectionStartTime), connectionEndTime: P(y.connectionEndTime), secureConnectionStartTime: P(y.secureConnectionStartTime), ALPNNegotiatedProtocol: y.ALPNNegotiatedProtocol };
    }
    o2(AA, "clampAndCoarsenConnectionTimingInfo");
    function K(y) {
      return P(I.now());
    }
    o2(K, "coarsenedSharedCurrentTime");
    function tA(y) {
      return { startTime: y.startTime ?? 0, redirectStartTime: 0, redirectEndTime: 0, postRedirectStartTime: y.startTime ?? 0, finalServiceWorkerStartTime: 0, finalNetworkResponseStartTime: 0, finalNetworkRequestStartTime: 0, endTime: 0, encodedBodySize: 0, decodedBodySize: 0, finalConnectionTimingInfo: null };
    }
    o2(tA, "createOpaqueTimingInfo");
    function aA() {
      return { referrerPolicy: "strict-origin-when-cross-origin" };
    }
    o2(aA, "makePolicyContainer");
    function X(y) {
      return { referrerPolicy: y.referrerPolicy };
    }
    o2(X, "clonePolicyContainer");
    function $(y) {
      const Y = y.referrerPolicy;
      L(Y);
      let W = null;
      if (y.referrer === "client") {
        const H = s2();
        if (!H || H.origin === "null")
          return "no-referrer";
        W = new URL(H);
      } else
        y.referrer instanceof URL && (W = y.referrer);
      let j = V(W);
      const nA = V(W, true);
      j.toString().length > 4096 && (j = nA);
      const R = yA(y, j), O = q(j) && !q(y.url);
      switch (Y) {
        case "origin":
          return nA ?? V(W, true);
        case "unsafe-url":
          return j;
        case "same-origin":
          return R ? nA : "no-referrer";
        case "origin-when-cross-origin":
          return R ? j : nA;
        case "strict-origin-when-cross-origin": {
          const H = D(y);
          return yA(j, H) ? j : q(j) && !q(H) ? "no-referrer" : nA;
        }
        case "strict-origin":
        case "no-referrer-when-downgrade":
        default:
          return O ? "no-referrer" : nA;
      }
    }
    o2($, "determineRequestsReferrer");
    function V(y, Y) {
      return L(y instanceof URL), y = new URL(y), y.protocol === "file:" || y.protocol === "about:" || y.protocol === "blank:" ? "no-referrer" : (y.username = "", y.password = "", y.hash = "", Y && (y.pathname = "", y.search = ""), y);
    }
    o2(V, "stripURLForReferrer");
    function q(y) {
      if (!(y instanceof URL))
        return false;
      if (y.href === "about:blank" || y.href === "about:srcdoc" || y.protocol === "data:" || y.protocol === "file:")
        return true;
      return Y(y.origin);
      function Y(W) {
        if (W == null || W === "null")
          return false;
        const j = new URL(W);
        return !!(j.protocol === "https:" || j.protocol === "wss:" || /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(j.hostname) || j.hostname === "localhost" || j.hostname.includes("localhost.") || j.hostname.endsWith(".localhost"));
      }
    }
    o2(q, "isURLPotentiallyTrustworthy");
    function z(y, Y) {
      if (k === undefined)
        return true;
      const W = iA(Y);
      if (W === "no metadata" || W.length === 0)
        return true;
      const j = gA(W), nA = BA(W, j);
      for (const R of nA) {
        const { algo: O, hash: H } = R;
        let J = k.createHash(O).update(y).digest("base64");
        if (J[J.length - 1] === "=" && (J[J.length - 2] === "=" ? J = J.slice(0, -2) : J = J.slice(0, -1)), sA(J, H))
          return true;
      }
      return false;
    }
    o2(z, "bytesMatch");
    const rA = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function iA(y) {
      const Y = [];
      let W = true;
      for (const j of y.split(" ")) {
        W = false;
        const nA = rA.exec(j);
        if (nA === null || nA.groups === undefined || nA.groups.algo === undefined)
          continue;
        const R = nA.groups.algo.toLowerCase();
        S.includes(R) && Y.push(nA.groups);
      }
      return W === true ? "no metadata" : Y;
    }
    o2(iA, "parseMetadata");
    function gA(y) {
      let Y = y[0].algo;
      if (Y[3] === "5")
        return Y;
      for (let W = 1;W < y.length; ++W) {
        const j = y[W];
        if (j.algo[3] === "5") {
          Y = "sha512";
          break;
        } else {
          if (Y[3] === "3")
            continue;
          j.algo[3] === "3" && (Y = "sha384");
        }
      }
      return Y;
    }
    o2(gA, "getStrongestMetadata");
    function BA(y, Y) {
      if (y.length === 1)
        return y;
      let W = 0;
      for (let j = 0;j < y.length; ++j)
        y[j].algo === Y && (y[W++] = y[j]);
      return y.length = W, y;
    }
    o2(BA, "filterMetadataListByAlgorithm");
    function sA(y, Y) {
      if (y.length !== Y.length)
        return false;
      for (let W = 0;W < y.length; ++W)
        if (y[W] !== Y[W]) {
          if (y[W] === "+" && Y[W] === "-" || y[W] === "/" && Y[W] === "_")
            continue;
          return false;
        }
      return true;
    }
    o2(sA, "compareBase64Mixed");
    function eA(y) {}
    o2(eA, "tryUpgradeRequestToAPotentiallyTrustworthyURL");
    function yA(y, Y) {
      return y.origin === Y.origin && y.origin === "null" || y.protocol === Y.protocol && y.hostname === Y.hostname && y.port === Y.port;
    }
    o2(yA, "sameOrigin");
    function WA() {
      let y, Y;
      return { promise: new Promise((j, nA) => {
        y = j, Y = nA;
      }), resolve: y, reject: Y };
    }
    o2(WA, "createDeferredPromise");
    function wA(y) {
      return y.controller.state === "aborted";
    }
    o2(wA, "isAborted");
    function qA(y) {
      return y.controller.state === "aborted" || y.controller.state === "terminated";
    }
    o2(qA, "isCancelled");
    const MA = { delete: "DELETE", DELETE: "DELETE", get: "GET", GET: "GET", head: "HEAD", HEAD: "HEAD", options: "OPTIONS", OPTIONS: "OPTIONS", post: "POST", POST: "POST", put: "PUT", PUT: "PUT" }, HA = { ...MA, patch: "patch", PATCH: "PATCH" };
    Object.setPrototypeOf(MA, null), Object.setPrototypeOf(HA, null);
    function pA(y) {
      return MA[y.toLowerCase()] ?? y;
    }
    o2(pA, "normalizeMethod");
    function YA(y) {
      const Y = JSON.stringify(y);
      if (Y === undefined)
        throw new TypeError("Value is not JSON serializable");
      return L(typeof Y == "string"), Y;
    }
    o2(YA, "serializeJavascriptValueToJSONString");
    const UA = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function JA(y, Y, W = 0, j = 1) {
      var R, O, H;
      const J = class J2 {
        constructor(x, QA) {
          CA(this, R, undefined);
          CA(this, O, undefined);
          CA(this, H, undefined);
          EA(this, R, x), EA(this, O, QA), EA(this, H, 0);
        }
        next() {
          if (typeof this != "object" || this === null || !yt(R, this))
            throw new TypeError(`'next' called on an object that does not implement interface ${y} Iterator.`);
          const x = p(this, H), QA = p(this, R)[Y], lA = QA.length;
          if (x >= lA)
            return { value: undefined, done: true };
          const { [W]: uA, [j]: cA } = QA[x];
          EA(this, H, x + 1);
          let fA;
          switch (p(this, O)) {
            case "key":
              fA = uA;
              break;
            case "value":
              fA = cA;
              break;
            case "key+value":
              fA = [uA, cA];
              break;
          }
          return { value: fA, done: false };
        }
      };
      R = new WeakMap, O = new WeakMap, H = new WeakMap, o2(J, "FastIterableIterator");
      let nA = J;
      return delete nA.prototype.constructor, Object.setPrototypeOf(nA.prototype, UA), Object.defineProperties(nA.prototype, { [Symbol.toStringTag]: { writable: false, enumerable: false, configurable: true, value: `${y} Iterator` }, next: { writable: true, enumerable: true, configurable: true } }), function(_, x) {
        return new nA(_, x);
      };
    }
    o2(JA, "createIterator");
    function VA(y, Y, W, j = 0, nA = 1) {
      const R = JA(y, W, j, nA), O = { keys: { writable: true, enumerable: true, configurable: true, value: o2(function() {
        return l2.brandCheck(this, Y), R(this, "key");
      }, "keys") }, values: { writable: true, enumerable: true, configurable: true, value: o2(function() {
        return l2.brandCheck(this, Y), R(this, "value");
      }, "values") }, entries: { writable: true, enumerable: true, configurable: true, value: o2(function() {
        return l2.brandCheck(this, Y), R(this, "key+value");
      }, "entries") }, forEach: { writable: true, enumerable: true, configurable: true, value: o2(function(J, _ = globalThis) {
        if (l2.brandCheck(this, Y), l2.argumentLengthCheck(arguments, 1, { header: `${y}.forEach` }), typeof J != "function")
          throw new TypeError(`Failed to execute 'forEach' on '${y}': parameter 1 is not of type 'Function'.`);
        for (const { 0: x, 1: QA } of R(this, "key+value"))
          J.call(_, QA, x, this);
      }, "forEach") } };
      return Object.defineProperties(Y.prototype, { ...O, [Symbol.iterator]: { writable: true, enumerable: false, configurable: true, value: O.entries.value } });
    }
    o2(VA, "iteratorMixin");
    async function OA(y, Y, W) {
      const j = Y, nA = W;
      let R;
      try {
        R = y.stream.getReader();
      } catch (O) {
        nA(O);
        return;
      }
      try {
        const O = await PA(R);
        j(O);
      } catch (O) {
        nA(O);
      }
    }
    o2(OA, "fullyReadBody");
    function IA(y) {
      return y instanceof ReadableStream || y[Symbol.toStringTag] === "ReadableStream" && typeof y.tee == "function";
    }
    o2(IA, "isReadableStreamLike");
    function hA(y) {
      try {
        y.close(), y.byobRequest?.respond(0);
      } catch (Y) {
        if (!Y.message.includes("Controller is already closed") && !Y.message.includes("ReadableStream is already closed"))
          throw Y;
      }
    }
    o2(hA, "readableStreamClose");
    function SA(y) {
      for (let Y = 0;Y < y.length; Y++)
        L(y.charCodeAt(Y) <= 255);
      return y;
    }
    o2(SA, "isomorphicEncode");
    async function PA(y) {
      const Y = [];
      let W = 0;
      for (;; ) {
        const { done: j, value: nA } = await y.read();
        if (j)
          return Buffer.concat(Y, W);
        if (!c(nA))
          throw new TypeError("Received non-Uint8Array chunk");
        Y.push(nA), W += nA.length;
      }
    }
    o2(PA, "readAllBytes");
    function Pe(y) {
      L("protocol" in y);
      const Y = y.protocol;
      return Y === "about:" || Y === "blob:" || Y === "data:";
    }
    o2(Pe, "urlIsLocal");
    function ee(y) {
      return typeof y == "string" ? y.startsWith("https:") : y.protocol === "https:";
    }
    o2(ee, "urlHasHttpsScheme");
    function ZA(y) {
      L("protocol" in y);
      const Y = y.protocol;
      return Y === "http:" || Y === "https:";
    }
    o2(ZA, "urlIsHttpHttpsScheme");
    function XA(y, Y) {
      const W = y;
      if (!W.startsWith("bytes"))
        return "failure";
      const j = { position: 5 };
      if (Y && i2((J) => J === "\t" || J === " ", W, j), W.charCodeAt(j.position) !== 61)
        return "failure";
      j.position++, Y && i2((J) => J === "\t" || J === " ", W, j);
      const nA = i2((J) => {
        const _ = J.charCodeAt(0);
        return _ >= 48 && _ <= 57;
      }, W, j), R = nA.length ? Number(nA) : null;
      if (Y && i2((J) => J === "\t" || J === " ", W, j), W.charCodeAt(j.position) !== 45)
        return "failure";
      j.position++, Y && i2((J) => J === "\t" || J === " ", W, j);
      const O = i2((J) => {
        const _ = J.charCodeAt(0);
        return _ >= 48 && _ <= 57;
      }, W, j), H = O.length ? Number(O) : null;
      return j.position < W.length || H === null && R === null || R > H ? "failure" : { rangeStartValue: R, rangeEndValue: H };
    }
    o2(XA, "simpleRangeHeaderValue");
    function Ze(y, Y, W) {
      let j = "bytes ";
      return j += SA(`${y}`), j += "-", j += SA(`${Y}`), j += "/", j += SA(`${W}`), j;
    }
    o2(Ze, "buildContentRange");
    const vA = class vA2 extends e2 {
      _transform(Y, W, j) {
        if (!this._inflateStream) {
          if (Y.length === 0) {
            j();
            return;
          }
          this._inflateStream = (Y[0] & 15) === 8 ? A.createInflate() : A.createInflateRaw(), this._inflateStream.on("data", this.push.bind(this)), this._inflateStream.on("end", () => this.push(null)), this._inflateStream.on("error", (nA) => this.destroy(nA));
        }
        this._inflateStream.write(Y, W, j);
      }
      _final(Y) {
        this._inflateStream && (this._inflateStream.end(), this._inflateStream = null), Y();
      }
    };
    o2(vA, "InflateStream");
    let KA = vA;
    function He() {
      return new KA;
    }
    o2(He, "createInflate");
    function te(y) {
      let Y = null, W = null, j = null;
      const nA = re("content-type", y);
      if (nA === null)
        return "failure";
      for (const R of nA) {
        const O = C(R);
        O === "failure" || O.essence === "*/*" || (j = O, j.essence !== W ? (Y = null, j.parameters.has("charset") && (Y = j.parameters.get("charset")), W = j.essence) : !j.parameters.has("charset") && Y !== null && j.parameters.set("charset", Y));
      }
      return j ?? "failure";
    }
    o2(te, "extractMimeType");
    function Ve(y) {
      const Y = y, W = { position: 0 }, j = [];
      let nA = "";
      for (;W.position < Y.length; ) {
        if (nA += i2((R) => R !== '"' && R !== ",", Y, W), W.position < Y.length)
          if (Y.charCodeAt(W.position) === 34) {
            if (nA += E(Y, W), W.position < Y.length)
              continue;
          } else
            L(Y.charCodeAt(W.position) === 44), W.position++;
        nA = Q(nA, true, true, (R) => R === 9 || R === 32), j.push(nA), nA = "";
      }
      return j;
    }
    o2(Ve, "gettingDecodingSplitting");
    function re(y, Y) {
      const W = Y.get(y, true);
      return W === null ? null : Ve(W);
    }
    o2(re, "getDecodeSplit");
    const ve = new TextDecoder;
    function Xe(y) {
      return y.length === 0 ? "" : (y[0] === 239 && y[1] === 187 && y[2] === 191 && (y = y.subarray(3)), ve.decode(y));
    }
    return o2(Xe, "utf8DecodeBytes"), util$j = { isAborted: wA, isCancelled: qA, createDeferredPromise: WA, ReadableStreamFrom: f, tryUpgradeRequestToAPotentiallyTrustworthyURL: eA, clampAndCoarsenConnectionTimingInfo: AA, coarsenedSharedCurrentTime: K, determineRequestsReferrer: $, makePolicyContainer: aA, clonePolicyContainer: X, appendFetchMetadata: v, appendRequestOriginHeader: Z, TAOCheck: T, corsCheck: m, crossOriginResourcePolicyCheck: b, createOpaqueTimingInfo: tA, setRequestReferrerPolicyOnRedirect: u, isValidHTTPToken: h2, requestBadPort: G, requestCurrentURL: D, responseURL: w, responseLocationURL: U, isBlobLike: a2, isURLPotentiallyTrustworthy: q, isValidReasonPhrase: d, sameOrigin: yA, normalizeMethod: pA, serializeJavascriptValueToJSONString: YA, iteratorMixin: VA, createIterator: JA, isValidHeaderName: F, isValidHeaderValue: N, isErrorLike: g, fullyReadBody: OA, bytesMatch: z, isReadableStreamLike: IA, readableStreamClose: hA, isomorphicEncode: SA, urlIsLocal: Pe, urlHasHttpsScheme: ee, urlIsHttpHttpsScheme: ZA, readAllBytes: PA, normalizeMethodRecord: HA, simpleRangeHeaderValue: XA, buildContentRange: Ze, parseMetadata: iA, createInflate: He, extractMimeType: te, getDecodeSplit: re, utf8DecodeBytes: Xe }, util$j;
  }
  o2(requireUtil$5, "requireUtil$5");
  var symbols$3;
  var hasRequiredSymbols$3;
  function requireSymbols$3() {
    return hasRequiredSymbols$3 || (hasRequiredSymbols$3 = 1, symbols$3 = { kUrl: Symbol("url"), kHeaders: Symbol("headers"), kSignal: Symbol("signal"), kState: Symbol("state"), kGuard: Symbol("guard"), kRealm: Symbol("realm"), kDispatcher: Symbol("dispatcher") }), symbols$3;
  }
  o2(requireSymbols$3, "requireSymbols$3");
  var file;
  var hasRequiredFile;
  function requireFile() {
    if (hasRequiredFile)
      return file;
    hasRequiredFile = 1;
    const { EOL: e2 } = require$$0__default$4, { Blob: A, File: t2 } = require$$6__default, { types: n } = require$$0__default$1, { kState: r } = requireSymbols$3(), { isBlobLike: s2 } = requireUtil$5(), { webidl: i2 } = requireWebidl(), { parseMIMEType: E, serializeAMimeType: Q } = requireDataUrl(), { kEnumerableProperty: C } = util$m, I = new TextEncoder, l2 = class l3 extends A {
      constructor(w, U, M = {}) {
        i2.argumentLengthCheck(arguments, 2, { header: "File constructor" }), w = i2.converters["sequence<BlobPart>"](w), U = i2.converters.USVString(U), M = i2.converters.FilePropertyBag(M);
        const B = U;
        let D = M.type, G;
        A: {
          if (D) {
            if (D = E(D), D === "failure") {
              D = "";
              break A;
            }
            D = Q(D).toLowerCase();
          }
          G = M.lastModified;
        }
        super(h2(w, M), { type: D }), this[r] = { name: B, lastModified: G, type: D };
      }
      get name() {
        return i2.brandCheck(this, l3), this[r].name;
      }
      get lastModified() {
        return i2.brandCheck(this, l3), this[r].lastModified;
      }
      get type() {
        return i2.brandCheck(this, l3), this[r].type;
      }
    };
    o2(l2, "File");
    let a2 = l2;
    const S = class S2 {
      constructor(w, U, M = {}) {
        const B = U, D = M.type, G = M.lastModified ?? Date.now();
        this[r] = { blobLike: w, name: B, type: D, lastModified: G };
      }
      stream(...w) {
        return i2.brandCheck(this, S2), this[r].blobLike.stream(...w);
      }
      arrayBuffer(...w) {
        return i2.brandCheck(this, S2), this[r].blobLike.arrayBuffer(...w);
      }
      slice(...w) {
        return i2.brandCheck(this, S2), this[r].blobLike.slice(...w);
      }
      text(...w) {
        return i2.brandCheck(this, S2), this[r].blobLike.text(...w);
      }
      get size() {
        return i2.brandCheck(this, S2), this[r].blobLike.size;
      }
      get type() {
        return i2.brandCheck(this, S2), this[r].blobLike.type;
      }
      get name() {
        return i2.brandCheck(this, S2), this[r].name;
      }
      get lastModified() {
        return i2.brandCheck(this, S2), this[r].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    o2(S, "FileLike");
    let f = S;
    Object.defineProperties(a2.prototype, { [Symbol.toStringTag]: { value: "File", configurable: true }, name: C, lastModified: C }), i2.converters.Blob = i2.interfaceConverter(A), i2.converters.BlobPart = function(k, w) {
      if (i2.util.Type(k) === "Object") {
        if (s2(k))
          return i2.converters.Blob(k, { strict: false });
        if (ArrayBuffer.isView(k) || n.isAnyArrayBuffer(k))
          return i2.converters.BufferSource(k, w);
      }
      return i2.converters.USVString(k, w);
    }, i2.converters["sequence<BlobPart>"] = i2.sequenceConverter(i2.converters.BlobPart), i2.converters.FilePropertyBag = i2.dictionaryConverter([{ key: "lastModified", converter: i2.converters["long long"], get defaultValue() {
      return Date.now();
    } }, { key: "type", converter: i2.converters.DOMString, defaultValue: "" }, { key: "endings", converter: (k) => (k = i2.converters.DOMString(k), k = k.toLowerCase(), k !== "native" && (k = "transparent"), k), defaultValue: "transparent" }]);
    function h2(k, w) {
      const U = [];
      for (const M of k)
        if (typeof M == "string") {
          let B = M;
          w.endings === "native" && (B = L(B)), U.push(I.encode(B));
        } else
          ArrayBuffer.isView(M) || n.isArrayBuffer(M) ? M.buffer ? U.push(new Uint8Array(M.buffer, M.byteOffset, M.byteLength)) : U.push(new Uint8Array(M)) : s2(M) && U.push(M);
      return U;
    }
    o2(h2, "processBlobParts");
    function L(k) {
      return k.replace(/\r?\n/g, e2);
    }
    o2(L, "convertLineEndingsNative");
    function c(k) {
      return t2 && k instanceof t2 || k instanceof a2 || k && (typeof k.stream == "function" || typeof k.arrayBuffer == "function") && k[Symbol.toStringTag] === "File";
    }
    return o2(c, "isFileLike"), file = { File: a2, FileLike: f, isFileLike: c }, file;
  }
  o2(requireFile, "requireFile");
  var formdata;
  var hasRequiredFormdata;
  function requireFormdata() {
    if (hasRequiredFormdata)
      return formdata;
    hasRequiredFormdata = 1;
    const { isBlobLike: e2, iteratorMixin: A } = requireUtil$5(), { kState: t2 } = requireSymbols$3(), { kEnumerableProperty: n } = util$m, { File: r, FileLike: s2, isFileLike: i2 } = requireFile(), { webidl: E } = requireWebidl(), { File: Q } = require$$6__default, C = require$$0__default$1, I = Q ?? r, h2 = class h3 {
      constructor(c) {
        if (c !== undefined)
          throw E.errors.conversionFailed({ prefix: "FormData constructor", argument: "Argument 1", types: ["undefined"] });
        this[t2] = [];
      }
      append(c, l2, S = undefined) {
        if (E.brandCheck(this, h3), E.argumentLengthCheck(arguments, 2, { header: "FormData.append" }), arguments.length === 3 && !e2(l2))
          throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
        c = E.converters.USVString(c), l2 = e2(l2) ? E.converters.Blob(l2, { strict: false }) : E.converters.USVString(l2), S = arguments.length === 3 ? E.converters.USVString(S) : undefined;
        const k = f(c, l2, S);
        this[t2].push(k);
      }
      delete(c) {
        E.brandCheck(this, h3), E.argumentLengthCheck(arguments, 1, { header: "FormData.delete" }), c = E.converters.USVString(c), this[t2] = this[t2].filter((l2) => l2.name !== c);
      }
      get(c) {
        E.brandCheck(this, h3), E.argumentLengthCheck(arguments, 1, { header: "FormData.get" }), c = E.converters.USVString(c);
        const l2 = this[t2].findIndex((S) => S.name === c);
        return l2 === -1 ? null : this[t2][l2].value;
      }
      getAll(c) {
        return E.brandCheck(this, h3), E.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" }), c = E.converters.USVString(c), this[t2].filter((l2) => l2.name === c).map((l2) => l2.value);
      }
      has(c) {
        return E.brandCheck(this, h3), E.argumentLengthCheck(arguments, 1, { header: "FormData.has" }), c = E.converters.USVString(c), this[t2].findIndex((l2) => l2.name === c) !== -1;
      }
      set(c, l2, S = undefined) {
        if (E.brandCheck(this, h3), E.argumentLengthCheck(arguments, 2, { header: "FormData.set" }), arguments.length === 3 && !e2(l2))
          throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
        c = E.converters.USVString(c), l2 = e2(l2) ? E.converters.Blob(l2, { strict: false }) : E.converters.USVString(l2), S = arguments.length === 3 ? E.converters.USVString(S) : undefined;
        const k = f(c, l2, S), w = this[t2].findIndex((U) => U.name === c);
        w !== -1 ? this[t2] = [...this[t2].slice(0, w), k, ...this[t2].slice(w + 1).filter((U) => U.name !== c)] : this[t2].push(k);
      }
      [C.inspect.custom](c, l2) {
        const S = this[t2].reduce((w, U) => (w[U.name] ? Array.isArray(w[U.name]) ? w[U.name].push(U.value) : w[U.name] = [w[U.name], U.value] : w[U.name] = U.value, w), { __proto__: null });
        l2.depth ?? (l2.depth = c), l2.colors ?? (l2.colors = true);
        const k = C.formatWithOptions(l2, S);
        return `FormData ${k.slice(k.indexOf("]") + 2)}`;
      }
    };
    o2(h2, "FormData");
    let a2 = h2;
    A("FormData", a2, t2, "name", "value"), Object.defineProperties(a2.prototype, { append: n, delete: n, get: n, getAll: n, has: n, set: n, [Symbol.toStringTag]: { value: "FormData", configurable: true } });
    function f(L, c, l2) {
      if (typeof c != "string") {
        if (i2(c) || (c = c instanceof Blob ? new I([c], "blob", { type: c.type }) : new s2(c, "blob", { type: c.type })), l2 !== undefined) {
          const S = { type: c.type, lastModified: c.lastModified };
          c = Q && c instanceof Q || c instanceof r ? new I([c], l2, S) : new s2(c, l2, S);
        }
      }
      return { name: L, value: c };
    }
    return o2(f, "makeEntry"), formdata = { FormData: a2, makeEntry: f }, formdata;
  }
  o2(requireFormdata, "requireFormdata");
  var formdataParser;
  var hasRequiredFormdataParser;
  function requireFormdataParser() {
    if (hasRequiredFormdataParser)
      return formdataParser;
    hasRequiredFormdataParser = 1;
    const { toUSVString: e2, isUSVString: A, bufferToLowerCasedHeaderName: t2 } = util$m, { utf8DecodeBytes: n } = requireUtil$5(), { HTTP_TOKEN_CODEPOINTS: r, isomorphicDecode: s2 } = requireDataUrl(), { isFileLike: i2, File: E } = requireFile(), { makeEntry: Q } = requireFormdata(), C = require$$0__default, { File: I } = require$$6__default, a2 = globalThis.File ?? I ?? E, f = Buffer.from('form-data; name="'), h2 = Buffer.from("; filename"), L = Buffer.from("--"), c = Buffer.from(`--\r
`);
    function l2(g) {
      for (let d = 0;d < g.length; ++d)
        if (g.charCodeAt(d) & -128)
          return false;
      return true;
    }
    o2(l2, "isAsciiString");
    function S(g) {
      const d = g.length;
      if (d < 27 || d > 70)
        return false;
      for (let F = 0;F < d; ++F) {
        const N = g.charCodeAt(F);
        if (!(N >= 48 && N <= 57 || N >= 65 && N <= 90 || N >= 97 && N <= 122 || N === 39 || N === 45 || N === 95))
          return false;
      }
      return true;
    }
    o2(S, "validateBoundary");
    function k(g, d = "utf-8", F = false) {
      return F ? g = e2(g) : (C(A(g)), g = g.replace(/\r\n?|\r?\n/g, `\r
`)), C(Buffer.isEncoding(d)), g = g.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), Buffer.from(g, d);
    }
    o2(k, "escapeFormDataName");
    function w(g, d) {
      C(d !== "failure" && d.essence === "multipart/form-data");
      const F = d.parameters.get("boundary");
      if (F === undefined)
        return "failure";
      const N = Buffer.from(`--${F}`, "utf8"), u = [], b = { position: 0 };
      for (g[0] === 13 && g[1] === 10 && (b.position += 2);; ) {
        if (g.subarray(b.position, b.position + N.length).equals(N))
          b.position += N.length;
        else
          return "failure";
        if (b.position === g.length - 2 && G(g, L, b) || b.position === g.length - 4 && G(g, c, b))
          return u;
        if (g[b.position] !== 13 || g[b.position + 1] !== 10)
          return "failure";
        b.position += 2;
        const m = U(g, b);
        if (m === "failure")
          return "failure";
        let { name: T, filename: v, contentType: Z, encoding: P } = m;
        b.position += 2;
        let AA;
        {
          const tA = g.indexOf(N.subarray(2), b.position);
          if (tA === -1)
            return "failure";
          AA = g.subarray(b.position, tA - 4), b.position += AA.length, P === "base64" && (AA = Buffer.from(AA.toString(), "base64"));
        }
        if (g[b.position] !== 13 || g[b.position + 1] !== 10)
          return "failure";
        b.position += 2;
        let K;
        v !== null ? (Z ?? (Z = "text/plain"), l2(Z) || (Z = ""), K = new a2([AA], v, { type: Z })) : K = n(Buffer.from(AA)), C(A(T)), C(typeof K == "string" && A(K) || i2(K)), u.push(Q(T, K, v));
      }
    }
    o2(w, "multipartFormDataParser");
    function U(g, d) {
      let F = null, N = null, u = null, b = null;
      for (;; ) {
        if (g[d.position] === 13 && g[d.position + 1] === 10)
          return F === null ? "failure" : { name: F, filename: N, contentType: u, encoding: b };
        let m = B((T) => T !== 10 && T !== 13 && T !== 58, g, d);
        if (m = D(m, true, true, (T) => T === 9 || T === 32), !r.test(m.toString()) || g[d.position] !== 58)
          return "failure";
        switch (d.position++, B((T) => T === 32 || T === 9, g, d), t2(m)) {
          case "content-disposition": {
            if (F = N = null, !G(g, f, d) || (d.position += 17, F = M(g, d), F === null))
              return "failure";
            if (G(g, h2, d)) {
              let T = d.position + h2.length;
              if (g[T] === 42 && (d.position += 1, T += 1), g[T] !== 61 || g[T + 1] !== 34 || (d.position += 12, N = M(g, d), N === null))
                return "failure";
            }
            break;
          }
          case "content-type": {
            let T = B((v) => v !== 10 && v !== 13, g, d);
            T = D(T, false, true, (v) => v === 9 || v === 32), u = s2(T);
            break;
          }
          case "content-transfer-encoding": {
            let T = B((v) => v !== 10 && v !== 13, g, d);
            T = D(T, false, true, (v) => v === 9 || v === 32), b = s2(T);
            break;
          }
          default:
            B((T) => T !== 10 && T !== 13, g, d);
        }
        if (g[d.position] !== 13 && g[d.position + 1] !== 10)
          return "failure";
        d.position += 2;
      }
    }
    o2(U, "parseMultipartFormDataHeaders");
    function M(g, d) {
      C(g[d.position - 1] === 34);
      let F = B((N) => N !== 10 && N !== 13 && N !== 34, g, d);
      return g[d.position] !== 34 ? null : (d.position++, F = new TextDecoder().decode(F).replace(/%0A/ig, `
`).replace(/%0D/ig, "\r").replace(/%22/g, '"'), F);
    }
    o2(M, "parseMultipartFormDataName");
    function B(g, d, F) {
      let N = F.position;
      for (;N < d.length && g(d[N]); )
        ++N;
      return d.subarray(F.position, F.position = N);
    }
    o2(B, "collectASequenceOfBytes");
    function D(g, d, F, N) {
      let u = 0, b = g.length - 1;
      if (d)
        for (;u < g.length && N(g[u]); )
          u++;
      if (F)
        for (;b > 0 && N(g[b]); )
          b--;
      return u === 0 && b === g.length - 1 ? g : g.subarray(u, b + 1);
    }
    o2(D, "removeChars");
    function G(g, d, F) {
      if (g.length < d.length)
        return false;
      for (let N = 0;N < d.length; N++)
        if (d[N] !== g[F.position + N])
          return false;
      return true;
    }
    return o2(G, "bufferStartsWith"), formdataParser = { multipartFormDataParser: w, validateBoundary: S, escapeFormDataName: k }, formdataParser;
  }
  o2(requireFormdataParser, "requireFormdataParser");
  var body;
  var hasRequiredBody;
  function requireBody() {
    if (hasRequiredBody)
      return body;
    hasRequiredBody = 1;
    const e2 = util$m, { ReadableStreamFrom: A, isBlobLike: t2, isReadableStreamLike: n, readableStreamClose: r, createDeferredPromise: s2, fullyReadBody: i2, extractMimeType: E, utf8DecodeBytes: Q } = requireUtil$5(), { FormData: C } = requireFormdata(), { kState: I } = requireSymbols$3(), { webidl: a2 } = requireWebidl(), { Blob: f } = require$$6__default, h2 = require$$0__default, { isErrored: L } = util$m, { isArrayBuffer: c } = require$$8__default$1, { serializeAMimeType: l2 } = requireDataUrl(), { multipartFormDataParser: S } = requireFormdataParser(), k = new TextEncoder;
    function w(u, b = false) {
      let m = null;
      u instanceof ReadableStream ? m = u : t2(u) ? m = u.stream() : m = new ReadableStream({ async pull(K) {
        const tA = typeof v == "string" ? k.encode(v) : v;
        tA.byteLength && K.enqueue(tA), queueMicrotask(() => r(K));
      }, start() {}, type: "bytes" }), h2(n(m));
      let T = null, v = null, Z = null, P = null;
      if (typeof u == "string")
        v = u, P = "text/plain;charset=UTF-8";
      else if (u instanceof URLSearchParams)
        v = u.toString(), P = "application/x-www-form-urlencoded;charset=UTF-8";
      else if (c(u))
        v = new Uint8Array(u.slice());
      else if (ArrayBuffer.isView(u))
        v = new Uint8Array(u.buffer.slice(u.byteOffset, u.byteOffset + u.byteLength));
      else if (e2.isFormDataLike(u)) {
        const K = `----formdata-undici-0${`${Math.floor(Math.random() * 100000000000)}`.padStart(11, "0")}`, tA = `--${K}\r
Content-Disposition: form-data`;
        /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
        const aA = o2((rA) => rA.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), "escape"), X = o2((rA) => rA.replace(/\r?\n|\r/g, `\r
`), "normalizeLinefeeds"), $ = [], V = new Uint8Array([13, 10]);
        Z = 0;
        let q = false;
        for (const [rA, iA] of u)
          if (typeof iA == "string") {
            const gA = k.encode(tA + `; name="${aA(X(rA))}"\r
\r
${X(iA)}\r
`);
            $.push(gA), Z += gA.byteLength;
          } else {
            const gA = k.encode(`${tA}; name="${aA(X(rA))}"` + (iA.name ? `; filename="${aA(iA.name)}"` : "") + `\r
Content-Type: ${iA.type || "application/octet-stream"}\r
\r
`);
            $.push(gA, iA, V), typeof iA.size == "number" ? Z += gA.byteLength + iA.size + V.byteLength : q = true;
          }
        const z = k.encode(`--${K}--`);
        $.push(z), Z += z.byteLength, q && (Z = null), v = u, T = o2(async function* () {
          for (const rA of $)
            rA.stream ? yield* rA.stream() : yield rA;
        }, "action"), P = `multipart/form-data; boundary=${K}`;
      } else if (t2(u))
        v = u, Z = u.size, u.type && (P = u.type);
      else if (typeof u[Symbol.asyncIterator] == "function") {
        if (b)
          throw new TypeError("keepalive");
        if (e2.isDisturbed(u) || u.locked)
          throw new TypeError("Response body object should not be disturbed or locked");
        m = u instanceof ReadableStream ? u : A(u);
      }
      if ((typeof v == "string" || e2.isBuffer(v)) && (Z = Buffer.byteLength(v)), T != null) {
        let K;
        m = new ReadableStream({ async start() {
          K = T(u)[Symbol.asyncIterator]();
        }, async pull(tA) {
          const { value: aA, done: X } = await K.next();
          if (X)
            queueMicrotask(() => {
              tA.close(), tA.byobRequest?.respond(0);
            });
          else if (!L(m)) {
            const $ = new Uint8Array(aA);
            $.byteLength && tA.enqueue($);
          }
          return tA.desiredSize > 0;
        }, async cancel(tA) {
          await K.return();
        }, type: "bytes" });
      }
      return [{ stream: m, source: v, length: Z }, P];
    }
    o2(w, "extractBody");
    function U(u, b = false) {
      return u instanceof ReadableStream && (h2(!e2.isDisturbed(u), "The body has already been consumed."), h2(!u.locked, "The stream is locked.")), w(u, b);
    }
    o2(U, "safelyExtractBody");
    function M(u) {
      const [b, m] = u.stream.tee();
      return u.stream = b, { stream: m, length: u.length, source: u.source };
    }
    o2(M, "cloneBody");
    function B(u) {
      if (u.aborted)
        throw new DOMException("The operation was aborted.", "AbortError");
    }
    o2(B, "throwIfAborted");
    function D(u) {
      return { blob() {
        return g(this, (m) => {
          let T = N(this);
          return T === null ? T = "" : T && (T = l2(T)), new f([m], { type: T });
        }, u);
      }, arrayBuffer() {
        return g(this, (m) => new Uint8Array(m).buffer, u);
      }, text() {
        return g(this, Q, u);
      }, json() {
        return g(this, F, u);
      }, formData() {
        return g(this, (m) => {
          const T = N(this);
          if (T !== null)
            switch (T.essence) {
              case "multipart/form-data": {
                const v = S(m, T);
                if (v === "failure")
                  throw new TypeError("Failed to parse body as FormData.");
                const Z = new C;
                return Z[I] = v, Z;
              }
              case "application/x-www-form-urlencoded": {
                const v = new URLSearchParams(m.toString()), Z = new C;
                for (const [P, AA] of v)
                  Z.append(P, AA);
                return Z;
              }
            }
          throw new TypeError('Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".');
        }, u);
      } };
    }
    o2(D, "bodyMixinMethods");
    function G(u) {
      Object.assign(u.prototype, D(u));
    }
    o2(G, "mixinBody");
    async function g(u, b, m) {
      if (a2.brandCheck(u, m), B(u[I]), d(u[I].body))
        throw new TypeError("Body is unusable");
      const T = s2(), v = o2((P) => T.reject(P), "errorSteps"), Z = o2((P) => {
        try {
          T.resolve(b(P));
        } catch (AA) {
          v(AA);
        }
      }, "successSteps");
      return u[I].body == null ? (Z(new Uint8Array), T.promise) : (await i2(u[I].body, Z, v), T.promise);
    }
    o2(g, "consumeBody");
    function d(u) {
      return u != null && (u.stream.locked || e2.isDisturbed(u.stream));
    }
    o2(d, "bodyUnusable");
    function F(u) {
      return JSON.parse(Q(u));
    }
    o2(F, "parseJSONFromBytes");
    function N(u) {
      const b = u[I].headersList, m = E(b);
      return m === "failure" ? null : m;
    }
    return o2(N, "bodyMimeType"), body = { extractBody: w, safelyExtractBody: U, cloneBody: M, mixinBody: G }, body;
  }
  o2(requireBody, "requireBody");
  var assert$a = require$$0__default;
  var util$i = util$m;
  var { channels: channels$1 } = diagnostics;
  var timers = timers$1;
  var { RequestContentLengthMismatchError: RequestContentLengthMismatchError$1, ResponseContentLengthMismatchError, RequestAbortedError: RequestAbortedError$5, HeadersTimeoutError, HeadersOverflowError, SocketError: SocketError$3, InformationalError: InformationalError$2, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError } = errors$1;
  var { kUrl: kUrl$4, kReset: kReset$1, kClient: kClient$3, kParser, kBlocking, kRunning: kRunning$5, kPending: kPending$4, kSize: kSize$4, kWriting, kQueue: kQueue$3, kNoRef, kKeepAliveDefaultTimeout: kKeepAliveDefaultTimeout$1, kHostHeader: kHostHeader$1, kPendingIdx: kPendingIdx$2, kRunningIdx: kRunningIdx$2, kError: kError$2, kPipelining: kPipelining$1, kSocket: kSocket$1, kKeepAliveTimeoutValue: kKeepAliveTimeoutValue$1, kMaxHeadersSize: kMaxHeadersSize$1, kKeepAliveMaxTimeout: kKeepAliveMaxTimeout$1, kKeepAliveTimeoutThreshold: kKeepAliveTimeoutThreshold$1, kHeadersTimeout: kHeadersTimeout$1, kBodyTimeout: kBodyTimeout$1, kStrictContentLength: kStrictContentLength$2, kMaxRequests: kMaxRequests$1, kCounter: kCounter$1, kMaxResponseSize: kMaxResponseSize$1, kOnError: kOnError$2, kResume: kResume$3, kHTTPContext: kHTTPContext$1 } = symbols$4;
  var constants$2 = constants$4;
  var EMPTY_BUF = Buffer.alloc(0);
  var FastBuffer = Buffer[Symbol.species];
  var addListener = util$i.addListener;
  var removeAllListeners = util$i.removeAllListeners;
  var extractBody;
  async function lazyllhttp() {
    const e2 = process.env.JEST_WORKER_ID ? requireLlhttpWasm() : undefined;
    let A;
    try {
      A = await WebAssembly.compile(requireLlhttp_simdWasm());
    } catch {
      A = await WebAssembly.compile(e2 || requireLlhttpWasm());
    }
    return await WebAssembly.instantiate(A, { env: { wasm_on_url: (t2, n, r) => 0, wasm_on_status: (t2, n, r) => {
      assert$a.strictEqual(currentParser.ptr, t2);
      const s2 = n - currentBufferPtr + currentBufferRef.byteOffset;
      return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, s2, r)) || 0;
    }, wasm_on_message_begin: (t2) => (assert$a.strictEqual(currentParser.ptr, t2), currentParser.onMessageBegin() || 0), wasm_on_header_field: (t2, n, r) => {
      assert$a.strictEqual(currentParser.ptr, t2);
      const s2 = n - currentBufferPtr + currentBufferRef.byteOffset;
      return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, s2, r)) || 0;
    }, wasm_on_header_value: (t2, n, r) => {
      assert$a.strictEqual(currentParser.ptr, t2);
      const s2 = n - currentBufferPtr + currentBufferRef.byteOffset;
      return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, s2, r)) || 0;
    }, wasm_on_headers_complete: (t2, n, r, s2) => (assert$a.strictEqual(currentParser.ptr, t2), currentParser.onHeadersComplete(n, !!r, !!s2) || 0), wasm_on_body: (t2, n, r) => {
      assert$a.strictEqual(currentParser.ptr, t2);
      const s2 = n - currentBufferPtr + currentBufferRef.byteOffset;
      return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, s2, r)) || 0;
    }, wasm_on_message_complete: (t2) => (assert$a.strictEqual(currentParser.ptr, t2), currentParser.onMessageComplete() || 0) } });
  }
  o2(lazyllhttp, "lazyllhttp");
  var llhttpInstance = null;
  var llhttpPromise = lazyllhttp();
  llhttpPromise.catch();
  var currentParser = null;
  var currentBufferRef = null;
  var currentBufferSize = 0;
  var currentBufferPtr = null;
  var TIMEOUT_HEADERS = 1;
  var TIMEOUT_BODY = 2;
  var TIMEOUT_IDLE = 3;
  var st = class st2 {
    constructor(A, t2, { exports: n }) {
      assert$a(Number.isFinite(A[kMaxHeadersSize$1]) && A[kMaxHeadersSize$1] > 0), this.llhttp = n, this.ptr = this.llhttp.llhttp_alloc(constants$2.TYPE.RESPONSE), this.client = A, this.socket = t2, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = null, this.statusText = "", this.upgrade = false, this.headers = [], this.headersSize = 0, this.headersMaxSize = A[kMaxHeadersSize$1], this.shouldKeepAlive = false, this.paused = false, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = "", this.contentLength = "", this.connection = "", this.maxResponseSize = A[kMaxResponseSize$1];
    }
    setTimeout(A, t2) {
      this.timeoutType = t2, A !== this.timeoutValue ? (timers.clearTimeout(this.timeout), A ? (this.timeout = timers.setTimeout(onParserTimeout, A, this), this.timeout.unref && this.timeout.unref()) : this.timeout = null, this.timeoutValue = A) : this.timeout && this.timeout.refresh && this.timeout.refresh();
    }
    resume() {
      this.socket.destroyed || !this.paused || (assert$a(this.ptr != null), assert$a(currentParser == null), this.llhttp.llhttp_resume(this.ptr), assert$a(this.timeoutType === TIMEOUT_BODY), this.timeout && this.timeout.refresh && this.timeout.refresh(), this.paused = false, this.execute(this.socket.read() || EMPTY_BUF), this.readMore());
    }
    readMore() {
      for (;!this.paused && this.ptr; ) {
        const A = this.socket.read();
        if (A === null)
          break;
        this.execute(A);
      }
    }
    execute(A) {
      assert$a(this.ptr != null), assert$a(currentParser == null), assert$a(!this.paused);
      const { socket: t2, llhttp: n } = this;
      A.length > currentBufferSize && (currentBufferPtr && n.free(currentBufferPtr), currentBufferSize = Math.ceil(A.length / 4096) * 4096, currentBufferPtr = n.malloc(currentBufferSize)), new Uint8Array(n.memory.buffer, currentBufferPtr, currentBufferSize).set(A);
      try {
        let r;
        try {
          currentBufferRef = A, currentParser = this, r = n.llhttp_execute(this.ptr, currentBufferPtr, A.length);
        } catch (i2) {
          throw i2;
        } finally {
          currentParser = null, currentBufferRef = null;
        }
        const s2 = n.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
        if (r === constants$2.ERROR.PAUSED_UPGRADE)
          this.onUpgrade(A.slice(s2));
        else if (r === constants$2.ERROR.PAUSED)
          this.paused = true, t2.unshift(A.slice(s2));
        else if (r !== constants$2.ERROR.OK) {
          const i2 = n.llhttp_get_error_reason(this.ptr);
          let E = "";
          if (i2) {
            const Q = new Uint8Array(n.memory.buffer, i2).indexOf(0);
            E = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(n.memory.buffer, i2, Q).toString() + ")";
          }
          throw new HTTPParserError(E, constants$2.ERROR[r], A.slice(s2));
        }
      } catch (r) {
        util$i.destroy(t2, r);
      }
    }
    destroy() {
      assert$a(this.ptr != null), assert$a(currentParser == null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, timers.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = false;
    }
    onStatus(A) {
      this.statusText = A.toString();
    }
    onMessageBegin() {
      const { socket: A, client: t2 } = this;
      if (A.destroyed)
        return -1;
      const n = t2[kQueue$3][t2[kRunningIdx$2]];
      if (!n)
        return -1;
      n.onResponseStarted();
    }
    onHeaderField(A) {
      const t2 = this.headers.length;
      t2 & 1 ? this.headers[t2 - 1] = Buffer.concat([this.headers[t2 - 1], A]) : this.headers.push(A), this.trackHeader(A.length);
    }
    onHeaderValue(A) {
      let t2 = this.headers.length;
      (t2 & 1) === 1 ? (this.headers.push(A), t2 += 1) : this.headers[t2 - 1] = Buffer.concat([this.headers[t2 - 1], A]);
      const n = this.headers[t2 - 2];
      if (n.length === 10) {
        const r = util$i.bufferToLowerCasedHeaderName(n);
        r === "keep-alive" ? this.keepAlive += A.toString() : r === "connection" && (this.connection += A.toString());
      } else
        n.length === 14 && util$i.bufferToLowerCasedHeaderName(n) === "content-length" && (this.contentLength += A.toString());
      this.trackHeader(A.length);
    }
    trackHeader(A) {
      this.headersSize += A, this.headersSize >= this.headersMaxSize && util$i.destroy(this.socket, new HeadersOverflowError);
    }
    onUpgrade(A) {
      const { upgrade: t2, client: n, socket: r, headers: s2, statusCode: i2 } = this;
      assert$a(t2);
      const E = n[kQueue$3][n[kRunningIdx$2]];
      assert$a(E), assert$a(!r.destroyed), assert$a(r === n[kSocket$1]), assert$a(!this.paused), assert$a(E.upgrade || E.method === "CONNECT"), this.statusCode = null, this.statusText = "", this.shouldKeepAlive = null, assert$a(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, r.unshift(A), r[kParser].destroy(), r[kParser] = null, r[kClient$3] = null, r[kError$2] = null, removeAllListeners(r), n[kSocket$1] = null, n[kHTTPContext$1] = null, n[kQueue$3][n[kRunningIdx$2]++] = null, n.emit("disconnect", n[kUrl$4], [n], new InformationalError$2("upgrade"));
      try {
        E.onUpgrade(i2, s2, r);
      } catch (Q) {
        util$i.destroy(r, Q);
      }
      n[kResume$3]();
    }
    onHeadersComplete(A, t2, n) {
      const { client: r, socket: s2, headers: i2, statusText: E } = this;
      if (s2.destroyed)
        return -1;
      const Q = r[kQueue$3][r[kRunningIdx$2]];
      if (!Q)
        return -1;
      if (assert$a(!this.upgrade), assert$a(this.statusCode < 200), A === 100)
        return util$i.destroy(s2, new SocketError$3("bad response", util$i.getSocketInfo(s2))), -1;
      if (t2 && !Q.upgrade)
        return util$i.destroy(s2, new SocketError$3("bad upgrade", util$i.getSocketInfo(s2))), -1;
      if (assert$a.strictEqual(this.timeoutType, TIMEOUT_HEADERS), this.statusCode = A, this.shouldKeepAlive = n || Q.method === "HEAD" && !s2[kReset$1] && this.connection.toLowerCase() === "keep-alive", this.statusCode >= 200) {
        const I = Q.bodyTimeout != null ? Q.bodyTimeout : r[kBodyTimeout$1];
        this.setTimeout(I, TIMEOUT_BODY);
      } else
        this.timeout && this.timeout.refresh && this.timeout.refresh();
      if (Q.method === "CONNECT")
        return assert$a(r[kRunning$5] === 1), this.upgrade = true, 2;
      if (t2)
        return assert$a(r[kRunning$5] === 1), this.upgrade = true, 2;
      if (assert$a(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && r[kPipelining$1]) {
        const I = this.keepAlive ? util$i.parseKeepAliveTimeout(this.keepAlive) : null;
        if (I != null) {
          const a2 = Math.min(I - r[kKeepAliveTimeoutThreshold$1], r[kKeepAliveMaxTimeout$1]);
          a2 <= 0 ? s2[kReset$1] = true : r[kKeepAliveTimeoutValue$1] = a2;
        } else
          r[kKeepAliveTimeoutValue$1] = r[kKeepAliveDefaultTimeout$1];
      } else
        s2[kReset$1] = true;
      const C = Q.onHeaders(A, i2, this.resume, E) === false;
      return Q.aborted ? -1 : Q.method === "HEAD" || A < 200 ? 1 : (s2[kBlocking] && (s2[kBlocking] = false, r[kResume$3]()), C ? constants$2.ERROR.PAUSED : 0);
    }
    onBody(A) {
      const { client: t2, socket: n, statusCode: r, maxResponseSize: s2 } = this;
      if (n.destroyed)
        return -1;
      const i2 = t2[kQueue$3][t2[kRunningIdx$2]];
      if (assert$a(i2), assert$a.strictEqual(this.timeoutType, TIMEOUT_BODY), this.timeout && this.timeout.refresh && this.timeout.refresh(), assert$a(r >= 200), s2 > -1 && this.bytesRead + A.length > s2)
        return util$i.destroy(n, new ResponseExceededMaxSizeError), -1;
      if (this.bytesRead += A.length, i2.onData(A) === false)
        return constants$2.ERROR.PAUSED;
    }
    onMessageComplete() {
      const { client: A, socket: t2, statusCode: n, upgrade: r, headers: s2, contentLength: i2, bytesRead: E, shouldKeepAlive: Q } = this;
      if (t2.destroyed && (!n || Q))
        return -1;
      if (r)
        return;
      const C = A[kQueue$3][A[kRunningIdx$2]];
      if (assert$a(C), assert$a(n >= 100), this.statusCode = null, this.statusText = "", this.bytesRead = 0, this.contentLength = "", this.keepAlive = "", this.connection = "", assert$a(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, !(n < 200)) {
        if (C.method !== "HEAD" && i2 && E !== parseInt(i2, 10))
          return util$i.destroy(t2, new ResponseContentLengthMismatchError), -1;
        if (C.onComplete(s2), A[kQueue$3][A[kRunningIdx$2]++] = null, t2[kWriting])
          return assert$a.strictEqual(A[kRunning$5], 0), util$i.destroy(t2, new InformationalError$2("reset")), constants$2.ERROR.PAUSED;
        if (Q) {
          if (t2[kReset$1] && A[kRunning$5] === 0)
            return util$i.destroy(t2, new InformationalError$2("reset")), constants$2.ERROR.PAUSED;
          A[kPipelining$1] == null || A[kPipelining$1] === 1 ? setImmediate(() => A[kResume$3]()) : A[kResume$3]();
        } else
          return util$i.destroy(t2, new InformationalError$2("reset")), constants$2.ERROR.PAUSED;
      }
    }
  };
  o2(st, "Parser");
  var Parser = st;
  function onParserTimeout(e2) {
    const { socket: A, timeoutType: t2, client: n } = e2;
    t2 === TIMEOUT_HEADERS ? (!A[kWriting] || A.writableNeedDrain || n[kRunning$5] > 1) && (assert$a(!e2.paused, "cannot be paused while waiting for headers"), util$i.destroy(A, new HeadersTimeoutError)) : t2 === TIMEOUT_BODY ? e2.paused || util$i.destroy(A, new BodyTimeoutError) : t2 === TIMEOUT_IDLE && (assert$a(n[kRunning$5] === 0 && n[kKeepAliveTimeoutValue$1]), util$i.destroy(A, new InformationalError$2("socket idle timeout")));
  }
  o2(onParserTimeout, "onParserTimeout");
  async function connectH1$1(e2, A) {
    e2[kSocket$1] = A, llhttpInstance || (llhttpInstance = await llhttpPromise, llhttpPromise = null), A[kNoRef] = false, A[kWriting] = false, A[kReset$1] = false, A[kBlocking] = false, A[kParser] = new Parser(e2, A, llhttpInstance), addListener(A, "error", function(n) {
      const r = this[kParser];
      if (assert$a(n.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), n.code === "ECONNRESET" && r.statusCode && !r.shouldKeepAlive) {
        r.onMessageComplete();
        return;
      }
      this[kError$2] = n, this[kClient$3][kOnError$2](n);
    }), addListener(A, "readable", function() {
      const n = this[kParser];
      n && n.readMore();
    }), addListener(A, "end", function() {
      const n = this[kParser];
      if (n.statusCode && !n.shouldKeepAlive) {
        n.onMessageComplete();
        return;
      }
      util$i.destroy(this, new SocketError$3("other side closed", util$i.getSocketInfo(this)));
    }), addListener(A, "close", function() {
      const n = this[kClient$3], r = this[kParser];
      r && (!this[kError$2] && r.statusCode && !r.shouldKeepAlive && r.onMessageComplete(), this[kParser].destroy(), this[kParser] = null);
      const s2 = this[kError$2] || new SocketError$3("closed", util$i.getSocketInfo(this));
      if (n[kSocket$1] = null, n[kHTTPContext$1] = null, n.destroyed) {
        assert$a(n[kPending$4] === 0);
        const i2 = n[kQueue$3].splice(n[kRunningIdx$2]);
        for (let E = 0;E < i2.length; E++) {
          const Q = i2[E];
          util$i.errorRequest(n, Q, s2);
        }
      } else if (n[kRunning$5] > 0 && s2.code !== "UND_ERR_INFO") {
        const i2 = n[kQueue$3][n[kRunningIdx$2]];
        n[kQueue$3][n[kRunningIdx$2]++] = null, util$i.errorRequest(n, i2, s2);
      }
      n[kPendingIdx$2] = n[kRunningIdx$2], assert$a(n[kRunning$5] === 0), n.emit("disconnect", n[kUrl$4], [n], s2), n[kResume$3]();
    });
    let t2 = false;
    return A.on("close", () => {
      t2 = true;
    }), { version: "h1", defaultPipelining: 1, write(...n) {
      return writeH1(e2, ...n);
    }, resume() {
      resumeH1(e2);
    }, destroy(n, r) {
      t2 ? queueMicrotask(r) : A.destroy(n).on("close", r);
    }, get destroyed() {
      return A.destroyed;
    }, busy(n) {
      return !!(A[kWriting] || A[kReset$1] || A[kBlocking] || n && (e2[kRunning$5] > 0 && !n.idempotent || e2[kRunning$5] > 0 && (n.upgrade || n.method === "CONNECT") || e2[kRunning$5] > 0 && util$i.bodyLength(n.body) !== 0 && (util$i.isStream(n.body) || util$i.isAsyncIterable(n.body) || util$i.isFormDataLike(n.body))));
    } };
  }
  o2(connectH1$1, "connectH1$1");
  function resumeH1(e2) {
    const A = e2[kSocket$1];
    if (A && !A.destroyed) {
      if (e2[kSize$4] === 0 ? !A[kNoRef] && A.unref && (A.unref(), A[kNoRef] = true) : A[kNoRef] && A.ref && (A.ref(), A[kNoRef] = false), e2[kSize$4] === 0)
        A[kParser].timeoutType !== TIMEOUT_IDLE && A[kParser].setTimeout(e2[kKeepAliveTimeoutValue$1], TIMEOUT_IDLE);
      else if (e2[kRunning$5] > 0 && A[kParser].statusCode < 200 && A[kParser].timeoutType !== TIMEOUT_HEADERS) {
        const t2 = e2[kQueue$3][e2[kRunningIdx$2]], n = t2.headersTimeout != null ? t2.headersTimeout : e2[kHeadersTimeout$1];
        A[kParser].setTimeout(n, TIMEOUT_HEADERS);
      }
    }
  }
  o2(resumeH1, "resumeH1");
  function shouldSendContentLength$1(e2) {
    return e2 !== "GET" && e2 !== "HEAD" && e2 !== "OPTIONS" && e2 !== "TRACE" && e2 !== "CONNECT";
  }
  o2(shouldSendContentLength$1, "shouldSendContentLength$1");
  function writeH1(e2, A) {
    const { method: t2, path: n, host: r, upgrade: s2, blocking: i2, reset: E } = A;
    let { body: Q, headers: C, contentLength: I } = A;
    const a2 = t2 === "PUT" || t2 === "POST" || t2 === "PATCH";
    if (util$i.isFormDataLike(Q)) {
      extractBody || (extractBody = requireBody().extractBody);
      const [l2, S] = extractBody(Q);
      A.contentType == null && C.push("content-type", S), Q = l2.stream, I = l2.length;
    } else
      util$i.isBlobLike(Q) && A.contentType == null && Q.type && C.push("content-type", Q.type);
    Q && typeof Q.read == "function" && Q.read(0);
    const f = util$i.bodyLength(Q);
    if (I = f ?? I, I === null && (I = A.contentLength), I === 0 && !a2 && (I = null), shouldSendContentLength$1(t2) && I > 0 && A.contentLength !== null && A.contentLength !== I) {
      if (e2[kStrictContentLength$2])
        return util$i.errorRequest(e2, A, new RequestContentLengthMismatchError$1), false;
      process.emitWarning(new RequestContentLengthMismatchError$1);
    }
    const h2 = e2[kSocket$1], L = o2((l2) => {
      A.aborted || A.completed || (util$i.errorRequest(e2, A, l2 || new RequestAbortedError$5), util$i.destroy(Q), util$i.destroy(h2, new InformationalError$2("aborted")));
    }, "abort");
    try {
      A.onConnect(L);
    } catch (l2) {
      util$i.errorRequest(e2, A, l2);
    }
    if (A.aborted)
      return false;
    t2 === "HEAD" && (h2[kReset$1] = true), (s2 || t2 === "CONNECT") && (h2[kReset$1] = true), E != null && (h2[kReset$1] = E), e2[kMaxRequests$1] && h2[kCounter$1]++ >= e2[kMaxRequests$1] && (h2[kReset$1] = true), i2 && (h2[kBlocking] = true);
    let c = `${t2} ${n} HTTP/1.1\r
`;
    if (typeof r == "string" ? c += `host: ${r}\r
` : c += e2[kHostHeader$1], s2 ? c += `connection: upgrade\r
upgrade: ${s2}\r
` : e2[kPipelining$1] && !h2[kReset$1] ? c += `connection: keep-alive\r
` : c += `connection: close\r
`, Array.isArray(C))
      for (let l2 = 0;l2 < C.length; l2 += 2) {
        const S = C[l2 + 0], k = C[l2 + 1];
        if (Array.isArray(k))
          for (let w = 0;w < k.length; w++)
            c += `${S}: ${k[w]}\r
`;
        else
          c += `${S}: ${k}\r
`;
      }
    return channels$1.sendHeaders.hasSubscribers && channels$1.sendHeaders.publish({ request: A, headers: c, socket: h2 }), !Q || f === 0 ? writeBuffer({ abort: L, body: null, client: e2, request: A, socket: h2, contentLength: I, header: c, expectsPayload: a2 }) : util$i.isBuffer(Q) ? writeBuffer({ abort: L, body: Q, client: e2, request: A, socket: h2, contentLength: I, header: c, expectsPayload: a2 }) : util$i.isBlobLike(Q) ? typeof Q.stream == "function" ? writeIterable$1({ abort: L, body: Q.stream(), client: e2, request: A, socket: h2, contentLength: I, header: c, expectsPayload: a2 }) : writeBlob$1({ abort: L, body: Q, client: e2, request: A, socket: h2, contentLength: I, header: c, expectsPayload: a2 }) : util$i.isStream(Q) ? writeStream$1({ abort: L, body: Q, client: e2, request: A, socket: h2, contentLength: I, header: c, expectsPayload: a2 }) : util$i.isIterable(Q) ? writeIterable$1({ abort: L, body: Q, client: e2, request: A, socket: h2, contentLength: I, header: c, expectsPayload: a2 }) : assert$a(false), true;
  }
  o2(writeH1, "writeH1");
  function writeStream$1({ abort: e2, body: A, client: t2, request: n, socket: r, contentLength: s2, header: i2, expectsPayload: E }) {
    assert$a(s2 !== 0 || t2[kRunning$5] === 0, "stream body cannot be pipelined");
    let Q = false;
    const C = new AsyncWriter({ abort: e2, socket: r, request: n, contentLength: s2, client: t2, expectsPayload: E, header: i2 }), I = o2(function(L) {
      if (!Q)
        try {
          !C.write(L) && this.pause && this.pause();
        } catch (c) {
          util$i.destroy(this, c);
        }
    }, "onData"), a2 = o2(function() {
      Q || A.resume && A.resume();
    }, "onDrain"), f = o2(function() {
      if (queueMicrotask(() => {
        A.removeListener("error", h2);
      }), !Q) {
        const L = new RequestAbortedError$5;
        queueMicrotask(() => h2(L));
      }
    }, "onClose"), h2 = o2(function(L) {
      if (!Q) {
        if (Q = true, assert$a(r.destroyed || r[kWriting] && t2[kRunning$5] <= 1), r.off("drain", a2).off("error", h2), A.removeListener("data", I).removeListener("end", h2).removeListener("close", f), !L)
          try {
            C.end();
          } catch (c) {
            L = c;
          }
        C.destroy(L), L && (L.code !== "UND_ERR_INFO" || L.message !== "reset") ? util$i.destroy(A, L) : util$i.destroy(A);
      }
    }, "onFinished");
    A.on("data", I).on("end", h2).on("error", h2).on("close", f), A.resume && A.resume(), r.on("drain", a2).on("error", h2), A.errorEmitted ?? A.errored ? setImmediate(() => h2(A.errored)) : (A.endEmitted ?? A.readableEnded) && setImmediate(() => h2(null)), (A.closeEmitted ?? A.closed) && setImmediate(f);
  }
  o2(writeStream$1, "writeStream$1");
  async function writeBuffer({ abort: e2, body: A, client: t2, request: n, socket: r, contentLength: s2, header: i2, expectsPayload: E }) {
    try {
      A ? util$i.isBuffer(A) && (assert$a(s2 === A.byteLength, "buffer body must have content length"), r.cork(), r.write(`${i2}content-length: ${s2}\r
\r
`, "latin1"), r.write(A), r.uncork(), n.onBodySent(A), E || (r[kReset$1] = true)) : s2 === 0 ? r.write(`${i2}content-length: 0\r
\r
`, "latin1") : (assert$a(s2 === null, "no body must not have content length"), r.write(`${i2}\r
`, "latin1")), n.onRequestSent(), t2[kResume$3]();
    } catch (Q) {
      e2(Q);
    }
  }
  o2(writeBuffer, "writeBuffer");
  async function writeBlob$1({ abort: e2, body: A, client: t2, request: n, socket: r, contentLength: s2, header: i2, expectsPayload: E }) {
    assert$a(s2 === A.size, "blob body must have content length");
    try {
      if (s2 != null && s2 !== A.size)
        throw new RequestContentLengthMismatchError$1;
      const Q = Buffer.from(await A.arrayBuffer());
      r.cork(), r.write(`${i2}content-length: ${s2}\r
\r
`, "latin1"), r.write(Q), r.uncork(), n.onBodySent(Q), n.onRequestSent(), E || (r[kReset$1] = true), t2[kResume$3]();
    } catch (Q) {
      e2(Q);
    }
  }
  o2(writeBlob$1, "writeBlob$1");
  async function writeIterable$1({ abort: e2, body: A, client: t2, request: n, socket: r, contentLength: s2, header: i2, expectsPayload: E }) {
    assert$a(s2 !== 0 || t2[kRunning$5] === 0, "iterator body cannot be pipelined");
    let Q = null;
    function C() {
      if (Q) {
        const f = Q;
        Q = null, f();
      }
    }
    o2(C, "onDrain");
    const I = o2(() => new Promise((f, h2) => {
      assert$a(Q === null), r[kError$2] ? h2(r[kError$2]) : Q = f;
    }), "waitForDrain");
    r.on("close", C).on("drain", C);
    const a2 = new AsyncWriter({ abort: e2, socket: r, request: n, contentLength: s2, client: t2, expectsPayload: E, header: i2 });
    try {
      for await (const f of A) {
        if (r[kError$2])
          throw r[kError$2];
        a2.write(f) || await I();
      }
      a2.end();
    } catch (f) {
      a2.destroy(f);
    } finally {
      r.off("close", C).off("drain", C);
    }
  }
  o2(writeIterable$1, "writeIterable$1");
  var ot = class ot2 {
    constructor({ abort: A, socket: t2, request: n, contentLength: r, client: s2, expectsPayload: i2, header: E }) {
      this.socket = t2, this.request = n, this.contentLength = r, this.client = s2, this.bytesWritten = 0, this.expectsPayload = i2, this.header = E, this.abort = A, t2[kWriting] = true;
    }
    write(A) {
      const { socket: t2, request: n, contentLength: r, client: s2, bytesWritten: i2, expectsPayload: E, header: Q } = this;
      if (t2[kError$2])
        throw t2[kError$2];
      if (t2.destroyed)
        return false;
      const C = Buffer.byteLength(A);
      if (!C)
        return true;
      if (r !== null && i2 + C > r) {
        if (s2[kStrictContentLength$2])
          throw new RequestContentLengthMismatchError$1;
        process.emitWarning(new RequestContentLengthMismatchError$1);
      }
      t2.cork(), i2 === 0 && (E || (t2[kReset$1] = true), r === null ? t2.write(`${Q}transfer-encoding: chunked\r
`, "latin1") : t2.write(`${Q}content-length: ${r}\r
\r
`, "latin1")), r === null && t2.write(`\r
${C.toString(16)}\r
`, "latin1"), this.bytesWritten += C;
      const I = t2.write(A);
      return t2.uncork(), n.onBodySent(A), I || t2[kParser].timeout && t2[kParser].timeoutType === TIMEOUT_HEADERS && t2[kParser].timeout.refresh && t2[kParser].timeout.refresh(), I;
    }
    end() {
      const { socket: A, contentLength: t2, client: n, bytesWritten: r, expectsPayload: s2, header: i2, request: E } = this;
      if (E.onRequestSent(), A[kWriting] = false, A[kError$2])
        throw A[kError$2];
      if (!A.destroyed) {
        if (r === 0 ? s2 ? A.write(`${i2}content-length: 0\r
\r
`, "latin1") : A.write(`${i2}\r
`, "latin1") : t2 === null && A.write(`\r
0\r
\r
`, "latin1"), t2 !== null && r !== t2) {
          if (n[kStrictContentLength$2])
            throw new RequestContentLengthMismatchError$1;
          process.emitWarning(new RequestContentLengthMismatchError$1);
        }
        A[kParser].timeout && A[kParser].timeoutType === TIMEOUT_HEADERS && A[kParser].timeout.refresh && A[kParser].timeout.refresh(), n[kResume$3]();
      }
    }
    destroy(A) {
      const { socket: t2, client: n, abort: r } = this;
      t2[kWriting] = false, A && (assert$a(n[kRunning$5] <= 1, "pipeline should only contain this request"), r(A));
    }
  };
  o2(ot, "AsyncWriter");
  var AsyncWriter = ot;
  var clientH1 = connectH1$1;
  var assert$9 = require$$0__default;
  var { pipeline: pipeline$1 } = Stream__default;
  var util$h = util$m;
  var { RequestContentLengthMismatchError, RequestAbortedError: RequestAbortedError$4, SocketError: SocketError$2, InformationalError: InformationalError$1 } = errors$1;
  var { kUrl: kUrl$3, kReset, kClient: kClient$2, kRunning: kRunning$4, kPending: kPending$3, kQueue: kQueue$2, kPendingIdx: kPendingIdx$1, kRunningIdx: kRunningIdx$1, kError: kError$1, kSocket, kStrictContentLength: kStrictContentLength$1, kOnError: kOnError$1, kMaxConcurrentStreams: kMaxConcurrentStreams$1, kHTTP2Session, kResume: kResume$2 } = symbols$4;
  var kOpenStreams = Symbol("open streams");
  var h2ExperimentalWarned = false;
  var http2;
  try {
    http2 = __require("http2");
  } catch {
    http2 = { constants: {} };
  }
  var { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;
  function parseH2Headers(e2) {
    const A = [];
    for (const [t2, n] of Object.entries(e2))
      if (Array.isArray(n))
        for (const r of n)
          A.push(Buffer.from(t2), Buffer.from(r));
      else
        A.push(Buffer.from(t2), Buffer.from(n));
    return A;
  }
  o2(parseH2Headers, "parseH2Headers");
  async function connectH2$1(e2, A) {
    e2[kSocket] = A, h2ExperimentalWarned || (h2ExperimentalWarned = true, process.emitWarning("H2 support is experimental, expect them to change at any time.", { code: "UNDICI-H2" }));
    const t2 = http2.connect(e2[kUrl$3], { createConnection: () => A, peerMaxConcurrentStreams: e2[kMaxConcurrentStreams$1] });
    t2[kOpenStreams] = 0, t2[kClient$2] = e2, t2[kSocket] = A, util$h.addListener(t2, "error", onHttp2SessionError), util$h.addListener(t2, "frameError", onHttp2FrameError), util$h.addListener(t2, "end", onHttp2SessionEnd), util$h.addListener(t2, "goaway", onHTTP2GoAway), util$h.addListener(t2, "close", function() {
      const { [kClient$2]: r } = this, s2 = this[kSocket][kError$1] || new SocketError$2("closed", util$h.getSocketInfo(this));
      r[kSocket] = null, r[kHTTP2Session] = null, assert$9(r[kPending$3] === 0);
      const i2 = r[kQueue$2].splice(r[kRunningIdx$1]);
      for (let E = 0;E < i2.length; E++) {
        const Q = i2[E];
        util$h.errorRequest(r, Q, s2);
      }
      r[kPendingIdx$1] = r[kRunningIdx$1], assert$9(r[kRunning$4] === 0), r.emit("disconnect", r[kUrl$3], [r], s2), r[kResume$2]();
    }), t2.unref(), e2[kHTTP2Session] = t2, A[kHTTP2Session] = t2, util$h.addListener(A, "error", function(r) {
      assert$9(r.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[kError$1] = r, this[kClient$2][kOnError$1](r);
    }), util$h.addListener(A, "end", function() {
      util$h.destroy(this, new SocketError$2("other side closed", util$h.getSocketInfo(this)));
    });
    let n = false;
    return A.on("close", () => {
      n = true;
    }), { version: "h2", defaultPipelining: 1 / 0, write(...r) {
      writeH2(e2, ...r);
    }, resume() {}, destroy(r, s2) {
      t2.destroy(r), n ? queueMicrotask(s2) : A.destroy(r).on("close", s2);
    }, get destroyed() {
      return A.destroyed;
    }, busy() {
      return false;
    } };
  }
  o2(connectH2$1, "connectH2$1");
  function onHttp2SessionError(e2) {
    assert$9(e2.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[kSocket][kError$1] = e2, this[kClient$2][kOnError$1](e2);
  }
  o2(onHttp2SessionError, "onHttp2SessionError");
  function onHttp2FrameError(e2, A, t2) {
    if (t2 === 0) {
      const n = new InformationalError$1(`HTTP/2: "frameError" received - type ${e2}, code ${A}`);
      this[kSocket][kError$1] = n, this[kClient$2][kOnError$1](n);
    }
  }
  o2(onHttp2FrameError, "onHttp2FrameError");
  function onHttp2SessionEnd() {
    const e2 = new SocketError$2("other side closed", util$h.getSocketInfo(this[kSocket]));
    this.destroy(e2), util$h.destroy(this[kSocket], e2);
  }
  o2(onHttp2SessionEnd, "onHttp2SessionEnd");
  function onHTTP2GoAway(e2) {
    const A = new InformationalError$1(`HTTP/2: "GOAWAY" frame received with code ${e2}`);
    this[kSocket][kError$1] = A, this[kClient$2][kOnError$1](A), this.unref(), this.destroy(), util$h.destroy(this[kSocket], A);
  }
  o2(onHTTP2GoAway, "onHTTP2GoAway");
  function shouldSendContentLength(e2) {
    return e2 !== "GET" && e2 !== "HEAD" && e2 !== "OPTIONS" && e2 !== "TRACE" && e2 !== "CONNECT";
  }
  o2(shouldSendContentLength, "shouldSendContentLength");
  function writeH2(e2, A) {
    const t2 = e2[kHTTP2Session], { body: n, method: r, path: s2, host: i2, upgrade: E, expectContinue: Q, signal: C, headers: I } = A;
    if (E)
      return util$h.errorRequest(e2, A, new Error("Upgrade not supported for H2")), false;
    if (A.aborted)
      return false;
    const a2 = {};
    for (let w = 0;w < I.length; w += 2) {
      const U = I[w + 0], M = I[w + 1];
      if (Array.isArray(M))
        for (let B = 0;B < M.length; B++)
          a2[U] ? a2[U] += `,${M[B]}` : a2[U] = M[B];
      else
        a2[U] = M;
    }
    let f;
    const { hostname: h2, port: L } = e2[kUrl$3];
    a2[HTTP2_HEADER_AUTHORITY] = i2 || `${h2}${L ? `:${L}` : ""}`, a2[HTTP2_HEADER_METHOD] = r;
    try {
      A.onConnect((w) => {
        A.aborted || A.completed || (w = w || new RequestAbortedError$4, f != null && (util$h.destroy(f, w), t2[kOpenStreams] -= 1, t2[kOpenStreams] === 0 && t2.unref()), util$h.errorRequest(e2, A, w));
      });
    } catch (w) {
      util$h.errorRequest(e2, A, w);
    }
    if (r === "CONNECT")
      return t2.ref(), f = t2.request(a2, { endStream: false, signal: C }), f.id && !f.pending ? (A.onUpgrade(null, null, f), ++t2[kOpenStreams]) : f.once("ready", () => {
        A.onUpgrade(null, null, f), ++t2[kOpenStreams];
      }), f.once("close", () => {
        t2[kOpenStreams] -= 1, t2[kOpenStreams] === 0 && t2.unref();
      }), true;
    a2[HTTP2_HEADER_PATH] = s2, a2[HTTP2_HEADER_SCHEME] = "https";
    const c = r === "PUT" || r === "POST" || r === "PATCH";
    n && typeof n.read == "function" && n.read(0);
    let l2 = util$h.bodyLength(n);
    if (l2 == null && (l2 = A.contentLength), (l2 === 0 || !c) && (l2 = null), shouldSendContentLength(r) && l2 > 0 && A.contentLength != null && A.contentLength !== l2) {
      if (e2[kStrictContentLength$1])
        return util$h.errorRequest(e2, A, new RequestContentLengthMismatchError), false;
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    l2 != null && (assert$9(n, "no body must not have content length"), a2[HTTP2_HEADER_CONTENT_LENGTH] = `${l2}`), t2.ref();
    const S = r === "GET" || r === "HEAD" || n === null;
    return Q ? (a2[HTTP2_HEADER_EXPECT] = "100-continue", f = t2.request(a2, { endStream: S, signal: C }), f.once("continue", k)) : (f = t2.request(a2, { endStream: S, signal: C }), k()), ++t2[kOpenStreams], f.once("response", (w) => {
      const { [HTTP2_HEADER_STATUS]: U, ...M } = w;
      if (A.onResponseStarted(), A.aborted || A.completed) {
        const B = new RequestAbortedError$4;
        util$h.errorRequest(e2, A, B), util$h.destroy(f, B);
        return;
      }
      A.onHeaders(Number(U), parseH2Headers(M), f.resume.bind(f), "") === false && f.pause(), f.on("data", (B) => {
        A.onData(B) === false && f.pause();
      });
    }), f.once("end", () => {
      if (f.state?.state == null || f.state.state < 6) {
        A.onComplete([]);
        return;
      }
      t2[kOpenStreams] -= 1, t2[kOpenStreams] === 0 && t2.unref();
      const w = new InformationalError$1("HTTP/2: stream half-closed (remote)");
      util$h.errorRequest(e2, A, w), util$h.destroy(f, w);
    }), f.once("close", () => {
      t2[kOpenStreams] -= 1, t2[kOpenStreams] === 0 && t2.unref();
    }), f.once("error", function(w) {
      e2[kHTTP2Session] && !e2[kHTTP2Session].destroyed && !this.closed && !this.destroyed && (t2[kOpenStreams] -= 1, util$h.errorRequest(e2, A, w), util$h.destroy(f, w));
    }), f.once("frameError", (w, U) => {
      const M = new InformationalError$1(`HTTP/2: "frameError" received - type ${w}, code ${U}`);
      util$h.errorRequest(e2, A, M), e2[kHTTP2Session] && !e2[kHTTP2Session].destroyed && !this.closed && !this.destroyed && (t2[kOpenStreams] -= 1, util$h.destroy(f, M));
    }), true;
    function k() {
      n ? util$h.isBuffer(n) ? (assert$9(l2 === n.byteLength, "buffer body must have content length"), f.cork(), f.write(n), f.uncork(), f.end(), A.onBodySent(n), A.onRequestSent()) : util$h.isBlobLike(n) ? typeof n.stream == "function" ? writeIterable({ client: e2, request: A, contentLength: l2, h2stream: f, expectsPayload: c, body: n.stream(), socket: e2[kSocket], header: "" }) : writeBlob({ body: n, client: e2, request: A, contentLength: l2, expectsPayload: c, h2stream: f, header: "", socket: e2[kSocket] }) : util$h.isStream(n) ? writeStream({ body: n, client: e2, request: A, contentLength: l2, expectsPayload: c, socket: e2[kSocket], h2stream: f, header: "" }) : util$h.isIterable(n) ? writeIterable({ body: n, client: e2, request: A, contentLength: l2, expectsPayload: c, header: "", h2stream: f, socket: e2[kSocket] }) : assert$9(false) : A.onRequestSent();
    }
    o2(k, "writeBodyH2");
  }
  o2(writeH2, "writeH2");
  function writeStream({ h2stream: e2, body: A, client: t2, request: n, socket: r, contentLength: s2, header: i2, expectsPayload: E }) {
    assert$9(s2 !== 0 || t2[kRunning$4] === 0, "stream body cannot be pipelined");
    const Q = pipeline$1(A, e2, (I) => {
      I ? (util$h.destroy(A, I), util$h.destroy(e2, I)) : n.onRequestSent();
    });
    Q.on("data", C), Q.once("end", () => {
      Q.removeListener("data", C), util$h.destroy(Q);
    });
    function C(I) {
      n.onBodySent(I);
    }
    o2(C, "onPipeData");
  }
  o2(writeStream, "writeStream");
  async function writeBlob({ h2stream: e2, body: A, client: t2, request: n, socket: r, contentLength: s2, header: i2, expectsPayload: E }) {
    assert$9(s2 === A.size, "blob body must have content length");
    try {
      if (s2 != null && s2 !== A.size)
        throw new RequestContentLengthMismatchError;
      const Q = Buffer.from(await A.arrayBuffer());
      e2.cork(), e2.write(Q), e2.uncork(), n.onBodySent(Q), n.onRequestSent(), E || (r[kReset] = true), t2[kResume$2]();
    } catch {
      util$h.destroy(e2);
    }
  }
  o2(writeBlob, "writeBlob");
  async function writeIterable({ h2stream: e2, body: A, client: t2, request: n, socket: r, contentLength: s2, header: i2, expectsPayload: E }) {
    assert$9(s2 !== 0 || t2[kRunning$4] === 0, "iterator body cannot be pipelined");
    let Q = null;
    function C() {
      if (Q) {
        const a2 = Q;
        Q = null, a2();
      }
    }
    o2(C, "onDrain");
    const I = o2(() => new Promise((a2, f) => {
      assert$9(Q === null), r[kError$1] ? f(r[kError$1]) : Q = a2;
    }), "waitForDrain");
    e2.on("close", C).on("drain", C);
    try {
      for await (const a2 of A) {
        if (r[kError$1])
          throw r[kError$1];
        const f = e2.write(a2);
        n.onBodySent(a2), f || await I();
      }
    } catch (a2) {
      e2.destroy(a2);
    } finally {
      n.onRequestSent(), e2.end(), e2.off("close", C).off("drain", C);
    }
  }
  o2(writeIterable, "writeIterable");
  var clientH2 = connectH2$1;
  var util$g = util$m;
  var { kBodyUsed } = symbols$4;
  var assert$8 = require$$0__default;
  var { InvalidArgumentError: InvalidArgumentError$f } = errors$1;
  var EE = require$$0__default$3;
  var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
  var kBody$1 = Symbol("body");
  var it = class it2 {
    constructor(A) {
      this[kBody$1] = A, this[kBodyUsed] = false;
    }
    async* [Symbol.asyncIterator]() {
      assert$8(!this[kBodyUsed], "disturbed"), this[kBodyUsed] = true, yield* this[kBody$1];
    }
  };
  o2(it, "BodyAsyncIterable");
  var BodyAsyncIterable = it;
  var RedirectHandler$1 = (Ue = class {
    constructor(A, t2, n, r) {
      if (t2 != null && (!Number.isInteger(t2) || t2 < 0))
        throw new InvalidArgumentError$f("maxRedirections must be a positive number");
      util$g.validateHandler(r, n.method, n.upgrade), this.dispatch = A, this.location = null, this.abort = null, this.opts = { ...n, maxRedirections: 0 }, this.maxRedirections = t2, this.handler = r, this.history = [], this.redirectionLimitReached = false, util$g.isStream(this.opts.body) ? (util$g.bodyLength(this.opts.body) === 0 && this.opts.body.on("data", function() {
        assert$8(false);
      }), typeof this.opts.body.readableDidRead != "boolean" && (this.opts.body[kBodyUsed] = false, EE.prototype.on.call(this.opts.body, "data", function() {
        this[kBodyUsed] = true;
      }))) : this.opts.body && typeof this.opts.body.pipeTo == "function" ? this.opts.body = new BodyAsyncIterable(this.opts.body) : this.opts.body && typeof this.opts.body != "string" && !ArrayBuffer.isView(this.opts.body) && util$g.isIterable(this.opts.body) && (this.opts.body = new BodyAsyncIterable(this.opts.body));
    }
    onConnect(A) {
      this.abort = A, this.handler.onConnect(A, { history: this.history });
    }
    onUpgrade(A, t2, n) {
      this.handler.onUpgrade(A, t2, n);
    }
    onError(A) {
      this.handler.onError(A);
    }
    onHeaders(A, t2, n, r) {
      if (this.location = this.history.length >= this.maxRedirections || util$g.isDisturbed(this.opts.body) ? null : parseLocation(A, t2), this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
        this.request && this.request.abort(new Error("max redirects")), this.redirectionLimitReached = true, this.abort(new Error("max redirects"));
        return;
      }
      if (this.opts.origin && this.history.push(new URL(this.opts.path, this.opts.origin)), !this.location)
        return this.handler.onHeaders(A, t2, n, r);
      const { origin: s2, pathname: i2, search: E } = util$g.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))), Q = E ? `${i2}${E}` : i2;
      this.opts.headers = cleanRequestHeaders(this.opts.headers, A === 303, this.opts.origin !== s2), this.opts.path = Q, this.opts.origin = s2, this.opts.maxRedirections = 0, this.opts.query = null, A === 303 && this.opts.method !== "HEAD" && (this.opts.method = "GET", this.opts.body = null);
    }
    onData(A) {
      if (!this.location)
        return this.handler.onData(A);
    }
    onComplete(A) {
      this.location ? (this.location = null, this.abort = null, this.dispatch(this.opts, this)) : this.handler.onComplete(A);
    }
    onBodySent(A) {
      this.handler.onBodySent && this.handler.onBodySent(A);
    }
  }, o2(Ue, "RedirectHandler"), Ue);
  function parseLocation(e2, A) {
    if (redirectableStatusCodes.indexOf(e2) === -1)
      return null;
    for (let t2 = 0;t2 < A.length; t2 += 2)
      if (A[t2].length === 8 && util$g.headerNameToString(A[t2]) === "location")
        return A[t2 + 1];
  }
  o2(parseLocation, "parseLocation");
  function shouldRemoveHeader(e2, A, t2) {
    if (e2.length === 4)
      return util$g.headerNameToString(e2) === "host";
    if (A && util$g.headerNameToString(e2).startsWith("content-"))
      return true;
    if (t2 && (e2.length === 13 || e2.length === 6 || e2.length === 19)) {
      const n = util$g.headerNameToString(e2);
      return n === "authorization" || n === "cookie" || n === "proxy-authorization";
    }
    return false;
  }
  o2(shouldRemoveHeader, "shouldRemoveHeader");
  function cleanRequestHeaders(e2, A, t2) {
    const n = [];
    if (Array.isArray(e2))
      for (let r = 0;r < e2.length; r += 2)
        shouldRemoveHeader(e2[r], A, t2) || n.push(e2[r], e2[r + 1]);
    else if (e2 && typeof e2 == "object")
      for (const r of Object.keys(e2))
        shouldRemoveHeader(r, A, t2) || n.push(r, e2[r]);
    else
      assert$8(e2 == null, "headers must be an object or an array");
    return n;
  }
  o2(cleanRequestHeaders, "cleanRequestHeaders");
  var redirectHandler = RedirectHandler$1;
  var RedirectHandler = redirectHandler;
  function createRedirectInterceptor$2({ maxRedirections: e2 }) {
    return (A) => o2(function(n, r) {
      const { maxRedirections: s2 = e2 } = n;
      if (!s2)
        return A(n, r);
      const i2 = new RedirectHandler(A, s2, n, r);
      return n = { ...n, maxRedirections: 0 }, A(n, i2);
    }, "Intercept");
  }
  o2(createRedirectInterceptor$2, "createRedirectInterceptor$2");
  var redirectInterceptor = createRedirectInterceptor$2;
  var assert$7 = require$$0__default;
  var net = require$$4__default;
  var http = http__default;
  var util$f = util$m;
  var { channels } = diagnostics;
  var Request2 = request$2;
  var DispatcherBase$3 = dispatcherBase;
  var { InvalidArgumentError: InvalidArgumentError$e, InformationalError, ClientDestroyedError } = errors$1;
  var buildConnector$2 = connect$2;
  var { kUrl: kUrl$2, kServerName, kClient: kClient$1, kBusy: kBusy$1, kConnect, kResuming, kRunning: kRunning$3, kPending: kPending$2, kSize: kSize$3, kQueue: kQueue$1, kConnected: kConnected$4, kConnecting, kNeedDrain: kNeedDrain$2, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections: kMaxRedirections$1, kMaxRequests, kCounter, kClose: kClose$5, kDestroy: kDestroy$3, kDispatch: kDispatch$2, kInterceptors: kInterceptors$3, kLocalAddress, kMaxResponseSize, kOnError, kHTTPContext, kMaxConcurrentStreams, kResume: kResume$1 } = symbols$4;
  var connectH1 = clientH1;
  var connectH2 = clientH2;
  var deprecatedInterceptorWarned = false;
  var kClosedResolve$1 = Symbol("kClosedResolve");
  function getPipelining(e2) {
    return e2[kPipelining] ?? e2[kHTTPContext]?.defaultPipelining ?? 1;
  }
  o2(getPipelining, "getPipelining");
  var Client$3 = (be = class extends DispatcherBase$3 {
    constructor(A, { interceptors: t2, maxHeaderSize: n, headersTimeout: r, socketTimeout: s2, requestTimeout: i2, connectTimeout: E, bodyTimeout: Q, idleTimeout: C, keepAlive: I, keepAliveTimeout: a2, maxKeepAliveTimeout: f, keepAliveMaxTimeout: h2, keepAliveTimeoutThreshold: L, socketPath: c, pipelining: l2, tls: S, strictContentLength: k, maxCachedSessions: w, maxRedirections: U, connect: M, maxRequestsPerClient: B, localAddress: D, maxResponseSize: G, autoSelectFamily: g, autoSelectFamilyAttemptTimeout: d, maxConcurrentStreams: F, allowH2: N } = {}) {
      if (super(), I !== undefined)
        throw new InvalidArgumentError$e("unsupported keepAlive, use pipelining=0 instead");
      if (s2 !== undefined)
        throw new InvalidArgumentError$e("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      if (i2 !== undefined)
        throw new InvalidArgumentError$e("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      if (C !== undefined)
        throw new InvalidArgumentError$e("unsupported idleTimeout, use keepAliveTimeout instead");
      if (f !== undefined)
        throw new InvalidArgumentError$e("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      if (n != null && !Number.isFinite(n))
        throw new InvalidArgumentError$e("invalid maxHeaderSize");
      if (c != null && typeof c != "string")
        throw new InvalidArgumentError$e("invalid socketPath");
      if (E != null && (!Number.isFinite(E) || E < 0))
        throw new InvalidArgumentError$e("invalid connectTimeout");
      if (a2 != null && (!Number.isFinite(a2) || a2 <= 0))
        throw new InvalidArgumentError$e("invalid keepAliveTimeout");
      if (h2 != null && (!Number.isFinite(h2) || h2 <= 0))
        throw new InvalidArgumentError$e("invalid keepAliveMaxTimeout");
      if (L != null && !Number.isFinite(L))
        throw new InvalidArgumentError$e("invalid keepAliveTimeoutThreshold");
      if (r != null && (!Number.isInteger(r) || r < 0))
        throw new InvalidArgumentError$e("headersTimeout must be a positive integer or zero");
      if (Q != null && (!Number.isInteger(Q) || Q < 0))
        throw new InvalidArgumentError$e("bodyTimeout must be a positive integer or zero");
      if (M != null && typeof M != "function" && typeof M != "object")
        throw new InvalidArgumentError$e("connect must be a function or an object");
      if (U != null && (!Number.isInteger(U) || U < 0))
        throw new InvalidArgumentError$e("maxRedirections must be a positive number");
      if (B != null && (!Number.isInteger(B) || B < 0))
        throw new InvalidArgumentError$e("maxRequestsPerClient must be a positive number");
      if (D != null && (typeof D != "string" || net.isIP(D) === 0))
        throw new InvalidArgumentError$e("localAddress must be valid string IP address");
      if (G != null && (!Number.isInteger(G) || G < -1))
        throw new InvalidArgumentError$e("maxResponseSize must be a positive number");
      if (d != null && (!Number.isInteger(d) || d < -1))
        throw new InvalidArgumentError$e("autoSelectFamilyAttemptTimeout must be a positive number");
      if (N != null && typeof N != "boolean")
        throw new InvalidArgumentError$e("allowH2 must be a valid boolean value");
      if (F != null && (typeof F != "number" || F < 1))
        throw new InvalidArgumentError$e("maxConcurrentStreams must be a positive integer, greater than 0");
      typeof M != "function" && (M = buildConnector$2({ ...S, maxCachedSessions: w, allowH2: N, socketPath: c, timeout: E, ...util$f.nodeHasAutoSelectFamily && g ? { autoSelectFamily: g, autoSelectFamilyAttemptTimeout: d } : undefined, ...M })), t2?.Client && Array.isArray(t2.Client) ? (this[kInterceptors$3] = t2.Client, deprecatedInterceptorWarned || (deprecatedInterceptorWarned = true, process.emitWarning("Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.", { code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED" }))) : this[kInterceptors$3] = [createRedirectInterceptor$1({ maxRedirections: U })], this[kUrl$2] = util$f.parseOrigin(A), this[kConnector] = M, this[kPipelining] = l2 ?? 1, this[kMaxHeadersSize] = n || http.maxHeaderSize, this[kKeepAliveDefaultTimeout] = a2 ?? 4000, this[kKeepAliveMaxTimeout] = h2 ?? 600000, this[kKeepAliveTimeoutThreshold] = L ?? 1000, this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout], this[kServerName] = null, this[kLocalAddress] = D ?? null, this[kResuming] = 0, this[kNeedDrain$2] = 0, this[kHostHeader] = `host: ${this[kUrl$2].hostname}${this[kUrl$2].port ? `:${this[kUrl$2].port}` : ""}\r
`, this[kBodyTimeout] = Q ?? 300000, this[kHeadersTimeout] = r ?? 300000, this[kStrictContentLength] = k ?? true, this[kMaxRedirections$1] = U, this[kMaxRequests] = B, this[kClosedResolve$1] = null, this[kMaxResponseSize] = G > -1 ? G : -1, this[kMaxConcurrentStreams] = F ?? 100, this[kHTTPContext] = null, this[kQueue$1] = [], this[kRunningIdx] = 0, this[kPendingIdx] = 0, this[kResume$1] = (u) => resume(this, u), this[kOnError] = (u) => onError(this, u);
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(A) {
      this[kPipelining] = A, this[kResume$1](true);
    }
    get [kPending$2]() {
      return this[kQueue$1].length - this[kPendingIdx];
    }
    get [kRunning$3]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize$3]() {
      return this[kQueue$1].length - this[kRunningIdx];
    }
    get [kConnected$4]() {
      return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
    }
    get [kBusy$1]() {
      return !!(this[kHTTPContext]?.busy(null) || this[kSize$3] >= (getPipelining(this) || 1) || this[kPending$2] > 0);
    }
    [kConnect](A) {
      connect$1(this), this.once("connect", A);
    }
    [kDispatch$2](A, t2) {
      const n = A.origin || this[kUrl$2].origin, r = new Request2(n, A, t2);
      return this[kQueue$1].push(r), this[kResuming] || (util$f.bodyLength(r.body) == null && util$f.isIterable(r.body) ? (this[kResuming] = 1, queueMicrotask(() => resume(this))) : this[kResume$1](true)), this[kResuming] && this[kNeedDrain$2] !== 2 && this[kBusy$1] && (this[kNeedDrain$2] = 2), this[kNeedDrain$2] < 2;
    }
    async[kClose$5]() {
      return new Promise((A) => {
        this[kSize$3] ? this[kClosedResolve$1] = A : A(null);
      });
    }
    async[kDestroy$3](A) {
      return new Promise((t2) => {
        const n = this[kQueue$1].splice(this[kPendingIdx]);
        for (let s2 = 0;s2 < n.length; s2++) {
          const i2 = n[s2];
          util$f.errorRequest(this, i2, A);
        }
        const r = o2(() => {
          this[kClosedResolve$1] && (this[kClosedResolve$1](), this[kClosedResolve$1] = null), t2(null);
        }, "callback");
        this[kHTTPContext] ? (this[kHTTPContext].destroy(A, r), this[kHTTPContext] = null) : queueMicrotask(r), this[kResume$1]();
      });
    }
  }, o2(be, "Client"), be);
  var createRedirectInterceptor$1 = redirectInterceptor;
  function onError(e2, A) {
    if (e2[kRunning$3] === 0 && A.code !== "UND_ERR_INFO" && A.code !== "UND_ERR_SOCKET") {
      assert$7(e2[kPendingIdx] === e2[kRunningIdx]);
      const t2 = e2[kQueue$1].splice(e2[kRunningIdx]);
      for (let n = 0;n < t2.length; n++) {
        const r = t2[n];
        util$f.errorRequest(e2, r, A);
      }
      assert$7(e2[kSize$3] === 0);
    }
  }
  o2(onError, "onError");
  async function connect$1(e2) {
    assert$7(!e2[kConnecting]), assert$7(!e2[kHTTPContext]);
    let { host: A, hostname: t2, protocol: n, port: r } = e2[kUrl$2];
    if (t2[0] === "[") {
      const s2 = t2.indexOf("]");
      assert$7(s2 !== -1);
      const i2 = t2.substring(1, s2);
      assert$7(net.isIP(i2)), t2 = i2;
    }
    e2[kConnecting] = true, channels.beforeConnect.hasSubscribers && channels.beforeConnect.publish({ connectParams: { host: A, hostname: t2, protocol: n, port: r, version: e2[kHTTPContext]?.version, servername: e2[kServerName], localAddress: e2[kLocalAddress] }, connector: e2[kConnector] });
    try {
      const s2 = await new Promise((i2, E) => {
        e2[kConnector]({ host: A, hostname: t2, protocol: n, port: r, servername: e2[kServerName], localAddress: e2[kLocalAddress] }, (Q, C) => {
          Q ? E(Q) : i2(C);
        });
      });
      if (e2.destroyed) {
        util$f.destroy(s2.on("error", () => {}), new ClientDestroyedError);
        return;
      }
      assert$7(s2);
      try {
        e2[kHTTPContext] = s2.alpnProtocol === "h2" ? await connectH2(e2, s2) : await connectH1(e2, s2);
      } catch (i2) {
        throw s2.destroy().on("error", () => {}), i2;
      }
      e2[kConnecting] = false, s2[kCounter] = 0, s2[kMaxRequests] = e2[kMaxRequests], s2[kClient$1] = e2, s2[kError] = null, channels.connected.hasSubscribers && channels.connected.publish({ connectParams: { host: A, hostname: t2, protocol: n, port: r, version: e2[kHTTPContext]?.version, servername: e2[kServerName], localAddress: e2[kLocalAddress] }, connector: e2[kConnector], socket: s2 }), e2.emit("connect", e2[kUrl$2], [e2]);
    } catch (s2) {
      if (e2.destroyed)
        return;
      if (e2[kConnecting] = false, channels.connectError.hasSubscribers && channels.connectError.publish({ connectParams: { host: A, hostname: t2, protocol: n, port: r, version: e2[kHTTPContext]?.version, servername: e2[kServerName], localAddress: e2[kLocalAddress] }, connector: e2[kConnector], error: s2 }), s2.code === "ERR_TLS_CERT_ALTNAME_INVALID")
        for (assert$7(e2[kRunning$3] === 0);e2[kPending$2] > 0 && e2[kQueue$1][e2[kPendingIdx]].servername === e2[kServerName]; ) {
          const i2 = e2[kQueue$1][e2[kPendingIdx]++];
          util$f.errorRequest(e2, i2, s2);
        }
      else
        onError(e2, s2);
      e2.emit("connectionError", e2[kUrl$2], [e2], s2);
    }
    e2[kResume$1]();
  }
  o2(connect$1, "connect$1");
  function emitDrain(e2) {
    e2[kNeedDrain$2] = 0, e2.emit("drain", e2[kUrl$2], [e2]);
  }
  o2(emitDrain, "emitDrain");
  function resume(e2, A) {
    e2[kResuming] !== 2 && (e2[kResuming] = 2, _resume(e2, A), e2[kResuming] = 0, e2[kRunningIdx] > 256 && (e2[kQueue$1].splice(0, e2[kRunningIdx]), e2[kPendingIdx] -= e2[kRunningIdx], e2[kRunningIdx] = 0));
  }
  o2(resume, "resume");
  function _resume(e2, A) {
    for (;; ) {
      if (e2.destroyed) {
        assert$7(e2[kPending$2] === 0);
        return;
      }
      if (e2[kClosedResolve$1] && !e2[kSize$3]) {
        e2[kClosedResolve$1](), e2[kClosedResolve$1] = null;
        return;
      }
      if (e2[kHTTPContext] && e2[kHTTPContext].resume(), e2[kBusy$1])
        e2[kNeedDrain$2] = 2;
      else if (e2[kNeedDrain$2] === 2) {
        A ? (e2[kNeedDrain$2] = 1, queueMicrotask(() => emitDrain(e2))) : emitDrain(e2);
        continue;
      }
      if (e2[kPending$2] === 0 || e2[kRunning$3] >= (getPipelining(e2) || 1))
        return;
      const t2 = e2[kQueue$1][e2[kPendingIdx]];
      if (e2[kUrl$2].protocol === "https:" && e2[kServerName] !== t2.servername) {
        if (e2[kRunning$3] > 0)
          return;
        e2[kServerName] = t2.servername, e2[kHTTPContext]?.destroy(new InformationalError("servername changed"), () => {
          e2[kHTTPContext] = null, resume(e2);
        });
      }
      if (e2[kConnecting])
        return;
      if (!e2[kHTTPContext]) {
        connect$1(e2);
        return;
      }
      if (e2[kHTTPContext].destroyed || e2[kHTTPContext].busy(t2))
        return;
      !t2.aborted && e2[kHTTPContext].write(t2) ? e2[kPendingIdx]++ : e2[kQueue$1].splice(e2[kPendingIdx], 1);
    }
  }
  o2(_resume, "_resume");
  var client = Client$3;
  var kSize$2 = 2048;
  var kMask = kSize$2 - 1;
  var Qt = class Qt2 {
    constructor() {
      this.bottom = 0, this.top = 0, this.list = new Array(kSize$2), this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(A) {
      this.list[this.top] = A, this.top = this.top + 1 & kMask;
    }
    shift() {
      const A = this.list[this.bottom];
      return A === undefined ? null : (this.list[this.bottom] = undefined, this.bottom = this.bottom + 1 & kMask, A);
    }
  };
  o2(Qt, "FixedCircularBuffer");
  var FixedCircularBuffer = Qt;
  var fixedQueue = (me = class {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(A) {
      this.head.isFull() && (this.head = this.head.next = new FixedCircularBuffer), this.head.push(A);
    }
    shift() {
      const A = this.tail, t2 = A.shift();
      return A.isEmpty() && A.next !== null && (this.tail = A.next), t2;
    }
  }, o2(me, "FixedQueue"), me);
  var { kFree: kFree$1, kConnected: kConnected$3, kPending: kPending$1, kQueued: kQueued$1, kRunning: kRunning$2, kSize: kSize$1 } = symbols$4;
  var kPool = Symbol("pool");
  var PoolStats$1 = (Le = class {
    constructor(A) {
      this[kPool] = A;
    }
    get connected() {
      return this[kPool][kConnected$3];
    }
    get free() {
      return this[kPool][kFree$1];
    }
    get pending() {
      return this[kPool][kPending$1];
    }
    get queued() {
      return this[kPool][kQueued$1];
    }
    get running() {
      return this[kPool][kRunning$2];
    }
    get size() {
      return this[kPool][kSize$1];
    }
  }, o2(Le, "PoolStats"), Le);
  var poolStats = PoolStats$1;
  var DispatcherBase$2 = dispatcherBase;
  var FixedQueue = fixedQueue;
  var { kConnected: kConnected$2, kSize, kRunning: kRunning$1, kPending, kQueued, kBusy, kFree, kUrl: kUrl$1, kClose: kClose$4, kDestroy: kDestroy$2, kDispatch: kDispatch$1 } = symbols$4;
  var PoolStats = poolStats;
  var kClients$2 = Symbol("clients");
  var kNeedDrain$1 = Symbol("needDrain");
  var kQueue = Symbol("queue");
  var kClosedResolve = Symbol("closed resolve");
  var kOnDrain$1 = Symbol("onDrain");
  var kOnConnect$1 = Symbol("onConnect");
  var kOnDisconnect$1 = Symbol("onDisconnect");
  var kOnConnectionError$1 = Symbol("onConnectionError");
  var kGetDispatcher$1 = Symbol("get dispatcher");
  var kAddClient$1 = Symbol("add client");
  var kRemoveClient = Symbol("remove client");
  var kStats = Symbol("stats");
  var PoolBase$1 = (Me = class extends DispatcherBase$2 {
    constructor() {
      super(), this[kQueue] = new FixedQueue, this[kClients$2] = [], this[kQueued] = 0;
      const A = this;
      this[kOnDrain$1] = o2(function(n, r) {
        const s2 = A[kQueue];
        let i2 = false;
        for (;!i2; ) {
          const E = s2.shift();
          if (!E)
            break;
          A[kQueued]--, i2 = !this.dispatch(E.opts, E.handler);
        }
        this[kNeedDrain$1] = i2, !this[kNeedDrain$1] && A[kNeedDrain$1] && (A[kNeedDrain$1] = false, A.emit("drain", n, [A, ...r])), A[kClosedResolve] && s2.isEmpty() && Promise.all(A[kClients$2].map((E) => E.close())).then(A[kClosedResolve]);
      }, "onDrain"), this[kOnConnect$1] = (t2, n) => {
        A.emit("connect", t2, [A, ...n]);
      }, this[kOnDisconnect$1] = (t2, n, r) => {
        A.emit("disconnect", t2, [A, ...n], r);
      }, this[kOnConnectionError$1] = (t2, n, r) => {
        A.emit("connectionError", t2, [A, ...n], r);
      }, this[kStats] = new PoolStats(this);
    }
    get [kBusy]() {
      return this[kNeedDrain$1];
    }
    get [kConnected$2]() {
      return this[kClients$2].filter((A) => A[kConnected$2]).length;
    }
    get [kFree]() {
      return this[kClients$2].filter((A) => A[kConnected$2] && !A[kNeedDrain$1]).length;
    }
    get [kPending]() {
      let A = this[kQueued];
      for (const { [kPending]: t2 } of this[kClients$2])
        A += t2;
      return A;
    }
    get [kRunning$1]() {
      let A = 0;
      for (const { [kRunning$1]: t2 } of this[kClients$2])
        A += t2;
      return A;
    }
    get [kSize]() {
      let A = this[kQueued];
      for (const { [kSize]: t2 } of this[kClients$2])
        A += t2;
      return A;
    }
    get stats() {
      return this[kStats];
    }
    async[kClose$4]() {
      return this[kQueue].isEmpty() ? Promise.all(this[kClients$2].map((A) => A.close())) : new Promise((A) => {
        this[kClosedResolve] = A;
      });
    }
    async[kDestroy$2](A) {
      for (;; ) {
        const t2 = this[kQueue].shift();
        if (!t2)
          break;
        t2.handler.onError(A);
      }
      return Promise.all(this[kClients$2].map((t2) => t2.destroy(A)));
    }
    [kDispatch$1](A, t2) {
      const n = this[kGetDispatcher$1]();
      return n ? n.dispatch(A, t2) || (n[kNeedDrain$1] = true, this[kNeedDrain$1] = !this[kGetDispatcher$1]()) : (this[kNeedDrain$1] = true, this[kQueue].push({ opts: A, handler: t2 }), this[kQueued]++), !this[kNeedDrain$1];
    }
    [kAddClient$1](A) {
      return A.on("drain", this[kOnDrain$1]).on("connect", this[kOnConnect$1]).on("disconnect", this[kOnDisconnect$1]).on("connectionError", this[kOnConnectionError$1]), this[kClients$2].push(A), this[kNeedDrain$1] && queueMicrotask(() => {
        this[kNeedDrain$1] && this[kOnDrain$1](A[kUrl$1], [this, A]);
      }), this;
    }
    [kRemoveClient](A) {
      A.close(() => {
        const t2 = this[kClients$2].indexOf(A);
        t2 !== -1 && this[kClients$2].splice(t2, 1);
      }), this[kNeedDrain$1] = this[kClients$2].some((t2) => !t2[kNeedDrain$1] && t2.closed !== true && t2.destroyed !== true);
    }
  }, o2(Me, "PoolBase"), Me);
  var poolBase = { PoolBase: PoolBase$1, kClients: kClients$2, kNeedDrain: kNeedDrain$1, kAddClient: kAddClient$1, kRemoveClient, kGetDispatcher: kGetDispatcher$1 };
  var { PoolBase, kClients: kClients$1, kNeedDrain, kAddClient, kGetDispatcher } = poolBase;
  var Client$2 = client;
  var { InvalidArgumentError: InvalidArgumentError$d } = errors$1;
  var util$e = util$m;
  var { kUrl, kInterceptors: kInterceptors$2 } = symbols$4;
  var buildConnector$1 = connect$2;
  var kOptions$1 = Symbol("options");
  var kConnections = Symbol("connections");
  var kFactory$1 = Symbol("factory");
  function defaultFactory$2(e2, A) {
    return new Client$2(e2, A);
  }
  o2(defaultFactory$2, "defaultFactory$2");
  var Pool$3 = (Ye = class extends PoolBase {
    constructor(A, { connections: t2, factory: n = defaultFactory$2, connect: r, connectTimeout: s2, tls: i2, maxCachedSessions: E, socketPath: Q, autoSelectFamily: C, autoSelectFamilyAttemptTimeout: I, allowH2: a2, ...f } = {}) {
      if (super(), t2 != null && (!Number.isFinite(t2) || t2 < 0))
        throw new InvalidArgumentError$d("invalid connections");
      if (typeof n != "function")
        throw new InvalidArgumentError$d("factory must be a function.");
      if (r != null && typeof r != "function" && typeof r != "object")
        throw new InvalidArgumentError$d("connect must be a function or an object");
      typeof r != "function" && (r = buildConnector$1({ ...i2, maxCachedSessions: E, allowH2: a2, socketPath: Q, timeout: s2, ...util$e.nodeHasAutoSelectFamily && C ? { autoSelectFamily: C, autoSelectFamilyAttemptTimeout: I } : undefined, ...r })), this[kInterceptors$2] = f.interceptors?.Pool && Array.isArray(f.interceptors.Pool) ? f.interceptors.Pool : [], this[kConnections] = t2 || null, this[kUrl] = util$e.parseOrigin(A), this[kOptions$1] = { ...util$e.deepClone(f), connect: r, allowH2: a2 }, this[kOptions$1].interceptors = f.interceptors ? { ...f.interceptors } : undefined, this[kFactory$1] = n;
    }
    [kGetDispatcher]() {
      for (const A of this[kClients$1])
        if (!A[kNeedDrain])
          return A;
      if (!this[kConnections] || this[kClients$1].length < this[kConnections]) {
        const A = this[kFactory$1](this[kUrl], this[kOptions$1]);
        return this[kAddClient](A), A;
      }
    }
  }, o2(Ye, "Pool"), Ye);
  var pool = Pool$3;
  var { InvalidArgumentError: InvalidArgumentError$c } = errors$1;
  var { kClients, kRunning, kClose: kClose$3, kDestroy: kDestroy$1, kDispatch, kInterceptors: kInterceptors$1 } = symbols$4;
  var DispatcherBase$1 = dispatcherBase;
  var Pool$2 = pool;
  var Client$1 = client;
  var util$d = util$m;
  var createRedirectInterceptor = redirectInterceptor;
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kMaxRedirections = Symbol("maxRedirections");
  var kOnDrain = Symbol("onDrain");
  var kFactory = Symbol("factory");
  var kOptions = Symbol("options");
  function defaultFactory$1(e2, A) {
    return A && A.connections === 1 ? new Client$1(e2, A) : new Pool$2(e2, A);
  }
  o2(defaultFactory$1, "defaultFactory$1");
  var Agent$3 = (Je = class extends DispatcherBase$1 {
    constructor({ factory: A = defaultFactory$1, maxRedirections: t2 = 0, connect: n, ...r } = {}) {
      if (super(), typeof A != "function")
        throw new InvalidArgumentError$c("factory must be a function.");
      if (n != null && typeof n != "function" && typeof n != "object")
        throw new InvalidArgumentError$c("connect must be a function or an object");
      if (!Number.isInteger(t2) || t2 < 0)
        throw new InvalidArgumentError$c("maxRedirections must be a positive number");
      n && typeof n != "function" && (n = { ...n }), this[kInterceptors$1] = r.interceptors?.Agent && Array.isArray(r.interceptors.Agent) ? r.interceptors.Agent : [createRedirectInterceptor({ maxRedirections: t2 })], this[kOptions] = { ...util$d.deepClone(r), connect: n }, this[kOptions].interceptors = r.interceptors ? { ...r.interceptors } : undefined, this[kMaxRedirections] = t2, this[kFactory] = A, this[kClients] = new Map, this[kOnDrain] = (s2, i2) => {
        this.emit("drain", s2, [this, ...i2]);
      }, this[kOnConnect] = (s2, i2) => {
        this.emit("connect", s2, [this, ...i2]);
      }, this[kOnDisconnect] = (s2, i2, E) => {
        this.emit("disconnect", s2, [this, ...i2], E);
      }, this[kOnConnectionError] = (s2, i2, E) => {
        this.emit("connectionError", s2, [this, ...i2], E);
      };
    }
    get [kRunning]() {
      let A = 0;
      for (const t2 of this[kClients].values())
        A += t2[kRunning];
      return A;
    }
    [kDispatch](A, t2) {
      let n;
      if (A.origin && (typeof A.origin == "string" || A.origin instanceof URL))
        n = String(A.origin);
      else
        throw new InvalidArgumentError$c("opts.origin must be a non-empty string or URL.");
      let r = this[kClients].get(n);
      return r || (r = this[kFactory](A.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]), this[kClients].set(n, r)), r.dispatch(A, t2);
    }
    async[kClose$3]() {
      const A = [];
      for (const t2 of this[kClients].values())
        A.push(t2.close());
      this[kClients].clear(), await Promise.all(A);
    }
    async[kDestroy$1](A) {
      const t2 = [];
      for (const n of this[kClients].values())
        t2.push(n.destroy(A));
      this[kClients].clear(), await Promise.all(t2);
    }
  }, o2(Je, "Agent"), Je);
  var agent = Agent$3;
  var { kProxy, kClose: kClose$2, kDestroy, kInterceptors } = symbols$4;
  var { URL: URL$1 } = require$$1__default;
  var Agent$2 = agent;
  var Pool$1 = pool;
  var DispatcherBase = dispatcherBase;
  var { InvalidArgumentError: InvalidArgumentError$b, RequestAbortedError: RequestAbortedError$3, SecureProxyConnectionError } = errors$1;
  var buildConnector = connect$2;
  var kAgent = Symbol("proxy agent");
  var kClient = Symbol("proxy client");
  var kProxyHeaders = Symbol("proxy headers");
  var kRequestTls = Symbol("request tls settings");
  var kProxyTls = Symbol("proxy tls settings");
  var kConnectEndpoint = Symbol("connect endpoint function");
  function defaultProtocolPort(e2) {
    return e2 === "https:" ? 443 : 80;
  }
  o2(defaultProtocolPort, "defaultProtocolPort");
  function defaultFactory(e2, A) {
    return new Pool$1(e2, A);
  }
  o2(defaultFactory, "defaultFactory");
  var ProxyAgent$1 = (Ge = class extends DispatcherBase {
    constructor(t2) {
      super();
      CA(this, Oe);
      if (!t2 || typeof t2 == "object" && !(t2 instanceof URL$1) && !t2.uri)
        throw new InvalidArgumentError$b("Proxy uri is mandatory");
      const { clientFactory: n = defaultFactory } = t2;
      if (typeof n != "function")
        throw new InvalidArgumentError$b("Proxy opts.clientFactory must be a function.");
      const r = kA(this, Oe, Rt).call(this, t2), { href: s2, origin: i2, port: E, protocol: Q, username: C, password: I, hostname: a2 } = r;
      if (this[kProxy] = { uri: s2, protocol: Q }, this[kInterceptors] = t2.interceptors?.ProxyAgent && Array.isArray(t2.interceptors.ProxyAgent) ? t2.interceptors.ProxyAgent : [], this[kRequestTls] = t2.requestTls, this[kProxyTls] = t2.proxyTls, this[kProxyHeaders] = t2.headers || {}, t2.auth && t2.token)
        throw new InvalidArgumentError$b("opts.auth cannot be used in combination with opts.token");
      t2.auth ? this[kProxyHeaders]["proxy-authorization"] = `Basic ${t2.auth}` : t2.token ? this[kProxyHeaders]["proxy-authorization"] = t2.token : C && I && (this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(C)}:${decodeURIComponent(I)}`).toString("base64")}`);
      const f = buildConnector({ ...t2.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...t2.requestTls }), this[kClient] = n(r, { connect: f }), this[kAgent] = new Agent$2({ ...t2, connect: async (h2, L) => {
        let c = h2.host;
        h2.port || (c += `:${defaultProtocolPort(h2.protocol)}`);
        try {
          const { socket: l2, statusCode: S } = await this[kClient].connect({ origin: i2, port: E, path: c, signal: h2.signal, headers: { ...this[kProxyHeaders], host: h2.host }, servername: this[kProxyTls]?.servername || a2 });
          if (S !== 200 && (l2.on("error", () => {}).destroy(), L(new RequestAbortedError$3(`Proxy response (${S}) !== 200 when HTTP Tunneling`))), h2.protocol !== "https:") {
            L(null, l2);
            return;
          }
          let k;
          this[kRequestTls] ? k = this[kRequestTls].servername : k = h2.servername, this[kConnectEndpoint]({ ...h2, servername: k, httpSocket: l2 }, L);
        } catch (l2) {
          l2.code === "ERR_TLS_CERT_ALTNAME_INVALID" ? L(new SecureProxyConnectionError(l2)) : L(l2);
        }
      } });
    }
    dispatch(t2, n) {
      const r = buildHeaders(t2.headers);
      if (throwIfProxyAuthIsSent(r), r && !("host" in r) && !("Host" in r)) {
        const { host: s2 } = new URL$1(t2.origin);
        r.host = s2;
      }
      return this[kAgent].dispatch({ ...t2, headers: r }, n);
    }
    async[kClose$2]() {
      await this[kAgent].close(), await this[kClient].close();
    }
    async[kDestroy]() {
      await this[kAgent].destroy(), await this[kClient].destroy();
    }
  }, Oe = new WeakSet, Rt = o2(function(t2) {
    return typeof t2 == "string" ? new URL$1(t2) : t2 instanceof URL$1 ? t2 : new URL$1(t2.uri);
  }, "#getUrl"), o2(Ge, "ProxyAgent"), Ge);
  function buildHeaders(e2) {
    if (Array.isArray(e2)) {
      const A = {};
      for (let t2 = 0;t2 < e2.length; t2 += 2)
        A[e2[t2]] = e2[t2 + 1];
      return A;
    }
    return e2;
  }
  o2(buildHeaders, "buildHeaders");
  function throwIfProxyAuthIsSent(e2) {
    if (e2 && Object.keys(e2).find((t2) => t2.toLowerCase() === "proxy-authorization"))
      throw new InvalidArgumentError$b("Proxy-Authorization should be sent in ProxyAgent constructor");
  }
  o2(throwIfProxyAuthIsSent, "throwIfProxyAuthIsSent");
  var proxyAgent = ProxyAgent$1;
  var api$1 = {};
  var apiRequest = { exports: {} };
  var assert$6 = require$$0__default;
  var { Readable: Readable$2 } = Stream__default;
  var { RequestAbortedError: RequestAbortedError$2, NotSupportedError, InvalidArgumentError: InvalidArgumentError$a, AbortError } = errors$1;
  var util$c = util$m;
  var { ReadableStreamFrom } = util$m;
  var kConsume = Symbol("kConsume");
  var kReading = Symbol("kReading");
  var kBody = Symbol("kBody");
  var kAbort = Symbol("kAbort");
  var kContentType = Symbol("kContentType");
  var kContentLength$1 = Symbol("kContentLength");
  var noop = o2(() => {}, "noop");
  var Et = class Et2 extends Readable$2 {
    constructor({ resume: A, abort: t2, contentType: n = "", contentLength: r, highWaterMark: s2 = 64 * 1024 }) {
      super({ autoDestroy: true, read: A, highWaterMark: s2 }), this._readableState.dataEmitted = false, this[kAbort] = t2, this[kConsume] = null, this[kBody] = null, this[kContentType] = n, this[kContentLength$1] = r, this[kReading] = false;
    }
    destroy(A) {
      return !A && !this._readableState.endEmitted && (A = new RequestAbortedError$2), A && this[kAbort](), super.destroy(A);
    }
    _destroy(A, t2) {
      queueMicrotask(() => {
        t2(A);
      });
    }
    on(A, ...t2) {
      return (A === "data" || A === "readable") && (this[kReading] = true), super.on(A, ...t2);
    }
    addListener(A, ...t2) {
      return this.on(A, ...t2);
    }
    off(A, ...t2) {
      const n = super.off(A, ...t2);
      return (A === "data" || A === "readable") && (this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0), n;
    }
    removeListener(A, ...t2) {
      return this.off(A, ...t2);
    }
    push(A) {
      return this[kConsume] && A !== null ? (consumePush(this[kConsume], A), this[kReading] ? super.push(A) : true) : super.push(A);
    }
    async text() {
      return consume(this, "text");
    }
    async json() {
      return consume(this, "json");
    }
    async blob() {
      return consume(this, "blob");
    }
    async arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    async formData() {
      throw new NotSupportedError;
    }
    get bodyUsed() {
      return util$c.isDisturbed(this);
    }
    get body() {
      return this[kBody] || (this[kBody] = ReadableStreamFrom(this), this[kConsume] && (this[kBody].getReader(), assert$6(this[kBody].locked))), this[kBody];
    }
    async dump(A) {
      let t2 = Number.isFinite(A?.limit) ? A.limit : 131072;
      const n = A?.signal;
      if (n != null && (typeof n != "object" || !("aborted" in n)))
        throw new InvalidArgumentError$a("signal must be an AbortSignal");
      return n?.throwIfAborted(), this._readableState.closeEmitted ? null : await new Promise((r, s2) => {
        this[kContentLength$1] > t2 && this.destroy(new AbortError);
        const i2 = o2(() => {
          this.destroy(n.reason ?? new AbortError);
        }, "onAbort");
        n?.addEventListener("abort", i2), this.on("close", function() {
          n?.removeEventListener("abort", i2), n?.aborted ? s2(n.reason ?? new AbortError) : r(null);
        }).on("error", noop).on("data", function(E) {
          t2 -= E.length, t2 <= 0 && this.destroy();
        }).resume();
      });
    }
  };
  o2(Et, "BodyReadable");
  var BodyReadable = Et;
  function isLocked(e2) {
    return e2[kBody] && e2[kBody].locked === true || e2[kConsume];
  }
  o2(isLocked, "isLocked");
  function isUnusable(e2) {
    return util$c.isDisturbed(e2) || isLocked(e2);
  }
  o2(isUnusable, "isUnusable");
  async function consume(e2, A) {
    return assert$6(!e2[kConsume]), new Promise((t2, n) => {
      if (isUnusable(e2)) {
        const r = e2._readableState;
        r.destroyed && r.closeEmitted === false ? e2.on("error", (s2) => {
          n(s2);
        }).on("close", () => {
          n(new TypeError("unusable"));
        }) : n(r.errored ?? new TypeError("unusable"));
      } else
        queueMicrotask(() => {
          e2[kConsume] = { type: A, stream: e2, resolve: t2, reject: n, length: 0, body: [] }, e2.on("error", function(r) {
            consumeFinish(this[kConsume], r);
          }).on("close", function() {
            this[kConsume].body !== null && consumeFinish(this[kConsume], new RequestAbortedError$2);
          }), consumeStart(e2[kConsume]);
        });
    });
  }
  o2(consume, "consume");
  function consumeStart(e2) {
    if (e2.body === null)
      return;
    const { _readableState: A } = e2.stream;
    if (A.bufferIndex) {
      const t2 = A.bufferIndex, n = A.buffer.length;
      for (let r = t2;r < n; r++)
        consumePush(e2, A.buffer[r]);
    } else
      for (const t2 of A.buffer)
        consumePush(e2, t2);
    for (A.endEmitted ? consumeEnd(this[kConsume]) : e2.stream.on("end", function() {
      consumeEnd(this[kConsume]);
    }), e2.stream.resume();e2.stream.read() != null; )
      ;
  }
  o2(consumeStart, "consumeStart");
  function chunksDecode$1(e2, A) {
    if (e2.length === 0 || A === 0)
      return "";
    const t2 = e2.length === 1 ? e2[0] : Buffer.concat(e2, A), n = t2.length, r = n > 2 && t2[0] === 239 && t2[1] === 187 && t2[2] === 191 ? 3 : 0;
    return t2.utf8Slice(r, n);
  }
  o2(chunksDecode$1, "chunksDecode$1");
  function consumeEnd(e2) {
    const { type: A, body: t2, resolve: n, stream: r, length: s2 } = e2;
    try {
      if (A === "text")
        n(chunksDecode$1(t2, s2));
      else if (A === "json")
        n(JSON.parse(chunksDecode$1(t2, s2)));
      else if (A === "arrayBuffer") {
        const i2 = new Uint8Array(s2);
        let E = 0;
        for (const Q of t2)
          i2.set(Q, E), E += Q.byteLength;
        n(i2.buffer);
      } else
        A === "blob" && n(new Blob(t2, { type: r[kContentType] }));
      consumeFinish(e2);
    } catch (i2) {
      r.destroy(i2);
    }
  }
  o2(consumeEnd, "consumeEnd");
  function consumePush(e2, A) {
    e2.length += A.length, e2.body.push(A);
  }
  o2(consumePush, "consumePush");
  function consumeFinish(e2, A) {
    e2.body !== null && (A ? e2.reject(A) : e2.resolve(), e2.type = null, e2.stream = null, e2.resolve = null, e2.reject = null, e2.length = 0, e2.body = null);
  }
  o2(consumeFinish, "consumeFinish");
  var readable = { Readable: BodyReadable, chunksDecode: chunksDecode$1 };
  var assert$5 = require$$0__default;
  var { ResponseStatusCodeError } = errors$1;
  var { chunksDecode } = readable;
  var CHUNK_LIMIT = 128 * 1024;
  async function getResolveErrorBodyCallback$2({ callback: e2, body: A, contentType: t2, statusCode: n, statusMessage: r, headers: s2 }) {
    assert$5(A);
    let i2 = [], E = 0;
    for await (const a2 of A)
      if (i2.push(a2), E += a2.length, E > CHUNK_LIMIT) {
        i2 = null;
        break;
      }
    const Q = `Response status code ${n}${r ? `: ${r}` : ""}`;
    if (n === 204 || !t2 || !i2) {
      queueMicrotask(() => e2(new ResponseStatusCodeError(Q, n, s2)));
      return;
    }
    const C = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    let I;
    try {
      isContentTypeApplicationJson(t2) ? I = JSON.parse(chunksDecode(i2, E)) : isContentTypeText(t2) && (I = chunksDecode(i2, E));
    } catch {} finally {
      Error.stackTraceLimit = C;
    }
    queueMicrotask(() => e2(new ResponseStatusCodeError(Q, n, s2, I)));
  }
  o2(getResolveErrorBodyCallback$2, "getResolveErrorBodyCallback$2");
  var isContentTypeApplicationJson = o2((e2) => e2.length > 15 && e2[11] === "/" && e2[0] === "a" && e2[1] === "p" && e2[2] === "p" && e2[3] === "l" && e2[4] === "i" && e2[5] === "c" && e2[6] === "a" && e2[7] === "t" && e2[8] === "i" && e2[9] === "o" && e2[10] === "n" && e2[12] === "j" && e2[13] === "s" && e2[14] === "o" && e2[15] === "n", "isContentTypeApplicationJson");
  var isContentTypeText = o2((e2) => e2.length > 4 && e2[4] === "/" && e2[0] === "t" && e2[1] === "e" && e2[2] === "x" && e2[3] === "t", "isContentTypeText");
  var util$b = { getResolveErrorBodyCallback: getResolveErrorBodyCallback$2, isContentTypeApplicationJson, isContentTypeText };
  var { addAbortListener } = util$m;
  var { RequestAbortedError: RequestAbortedError$1 } = errors$1;
  var kListener = Symbol("kListener");
  var kSignal = Symbol("kSignal");
  function abort(e2) {
    e2.abort ? e2.abort(e2[kSignal]?.reason) : e2.reason = e2[kSignal]?.reason ?? new RequestAbortedError$1, removeSignal$5(e2);
  }
  o2(abort, "abort");
  function addSignal$5(e2, A) {
    if (e2.reason = null, e2[kSignal] = null, e2[kListener] = null, !!A) {
      if (A.aborted) {
        abort(e2);
        return;
      }
      e2[kSignal] = A, e2[kListener] = () => {
        abort(e2);
      }, addAbortListener(e2[kSignal], e2[kListener]);
    }
  }
  o2(addSignal$5, "addSignal$5");
  function removeSignal$5(e2) {
    e2[kSignal] && (("removeEventListener" in e2[kSignal]) ? e2[kSignal].removeEventListener("abort", e2[kListener]) : e2[kSignal].removeListener("abort", e2[kListener]), e2[kSignal] = null, e2[kListener] = null);
  }
  o2(removeSignal$5, "removeSignal$5");
  var abortSignal = { addSignal: addSignal$5, removeSignal: removeSignal$5 };
  var assert$4 = require$$0__default;
  var { Readable: Readable$1 } = readable;
  var { InvalidArgumentError: InvalidArgumentError$9 } = errors$1;
  var util$a = util$m;
  var { getResolveErrorBodyCallback: getResolveErrorBodyCallback$1 } = util$b;
  var { AsyncResource: AsyncResource$4 } = require$$5__default$1;
  var { addSignal: addSignal$4, removeSignal: removeSignal$4 } = abortSignal;
  var gt = class gt2 extends AsyncResource$4 {
    constructor(A, t2) {
      if (!A || typeof A != "object")
        throw new InvalidArgumentError$9("invalid opts");
      const { signal: n, method: r, opaque: s2, body: i2, onInfo: E, responseHeaders: Q, throwOnError: C, highWaterMark: I } = A;
      try {
        if (typeof t2 != "function")
          throw new InvalidArgumentError$9("invalid callback");
        if (I && (typeof I != "number" || I < 0))
          throw new InvalidArgumentError$9("invalid highWaterMark");
        if (n && typeof n.on != "function" && typeof n.addEventListener != "function")
          throw new InvalidArgumentError$9("signal must be an EventEmitter or EventTarget");
        if (r === "CONNECT")
          throw new InvalidArgumentError$9("invalid method");
        if (E && typeof E != "function")
          throw new InvalidArgumentError$9("invalid onInfo callback");
        super("UNDICI_REQUEST");
      } catch (a2) {
        throw util$a.isStream(i2) && util$a.destroy(i2.on("error", util$a.nop), a2), a2;
      }
      this.responseHeaders = Q || null, this.opaque = s2 || null, this.callback = t2, this.res = null, this.abort = null, this.body = i2, this.trailers = {}, this.context = null, this.onInfo = E || null, this.throwOnError = C, this.highWaterMark = I, util$a.isStream(i2) && i2.on("error", (a2) => {
        this.onError(a2);
      }), addSignal$4(this, n);
    }
    onConnect(A, t2) {
      if (this.reason) {
        A(this.reason);
        return;
      }
      assert$4(this.callback), this.abort = A, this.context = t2;
    }
    onHeaders(A, t2, n, r) {
      const { callback: s2, opaque: i2, abort: E, context: Q, responseHeaders: C, highWaterMark: I } = this, a2 = C === "raw" ? util$a.parseRawHeaders(t2) : util$a.parseHeaders(t2);
      if (A < 200) {
        this.onInfo && this.onInfo({ statusCode: A, headers: a2 });
        return;
      }
      const f = C === "raw" ? util$a.parseHeaders(t2) : a2, h2 = f["content-type"], L = f["content-length"], c = new Readable$1({ resume: n, abort: E, contentType: h2, contentLength: L, highWaterMark: I });
      this.callback = null, this.res = c, s2 !== null && (this.throwOnError && A >= 400 ? this.runInAsyncScope(getResolveErrorBodyCallback$1, null, { callback: s2, body: c, contentType: h2, statusCode: A, statusMessage: r, headers: a2 }) : this.runInAsyncScope(s2, null, null, { statusCode: A, headers: a2, trailers: this.trailers, opaque: i2, body: c, context: Q }));
    }
    onData(A) {
      const { res: t2 } = this;
      return t2.push(A);
    }
    onComplete(A) {
      const { res: t2 } = this;
      removeSignal$4(this), util$a.parseHeaders(A, this.trailers), t2.push(null);
    }
    onError(A) {
      const { res: t2, callback: n, body: r, opaque: s2 } = this;
      removeSignal$4(this), n && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(n, null, A, { opaque: s2 });
      })), t2 && (this.res = null, queueMicrotask(() => {
        util$a.destroy(t2, A);
      })), r && (this.body = null, util$a.destroy(r, A));
    }
  };
  o2(gt, "RequestHandler");
  var RequestHandler = gt;
  function request$1(e2, A) {
    if (A === undefined)
      return new Promise((t2, n) => {
        request$1.call(this, e2, (r, s2) => r ? n(r) : t2(s2));
      });
    try {
      this.dispatch(e2, new RequestHandler(e2, A));
    } catch (t2) {
      if (typeof A != "function")
        throw t2;
      const n = e2?.opaque;
      queueMicrotask(() => A(t2, { opaque: n }));
    }
  }
  o2(request$1, "request$1"), apiRequest.exports = request$1, apiRequest.exports.RequestHandler = RequestHandler;
  var apiRequestExports = apiRequest.exports;
  var assert$3 = require$$0__default;
  var { finished, PassThrough: PassThrough$1 } = Stream__default;
  var { InvalidArgumentError: InvalidArgumentError$8, InvalidReturnValueError: InvalidReturnValueError$1 } = errors$1;
  var util$9 = util$m;
  var { getResolveErrorBodyCallback } = util$b;
  var { AsyncResource: AsyncResource$3 } = require$$5__default$1;
  var { addSignal: addSignal$3, removeSignal: removeSignal$3 } = abortSignal;
  var Bt = class Bt2 extends AsyncResource$3 {
    constructor(A, t2, n) {
      if (!A || typeof A != "object")
        throw new InvalidArgumentError$8("invalid opts");
      const { signal: r, method: s2, opaque: i2, body: E, onInfo: Q, responseHeaders: C, throwOnError: I } = A;
      try {
        if (typeof n != "function")
          throw new InvalidArgumentError$8("invalid callback");
        if (typeof t2 != "function")
          throw new InvalidArgumentError$8("invalid factory");
        if (r && typeof r.on != "function" && typeof r.addEventListener != "function")
          throw new InvalidArgumentError$8("signal must be an EventEmitter or EventTarget");
        if (s2 === "CONNECT")
          throw new InvalidArgumentError$8("invalid method");
        if (Q && typeof Q != "function")
          throw new InvalidArgumentError$8("invalid onInfo callback");
        super("UNDICI_STREAM");
      } catch (a2) {
        throw util$9.isStream(E) && util$9.destroy(E.on("error", util$9.nop), a2), a2;
      }
      this.responseHeaders = C || null, this.opaque = i2 || null, this.factory = t2, this.callback = n, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = E, this.onInfo = Q || null, this.throwOnError = I || false, util$9.isStream(E) && E.on("error", (a2) => {
        this.onError(a2);
      }), addSignal$3(this, r);
    }
    onConnect(A, t2) {
      if (this.reason) {
        A(this.reason);
        return;
      }
      assert$3(this.callback), this.abort = A, this.context = t2;
    }
    onHeaders(A, t2, n, r) {
      const { factory: s2, opaque: i2, context: E, callback: Q, responseHeaders: C } = this, I = C === "raw" ? util$9.parseRawHeaders(t2) : util$9.parseHeaders(t2);
      if (A < 200) {
        this.onInfo && this.onInfo({ statusCode: A, headers: I });
        return;
      }
      this.factory = null;
      let a2;
      if (this.throwOnError && A >= 400) {
        const L = (C === "raw" ? util$9.parseHeaders(t2) : I)["content-type"];
        a2 = new PassThrough$1, this.callback = null, this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback: Q, body: a2, contentType: L, statusCode: A, statusMessage: r, headers: I });
      } else {
        if (s2 === null)
          return;
        if (a2 = this.runInAsyncScope(s2, null, { statusCode: A, headers: I, opaque: i2, context: E }), !a2 || typeof a2.write != "function" || typeof a2.end != "function" || typeof a2.on != "function")
          throw new InvalidReturnValueError$1("expected Writable");
        finished(a2, { readable: false }, (h2) => {
          const { callback: L, res: c, opaque: l2, trailers: S, abort: k } = this;
          this.res = null, (h2 || !c.readable) && util$9.destroy(c, h2), this.callback = null, this.runInAsyncScope(L, null, h2 || null, { opaque: l2, trailers: S }), h2 && k();
        });
      }
      return a2.on("drain", n), this.res = a2, (a2.writableNeedDrain !== undefined ? a2.writableNeedDrain : a2._writableState?.needDrain) !== true;
    }
    onData(A) {
      const { res: t2 } = this;
      return t2 ? t2.write(A) : true;
    }
    onComplete(A) {
      const { res: t2 } = this;
      removeSignal$3(this), t2 && (this.trailers = util$9.parseHeaders(A), t2.end());
    }
    onError(A) {
      const { res: t2, callback: n, opaque: r, body: s2 } = this;
      removeSignal$3(this), this.factory = null, t2 ? (this.res = null, util$9.destroy(t2, A)) : n && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(n, null, A, { opaque: r });
      })), s2 && (this.body = null, util$9.destroy(s2, A));
    }
  };
  o2(Bt, "StreamHandler");
  var StreamHandler = Bt;
  function stream(e2, A, t2) {
    if (t2 === undefined)
      return new Promise((n, r) => {
        stream.call(this, e2, A, (s2, i2) => s2 ? r(s2) : n(i2));
      });
    try {
      this.dispatch(e2, new StreamHandler(e2, A, t2));
    } catch (n) {
      if (typeof t2 != "function")
        throw n;
      const r = e2?.opaque;
      queueMicrotask(() => t2(n, { opaque: r }));
    }
  }
  o2(stream, "stream");
  var apiStream = stream;
  var { Readable, Duplex, PassThrough } = Stream__default;
  var { InvalidArgumentError: InvalidArgumentError$7, InvalidReturnValueError, RequestAbortedError } = errors$1;
  var util$8 = util$m;
  var { AsyncResource: AsyncResource$2 } = require$$5__default$1;
  var { addSignal: addSignal$2, removeSignal: removeSignal$2 } = abortSignal;
  var assert$2 = require$$0__default;
  var kResume = Symbol("resume");
  var Ct = class Ct2 extends Readable {
    constructor() {
      super({ autoDestroy: true }), this[kResume] = null;
    }
    _read() {
      const { [kResume]: A } = this;
      A && (this[kResume] = null, A());
    }
    _destroy(A, t2) {
      this._read(), t2(A);
    }
  };
  o2(Ct, "PipelineRequest");
  var PipelineRequest = Ct;
  var It = class It2 extends Readable {
    constructor(A) {
      super({ autoDestroy: true }), this[kResume] = A;
    }
    _read() {
      this[kResume]();
    }
    _destroy(A, t2) {
      !A && !this._readableState.endEmitted && (A = new RequestAbortedError), t2(A);
    }
  };
  o2(It, "PipelineResponse");
  var PipelineResponse = It;
  var at = class at2 extends AsyncResource$2 {
    constructor(A, t2) {
      if (!A || typeof A != "object")
        throw new InvalidArgumentError$7("invalid opts");
      if (typeof t2 != "function")
        throw new InvalidArgumentError$7("invalid handler");
      const { signal: n, method: r, opaque: s2, onInfo: i2, responseHeaders: E } = A;
      if (n && typeof n.on != "function" && typeof n.addEventListener != "function")
        throw new InvalidArgumentError$7("signal must be an EventEmitter or EventTarget");
      if (r === "CONNECT")
        throw new InvalidArgumentError$7("invalid method");
      if (i2 && typeof i2 != "function")
        throw new InvalidArgumentError$7("invalid onInfo callback");
      super("UNDICI_PIPELINE"), this.opaque = s2 || null, this.responseHeaders = E || null, this.handler = t2, this.abort = null, this.context = null, this.onInfo = i2 || null, this.req = new PipelineRequest().on("error", util$8.nop), this.ret = new Duplex({ readableObjectMode: A.objectMode, autoDestroy: true, read: () => {
        const { body: Q } = this;
        Q?.resume && Q.resume();
      }, write: (Q, C, I) => {
        const { req: a2 } = this;
        a2.push(Q, C) || a2._readableState.destroyed ? I() : a2[kResume] = I;
      }, destroy: (Q, C) => {
        const { body: I, req: a2, res: f, ret: h2, abort: L } = this;
        !Q && !h2._readableState.endEmitted && (Q = new RequestAbortedError), L && Q && L(), util$8.destroy(I, Q), util$8.destroy(a2, Q), util$8.destroy(f, Q), removeSignal$2(this), C(Q);
      } }).on("prefinish", () => {
        const { req: Q } = this;
        Q.push(null);
      }), this.res = null, addSignal$2(this, n);
    }
    onConnect(A, t2) {
      const { ret: n, res: r } = this;
      if (this.reason) {
        A(this.reason);
        return;
      }
      assert$2(!r, "pipeline cannot be retried"), assert$2(!n.destroyed), this.abort = A, this.context = t2;
    }
    onHeaders(A, t2, n) {
      const { opaque: r, handler: s2, context: i2 } = this;
      if (A < 200) {
        if (this.onInfo) {
          const Q = this.responseHeaders === "raw" ? util$8.parseRawHeaders(t2) : util$8.parseHeaders(t2);
          this.onInfo({ statusCode: A, headers: Q });
        }
        return;
      }
      this.res = new PipelineResponse(n);
      let E;
      try {
        this.handler = null;
        const Q = this.responseHeaders === "raw" ? util$8.parseRawHeaders(t2) : util$8.parseHeaders(t2);
        E = this.runInAsyncScope(s2, null, { statusCode: A, headers: Q, opaque: r, body: this.res, context: i2 });
      } catch (Q) {
        throw this.res.on("error", util$8.nop), Q;
      }
      if (!E || typeof E.on != "function")
        throw new InvalidReturnValueError("expected Readable");
      E.on("data", (Q) => {
        const { ret: C, body: I } = this;
        !C.push(Q) && I.pause && I.pause();
      }).on("error", (Q) => {
        const { ret: C } = this;
        util$8.destroy(C, Q);
      }).on("end", () => {
        const { ret: Q } = this;
        Q.push(null);
      }).on("close", () => {
        const { ret: Q } = this;
        Q._readableState.ended || util$8.destroy(Q, new RequestAbortedError);
      }), this.body = E;
    }
    onData(A) {
      const { res: t2 } = this;
      return t2.push(A);
    }
    onComplete(A) {
      const { res: t2 } = this;
      t2.push(null);
    }
    onError(A) {
      const { ret: t2 } = this;
      this.handler = null, util$8.destroy(t2, A);
    }
  };
  o2(at, "PipelineHandler");
  var PipelineHandler = at;
  function pipeline(e2, A) {
    try {
      const t2 = new PipelineHandler(e2, A);
      return this.dispatch({ ...e2, body: t2.req }, t2), t2.ret;
    } catch (t2) {
      return new PassThrough().destroy(t2);
    }
  }
  o2(pipeline, "pipeline");
  var apiPipeline = pipeline;
  var { InvalidArgumentError: InvalidArgumentError$6, SocketError: SocketError$1 } = errors$1;
  var { AsyncResource: AsyncResource$1 } = require$$5__default$1;
  var util$7 = util$m;
  var { addSignal: addSignal$1, removeSignal: removeSignal$1 } = abortSignal;
  var assert$1 = require$$0__default;
  var ct = class ct2 extends AsyncResource$1 {
    constructor(A, t2) {
      if (!A || typeof A != "object")
        throw new InvalidArgumentError$6("invalid opts");
      if (typeof t2 != "function")
        throw new InvalidArgumentError$6("invalid callback");
      const { signal: n, opaque: r, responseHeaders: s2 } = A;
      if (n && typeof n.on != "function" && typeof n.addEventListener != "function")
        throw new InvalidArgumentError$6("signal must be an EventEmitter or EventTarget");
      super("UNDICI_UPGRADE"), this.responseHeaders = s2 || null, this.opaque = r || null, this.callback = t2, this.abort = null, this.context = null, addSignal$1(this, n);
    }
    onConnect(A, t2) {
      if (this.reason) {
        A(this.reason);
        return;
      }
      assert$1(this.callback), this.abort = A, this.context = null;
    }
    onHeaders() {
      throw new SocketError$1("bad upgrade", null);
    }
    onUpgrade(A, t2, n) {
      const { callback: r, opaque: s2, context: i2 } = this;
      assert$1.strictEqual(A, 101), removeSignal$1(this), this.callback = null;
      const E = this.responseHeaders === "raw" ? util$7.parseRawHeaders(t2) : util$7.parseHeaders(t2);
      this.runInAsyncScope(r, null, null, { headers: E, socket: n, opaque: s2, context: i2 });
    }
    onError(A) {
      const { callback: t2, opaque: n } = this;
      removeSignal$1(this), t2 && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(t2, null, A, { opaque: n });
      }));
    }
  };
  o2(ct, "UpgradeHandler");
  var UpgradeHandler = ct;
  function upgrade(e2, A) {
    if (A === undefined)
      return new Promise((t2, n) => {
        upgrade.call(this, e2, (r, s2) => r ? n(r) : t2(s2));
      });
    try {
      const t2 = new UpgradeHandler(e2, A);
      this.dispatch({ ...e2, method: e2.method || "GET", upgrade: e2.protocol || "Websocket" }, t2);
    } catch (t2) {
      if (typeof A != "function")
        throw t2;
      const n = e2?.opaque;
      queueMicrotask(() => A(t2, { opaque: n }));
    }
  }
  o2(upgrade, "upgrade");
  var apiUpgrade = upgrade;
  var assert = require$$0__default;
  var { AsyncResource } = require$$5__default$1;
  var { InvalidArgumentError: InvalidArgumentError$5, SocketError } = errors$1;
  var util$6 = util$m;
  var { addSignal, removeSignal } = abortSignal;
  var ht = class ht2 extends AsyncResource {
    constructor(A, t2) {
      if (!A || typeof A != "object")
        throw new InvalidArgumentError$5("invalid opts");
      if (typeof t2 != "function")
        throw new InvalidArgumentError$5("invalid callback");
      const { signal: n, opaque: r, responseHeaders: s2 } = A;
      if (n && typeof n.on != "function" && typeof n.addEventListener != "function")
        throw new InvalidArgumentError$5("signal must be an EventEmitter or EventTarget");
      super("UNDICI_CONNECT"), this.opaque = r || null, this.responseHeaders = s2 || null, this.callback = t2, this.abort = null, addSignal(this, n);
    }
    onConnect(A, t2) {
      if (this.reason) {
        A(this.reason);
        return;
      }
      assert(this.callback), this.abort = A, this.context = t2;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(A, t2, n) {
      const { callback: r, opaque: s2, context: i2 } = this;
      removeSignal(this), this.callback = null;
      let E = t2;
      E != null && (E = this.responseHeaders === "raw" ? util$6.parseRawHeaders(t2) : util$6.parseHeaders(t2)), this.runInAsyncScope(r, null, null, { statusCode: A, headers: E, socket: n, opaque: s2, context: i2 });
    }
    onError(A) {
      const { callback: t2, opaque: n } = this;
      removeSignal(this), t2 && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(t2, null, A, { opaque: n });
      }));
    }
  };
  o2(ht, "ConnectHandler");
  var ConnectHandler = ht;
  function connect(e2, A) {
    if (A === undefined)
      return new Promise((t2, n) => {
        connect.call(this, e2, (r, s2) => r ? n(r) : t2(s2));
      });
    try {
      const t2 = new ConnectHandler(e2, A);
      this.dispatch({ ...e2, method: "CONNECT" }, t2);
    } catch (t2) {
      if (typeof A != "function")
        throw t2;
      const n = e2?.opaque;
      queueMicrotask(() => A(t2, { opaque: n }));
    }
  }
  o2(connect, "connect");
  var apiConnect = connect;
  api$1.request = apiRequestExports, api$1.stream = apiStream, api$1.pipeline = apiPipeline, api$1.upgrade = apiUpgrade, api$1.connect = apiConnect;
  var { UndiciError } = errors$1;
  var MockNotMatchedError$1 = (Ae = class extends UndiciError {
    constructor(A) {
      super(A), Error.captureStackTrace(this, Ae), this.name = "MockNotMatchedError", this.message = A || "The request does not match any registered mock dispatches", this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
  }, o2(Ae, "MockNotMatchedError"), Ae);
  var mockErrors = { MockNotMatchedError: MockNotMatchedError$1 };
  var mockSymbols = { kAgent: Symbol("agent"), kOptions: Symbol("options"), kFactory: Symbol("factory"), kDispatches: Symbol("dispatches"), kDispatchKey: Symbol("dispatch key"), kDefaultHeaders: Symbol("default headers"), kDefaultTrailers: Symbol("default trailers"), kContentLength: Symbol("content length"), kMockAgent: Symbol("mock agent"), kMockAgentSet: Symbol("mock agent set"), kMockAgentGet: Symbol("mock agent get"), kMockDispatch: Symbol("mock dispatch"), kClose: Symbol("close"), kOriginalClose: Symbol("original agent close"), kOrigin: Symbol("origin"), kIsMockActive: Symbol("is mock active"), kNetConnect: Symbol("net connect"), kGetNetConnect: Symbol("get net connect"), kConnected: Symbol("connected") };
  var { MockNotMatchedError } = mockErrors;
  var { kDispatches: kDispatches$3, kMockAgent: kMockAgent$2, kOriginalDispatch: kOriginalDispatch$2, kOrigin: kOrigin$2, kGetNetConnect } = mockSymbols;
  var { buildURL: buildURL$1 } = util$m;
  var { STATUS_CODES } = http__default;
  var { types: { isPromise } } = require$$0__default$1;
  function matchValue(e2, A) {
    return typeof e2 == "string" ? e2 === A : e2 instanceof RegExp ? e2.test(A) : typeof e2 == "function" ? e2(A) === true : false;
  }
  o2(matchValue, "matchValue");
  function lowerCaseEntries(e2) {
    return Object.fromEntries(Object.entries(e2).map(([A, t2]) => [A.toLocaleLowerCase(), t2]));
  }
  o2(lowerCaseEntries, "lowerCaseEntries");
  function getHeaderByName(e2, A) {
    if (Array.isArray(e2)) {
      for (let t2 = 0;t2 < e2.length; t2 += 2)
        if (e2[t2].toLocaleLowerCase() === A.toLocaleLowerCase())
          return e2[t2 + 1];
      return;
    } else
      return typeof e2.get == "function" ? e2.get(A) : lowerCaseEntries(e2)[A.toLocaleLowerCase()];
  }
  o2(getHeaderByName, "getHeaderByName");
  function buildHeadersFromArray(e2) {
    const A = e2.slice(), t2 = [];
    for (let n = 0;n < A.length; n += 2)
      t2.push([A[n], A[n + 1]]);
    return Object.fromEntries(t2);
  }
  o2(buildHeadersFromArray, "buildHeadersFromArray");
  function matchHeaders(e2, A) {
    if (typeof e2.headers == "function")
      return Array.isArray(A) && (A = buildHeadersFromArray(A)), e2.headers(A ? lowerCaseEntries(A) : {});
    if (typeof e2.headers > "u")
      return true;
    if (typeof A != "object" || typeof e2.headers != "object")
      return false;
    for (const [t2, n] of Object.entries(e2.headers)) {
      const r = getHeaderByName(A, t2);
      if (!matchValue(n, r))
        return false;
    }
    return true;
  }
  o2(matchHeaders, "matchHeaders");
  function safeUrl(e2) {
    if (typeof e2 != "string")
      return e2;
    const A = e2.split("?");
    if (A.length !== 2)
      return e2;
    const t2 = new URLSearchParams(A.pop());
    return t2.sort(), [...A, t2.toString()].join("?");
  }
  o2(safeUrl, "safeUrl");
  function matchKey(e2, { path: A, method: t2, body: n, headers: r }) {
    const s2 = matchValue(e2.path, A), i2 = matchValue(e2.method, t2), E = typeof e2.body < "u" ? matchValue(e2.body, n) : true, Q = matchHeaders(e2, r);
    return s2 && i2 && E && Q;
  }
  o2(matchKey, "matchKey");
  function getResponseData$1(e2) {
    return Buffer.isBuffer(e2) ? e2 : typeof e2 == "object" ? JSON.stringify(e2) : e2.toString();
  }
  o2(getResponseData$1, "getResponseData$1");
  function getMockDispatch(e2, A) {
    const t2 = A.query ? buildURL$1(A.path, A.query) : A.path, n = typeof t2 == "string" ? safeUrl(t2) : t2;
    let r = e2.filter(({ consumed: s2 }) => !s2).filter(({ path: s2 }) => matchValue(safeUrl(s2), n));
    if (r.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${n}'`);
    if (r = r.filter(({ method: s2 }) => matchValue(s2, A.method)), r.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${A.method}' on path '${n}'`);
    if (r = r.filter(({ body: s2 }) => typeof s2 < "u" ? matchValue(s2, A.body) : true), r.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${A.body}' on path '${n}'`);
    if (r = r.filter((s2) => matchHeaders(s2, A.headers)), r.length === 0) {
      const s2 = typeof A.headers == "object" ? JSON.stringify(A.headers) : A.headers;
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${s2}' on path '${n}'`);
    }
    return r[0];
  }
  o2(getMockDispatch, "getMockDispatch");
  function addMockDispatch$1(e2, A, t2) {
    const n = { timesInvoked: 0, times: 1, persist: false, consumed: false }, r = typeof t2 == "function" ? { callback: t2 } : { ...t2 }, s2 = { ...n, ...A, pending: true, data: { error: null, ...r } };
    return e2.push(s2), s2;
  }
  o2(addMockDispatch$1, "addMockDispatch$1");
  function deleteMockDispatch(e2, A) {
    const t2 = e2.findIndex((n) => n.consumed ? matchKey(n, A) : false);
    t2 !== -1 && e2.splice(t2, 1);
  }
  o2(deleteMockDispatch, "deleteMockDispatch");
  function buildKey$1(e2) {
    const { path: A, method: t2, body: n, headers: r, query: s2 } = e2;
    return { path: A, method: t2, body: n, headers: r, query: s2 };
  }
  o2(buildKey$1, "buildKey$1");
  function generateKeyValues(e2) {
    const A = Object.keys(e2), t2 = [];
    for (let n = 0;n < A.length; ++n) {
      const r = A[n], s2 = e2[r], i2 = Buffer.from(`${r}`);
      if (Array.isArray(s2))
        for (let E = 0;E < s2.length; ++E)
          t2.push(i2, Buffer.from(`${s2[E]}`));
      else
        t2.push(i2, Buffer.from(`${s2}`));
    }
    return t2;
  }
  o2(generateKeyValues, "generateKeyValues");
  function getStatusText(e2) {
    return STATUS_CODES[e2] || "unknown";
  }
  o2(getStatusText, "getStatusText");
  async function getResponse(e2) {
    const A = [];
    for await (const t2 of e2)
      A.push(t2);
    return Buffer.concat(A).toString("utf8");
  }
  o2(getResponse, "getResponse");
  function mockDispatch(e2, A) {
    const t2 = buildKey$1(e2), n = getMockDispatch(this[kDispatches$3], t2);
    n.timesInvoked++, n.data.callback && (n.data = { ...n.data, ...n.data.callback(e2) });
    const { data: { statusCode: r, data: s2, headers: i2, trailers: E, error: Q }, delay: C, persist: I } = n, { timesInvoked: a2, times: f } = n;
    if (n.consumed = !I && a2 >= f, n.pending = a2 < f, Q !== null)
      return deleteMockDispatch(this[kDispatches$3], t2), A.onError(Q), true;
    typeof C == "number" && C > 0 ? setTimeout(() => {
      h2(this[kDispatches$3]);
    }, C) : h2(this[kDispatches$3]);
    function h2(c, l2 = s2) {
      const S = Array.isArray(e2.headers) ? buildHeadersFromArray(e2.headers) : e2.headers, k = typeof l2 == "function" ? l2({ ...e2, headers: S }) : l2;
      if (isPromise(k)) {
        k.then((B) => h2(c, B));
        return;
      }
      const w = getResponseData$1(k), U = generateKeyValues(i2), M = generateKeyValues(E);
      A.onConnect?.((B) => A.onError(B), null), A.onHeaders?.(r, U, L, getStatusText(r)), A.onData?.(Buffer.from(w)), A.onComplete?.(M), deleteMockDispatch(c, t2);
    }
    o2(h2, "handleReply");
    function L() {}
    return o2(L, "resume"), true;
  }
  o2(mockDispatch, "mockDispatch");
  function buildMockDispatch$2() {
    const e2 = this[kMockAgent$2], A = this[kOrigin$2], t2 = this[kOriginalDispatch$2];
    return o2(function(r, s2) {
      if (e2.isMockActive)
        try {
          mockDispatch.call(this, r, s2);
        } catch (i2) {
          if (i2 instanceof MockNotMatchedError) {
            const E = e2[kGetNetConnect]();
            if (E === false)
              throw new MockNotMatchedError(`${i2.message}: subsequent request to origin ${A} was not allowed (net.connect disabled)`);
            if (checkNetConnect(E, A))
              t2.call(this, r, s2);
            else
              throw new MockNotMatchedError(`${i2.message}: subsequent request to origin ${A} was not allowed (net.connect is not enabled for this origin)`);
          } else
            throw i2;
        }
      else
        t2.call(this, r, s2);
    }, "dispatch");
  }
  o2(buildMockDispatch$2, "buildMockDispatch$2");
  function checkNetConnect(e2, A) {
    const t2 = new URL(A);
    return e2 === true ? true : !!(Array.isArray(e2) && e2.some((n) => matchValue(n, t2.host)));
  }
  o2(checkNetConnect, "checkNetConnect");
  function buildMockOptions(e2) {
    if (e2) {
      const { agent: A, ...t2 } = e2;
      return t2;
    }
  }
  o2(buildMockOptions, "buildMockOptions");
  var mockUtils = { getResponseData: getResponseData$1, getMockDispatch, addMockDispatch: addMockDispatch$1, deleteMockDispatch, buildKey: buildKey$1, generateKeyValues, matchValue, getResponse, getStatusText, mockDispatch, buildMockDispatch: buildMockDispatch$2, checkNetConnect, buildMockOptions, getHeaderByName, buildHeadersFromArray };
  var mockInterceptor = {};
  var { getResponseData, buildKey, addMockDispatch } = mockUtils;
  var { kDispatches: kDispatches$2, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = mockSymbols;
  var { InvalidArgumentError: InvalidArgumentError$4 } = errors$1;
  var { buildURL } = util$m;
  var lt = class lt2 {
    constructor(A) {
      this[kMockDispatch] = A;
    }
    delay(A) {
      if (typeof A != "number" || !Number.isInteger(A) || A <= 0)
        throw new InvalidArgumentError$4("waitInMs must be a valid integer > 0");
      return this[kMockDispatch].delay = A, this;
    }
    persist() {
      return this[kMockDispatch].persist = true, this;
    }
    times(A) {
      if (typeof A != "number" || !Number.isInteger(A) || A <= 0)
        throw new InvalidArgumentError$4("repeatTimes must be a valid integer > 0");
      return this[kMockDispatch].times = A, this;
    }
  };
  o2(lt, "MockScope");
  var MockScope = lt;
  var MockInterceptor$2 = (Te = class {
    constructor(A, t2) {
      if (typeof A != "object")
        throw new InvalidArgumentError$4("opts must be an object");
      if (typeof A.path > "u")
        throw new InvalidArgumentError$4("opts.path must be defined");
      if (typeof A.method > "u" && (A.method = "GET"), typeof A.path == "string")
        if (A.query)
          A.path = buildURL(A.path, A.query);
        else {
          const n = new URL(A.path, "data://");
          A.path = n.pathname + n.search;
        }
      typeof A.method == "string" && (A.method = A.method.toUpperCase()), this[kDispatchKey] = buildKey(A), this[kDispatches$2] = t2, this[kDefaultHeaders] = {}, this[kDefaultTrailers] = {}, this[kContentLength] = false;
    }
    createMockScopeDispatchData({ statusCode: A, data: t2, responseOptions: n }) {
      const r = getResponseData(t2), s2 = this[kContentLength] ? { "content-length": r.length } : {}, i2 = { ...this[kDefaultHeaders], ...s2, ...n.headers }, E = { ...this[kDefaultTrailers], ...n.trailers };
      return { statusCode: A, data: t2, headers: i2, trailers: E };
    }
    validateReplyParameters(A) {
      if (typeof A.statusCode > "u")
        throw new InvalidArgumentError$4("statusCode must be defined");
      if (typeof A.responseOptions != "object" || A.responseOptions === null)
        throw new InvalidArgumentError$4("responseOptions must be an object");
    }
    reply(A) {
      if (typeof A == "function") {
        const s2 = o2((E) => {
          const Q = A(E);
          if (typeof Q != "object" || Q === null)
            throw new InvalidArgumentError$4("reply options callback must return an object");
          const C = { data: "", responseOptions: {}, ...Q };
          return this.validateReplyParameters(C), { ...this.createMockScopeDispatchData(C) };
        }, "wrappedDefaultsCallback"), i2 = addMockDispatch(this[kDispatches$2], this[kDispatchKey], s2);
        return new MockScope(i2);
      }
      const t2 = { statusCode: A, data: arguments[1] === undefined ? "" : arguments[1], responseOptions: arguments[2] === undefined ? {} : arguments[2] };
      this.validateReplyParameters(t2);
      const n = this.createMockScopeDispatchData(t2), r = addMockDispatch(this[kDispatches$2], this[kDispatchKey], n);
      return new MockScope(r);
    }
    replyWithError(A) {
      if (typeof A > "u")
        throw new InvalidArgumentError$4("error must be defined");
      const t2 = addMockDispatch(this[kDispatches$2], this[kDispatchKey], { error: A });
      return new MockScope(t2);
    }
    defaultReplyHeaders(A) {
      if (typeof A > "u")
        throw new InvalidArgumentError$4("headers must be defined");
      return this[kDefaultHeaders] = A, this;
    }
    defaultReplyTrailers(A) {
      if (typeof A > "u")
        throw new InvalidArgumentError$4("trailers must be defined");
      return this[kDefaultTrailers] = A, this;
    }
    replyContentLength() {
      return this[kContentLength] = true, this;
    }
  }, o2(Te, "MockInterceptor"), Te);
  mockInterceptor.MockInterceptor = MockInterceptor$2, mockInterceptor.MockScope = MockScope;
  var { promisify: promisify$1 } = require$$0__default$1;
  var Client = client;
  var { buildMockDispatch: buildMockDispatch$1 } = mockUtils;
  var { kDispatches: kDispatches$1, kMockAgent: kMockAgent$1, kClose: kClose$1, kOriginalClose: kOriginalClose$1, kOrigin: kOrigin$1, kOriginalDispatch: kOriginalDispatch$1, kConnected: kConnected$1 } = mockSymbols;
  var { MockInterceptor: MockInterceptor$1 } = mockInterceptor;
  var Symbols$1 = symbols$4;
  var { InvalidArgumentError: InvalidArgumentError$3 } = errors$1;
  var ut = class ut2 extends Client {
    constructor(A, t2) {
      if (super(A, t2), !t2 || !t2.agent || typeof t2.agent.dispatch != "function")
        throw new InvalidArgumentError$3("Argument opts.agent must implement Agent");
      this[kMockAgent$1] = t2.agent, this[kOrigin$1] = A, this[kDispatches$1] = [], this[kConnected$1] = 1, this[kOriginalDispatch$1] = this.dispatch, this[kOriginalClose$1] = this.close.bind(this), this.dispatch = buildMockDispatch$1.call(this), this.close = this[kClose$1];
    }
    get [Symbols$1.kConnected]() {
      return this[kConnected$1];
    }
    intercept(A) {
      return new MockInterceptor$1(A, this[kDispatches$1]);
    }
    async[kClose$1]() {
      await promisify$1(this[kOriginalClose$1])(), this[kConnected$1] = 0, this[kMockAgent$1][Symbols$1.kClients].delete(this[kOrigin$1]);
    }
  };
  o2(ut, "MockClient");
  var { promisify } = require$$0__default$1;
  var Pool = pool;
  var { buildMockDispatch } = mockUtils;
  var { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = mockSymbols;
  var { MockInterceptor } = mockInterceptor;
  var Symbols = symbols$4;
  var { InvalidArgumentError: InvalidArgumentError$2 } = errors$1;
  var dt = class dt2 extends Pool {
    constructor(A, t2) {
      if (super(A, t2), !t2 || !t2.agent || typeof t2.agent.dispatch != "function")
        throw new InvalidArgumentError$2("Argument opts.agent must implement Agent");
      this[kMockAgent] = t2.agent, this[kOrigin] = A, this[kDispatches] = [], this[kConnected] = 1, this[kOriginalDispatch] = this.dispatch, this[kOriginalClose] = this.close.bind(this), this.dispatch = buildMockDispatch.call(this), this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(A) {
      return new MockInterceptor(A, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])(), this[kConnected] = 0, this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  };
  o2(dt, "MockPool");
  process.versions.icu, process.versions.icu;
  var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
  var { InvalidArgumentError: InvalidArgumentError$1 } = errors$1;
  var Agent$1 = agent;
  getGlobalDispatcher$1() === undefined && setGlobalDispatcher$1(new Agent$1);
  function setGlobalDispatcher$1(e2) {
    if (!e2 || typeof e2.dispatch != "function")
      throw new InvalidArgumentError$1("Argument agent must implement Agent");
    Object.defineProperty(globalThis, globalDispatcher, { value: e2, writable: true, enumerable: false, configurable: false });
  }
  o2(setGlobalDispatcher$1, "setGlobalDispatcher$1");
  function getGlobalDispatcher$1() {
    return globalThis[globalDispatcher];
  }
  o2(getGlobalDispatcher$1, "getGlobalDispatcher$1");
  var global2 = { setGlobalDispatcher: setGlobalDispatcher$1, getGlobalDispatcher: getGlobalDispatcher$1 };
  var headers;
  var hasRequiredHeaders;
  function requireHeaders() {
    if (hasRequiredHeaders)
      return headers;
    hasRequiredHeaders = 1;
    const { kHeadersList: e2, kConstruct: A } = symbols$4, { kGuard: t2 } = requireSymbols$3(), { kEnumerableProperty: n } = util$m, { iteratorMixin: r, isValidHeaderName: s2, isValidHeaderValue: i2 } = requireUtil$5(), { webidl: E } = requireWebidl(), Q = require$$0__default, C = require$$0__default$1, I = Symbol("headers map"), a2 = Symbol("headers map sorted");
    function f(M) {
      return M === 10 || M === 13 || M === 9 || M === 32;
    }
    o2(f, "isHTTPWhiteSpaceCharCode");
    function h2(M) {
      let B = 0, D = M.length;
      for (;D > B && f(M.charCodeAt(D - 1)); )
        --D;
      for (;D > B && f(M.charCodeAt(B)); )
        ++B;
      return B === 0 && D === M.length ? M : M.substring(B, D);
    }
    o2(h2, "headerValueNormalize");
    function L(M, B) {
      if (Array.isArray(B))
        for (let D = 0;D < B.length; ++D) {
          const G = B[D];
          if (G.length !== 2)
            throw E.errors.exception({ header: "Headers constructor", message: `expected name/value pair to be length 2, found ${G.length}.` });
          c(M, G[0], G[1]);
        }
      else if (typeof B == "object" && B !== null) {
        const D = Object.keys(B);
        for (let G = 0;G < D.length; ++G)
          c(M, D[G], B[D[G]]);
      } else
        throw E.errors.conversionFailed({ prefix: "Headers constructor", argument: "Argument 1", types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"] });
    }
    o2(L, "fill");
    function c(M, B, D) {
      if (D = h2(D), s2(B)) {
        if (!i2(D))
          throw E.errors.invalidArgument({ prefix: "Headers.append", value: D, type: "header value" });
      } else
        throw E.errors.invalidArgument({ prefix: "Headers.append", value: B, type: "header name" });
      if (M[t2] === "immutable")
        throw new TypeError("immutable");
      return M[t2], M[e2].append(B, D, false);
    }
    o2(c, "appendHeader");
    function l2(M, B) {
      return M[0] < B[0] ? -1 : 1;
    }
    o2(l2, "compareHeaderName");
    const w = class w2 {
      constructor(B) {
        NA(this, "cookies", null);
        B instanceof w2 ? (this[I] = new Map(B[I]), this[a2] = B[a2], this.cookies = B.cookies === null ? null : [...B.cookies]) : (this[I] = new Map(B), this[a2] = null);
      }
      contains(B, D) {
        return this[I].has(D ? B : B.toLowerCase());
      }
      clear() {
        this[I].clear(), this[a2] = null, this.cookies = null;
      }
      append(B, D, G) {
        this[a2] = null;
        const g = G ? B : B.toLowerCase(), d = this[I].get(g);
        if (d) {
          const F = g === "cookie" ? "; " : ", ";
          this[I].set(g, { name: d.name, value: `${d.value}${F}${D}` });
        } else
          this[I].set(g, { name: B, value: D });
        g === "set-cookie" && (this.cookies ?? (this.cookies = [])).push(D);
      }
      set(B, D, G) {
        this[a2] = null;
        const g = G ? B : B.toLowerCase();
        g === "set-cookie" && (this.cookies = [D]), this[I].set(g, { name: B, value: D });
      }
      delete(B, D) {
        this[a2] = null, D || (B = B.toLowerCase()), B === "set-cookie" && (this.cookies = null), this[I].delete(B);
      }
      get(B, D) {
        return this[I].get(D ? B : B.toLowerCase())?.value ?? null;
      }
      *[Symbol.iterator]() {
        for (const { 0: B, 1: { value: D } } of this[I])
          yield [B, D];
      }
      get entries() {
        const B = {};
        if (this[I].size)
          for (const { name: D, value: G } of this[I].values())
            B[D] = G;
        return B;
      }
      toSortedArray() {
        const B = this[I].size, D = new Array(B);
        if (B <= 32) {
          if (B === 0)
            return D;
          const G = this[I][Symbol.iterator](), g = G.next().value;
          D[0] = [g[0], g[1].value], Q(g[1].value !== null);
          for (let d = 1, F = 0, N = 0, u = 0, b = 0, m, T;d < B; ++d) {
            for (T = G.next().value, m = D[d] = [T[0], T[1].value], Q(m[1] !== null), u = 0, N = d;u < N; )
              b = u + (N - u >> 1), D[b][0] <= m[0] ? u = b + 1 : N = b;
            if (d !== b) {
              for (F = d;F > u; )
                D[F] = D[--F];
              D[u] = m;
            }
          }
          if (!G.next().done)
            throw new TypeError("Unreachable");
          return D;
        } else {
          let G = 0;
          for (const { 0: g, 1: { value: d } } of this[I])
            D[G++] = [g, d], Q(d !== null);
          return D.sort(l2);
        }
      }
    };
    o2(w, "HeadersList");
    let S = w;
    const U = class U2 {
      constructor(B = undefined) {
        B !== A && (this[e2] = new S, this[t2] = "none", B !== undefined && (B = E.converters.HeadersInit(B), L(this, B)));
      }
      append(B, D) {
        return E.brandCheck(this, U2), E.argumentLengthCheck(arguments, 2, { header: "Headers.append" }), B = E.converters.ByteString(B), D = E.converters.ByteString(D), c(this, B, D);
      }
      delete(B) {
        if (E.brandCheck(this, U2), E.argumentLengthCheck(arguments, 1, { header: "Headers.delete" }), B = E.converters.ByteString(B), !s2(B))
          throw E.errors.invalidArgument({ prefix: "Headers.delete", value: B, type: "header name" });
        if (this[t2] === "immutable")
          throw new TypeError("immutable");
        this[t2], this[e2].contains(B, false) && this[e2].delete(B, false);
      }
      get(B) {
        if (E.brandCheck(this, U2), E.argumentLengthCheck(arguments, 1, { header: "Headers.get" }), B = E.converters.ByteString(B), !s2(B))
          throw E.errors.invalidArgument({ prefix: "Headers.get", value: B, type: "header name" });
        return this[e2].get(B, false);
      }
      has(B) {
        if (E.brandCheck(this, U2), E.argumentLengthCheck(arguments, 1, { header: "Headers.has" }), B = E.converters.ByteString(B), !s2(B))
          throw E.errors.invalidArgument({ prefix: "Headers.has", value: B, type: "header name" });
        return this[e2].contains(B, false);
      }
      set(B, D) {
        if (E.brandCheck(this, U2), E.argumentLengthCheck(arguments, 2, { header: "Headers.set" }), B = E.converters.ByteString(B), D = E.converters.ByteString(D), D = h2(D), s2(B)) {
          if (!i2(D))
            throw E.errors.invalidArgument({ prefix: "Headers.set", value: D, type: "header value" });
        } else
          throw E.errors.invalidArgument({ prefix: "Headers.set", value: B, type: "header name" });
        if (this[t2] === "immutable")
          throw new TypeError("immutable");
        this[t2], this[e2].set(B, D, false);
      }
      getSetCookie() {
        E.brandCheck(this, U2);
        const B = this[e2].cookies;
        return B ? [...B] : [];
      }
      get [a2]() {
        if (this[e2][a2])
          return this[e2][a2];
        const B = [], D = this[e2].toSortedArray(), G = this[e2].cookies;
        if (G === null || G.length === 1)
          return this[e2][a2] = D;
        for (let g = 0;g < D.length; ++g) {
          const { 0: d, 1: F } = D[g];
          if (d === "set-cookie")
            for (let N = 0;N < G.length; ++N)
              B.push([d, G[N]]);
          else
            B.push([d, F]);
        }
        return this[e2][a2] = B;
      }
      [C.inspect.custom](B, D) {
        return D.depth ?? (D.depth = B), `Headers ${C.formatWithOptions(D, this[e2].entries)}`;
      }
    };
    o2(U, "Headers");
    let k = U;
    return Object.defineProperty(k.prototype, C.inspect.custom, { enumerable: false }), r("Headers", k, a2, 0, 1), Object.defineProperties(k.prototype, { append: n, delete: n, get: n, has: n, set: n, getSetCookie: n, [Symbol.toStringTag]: { value: "Headers", configurable: true } }), E.converters.HeadersInit = function(M) {
      if (E.util.Type(M) === "Object") {
        const B = Reflect.get(M, Symbol.iterator);
        return typeof B == "function" ? E.converters["sequence<sequence<ByteString>>"](M, B.bind(M)) : E.converters["record<ByteString, ByteString>"](M);
      }
      throw E.errors.conversionFailed({ prefix: "Headers constructor", argument: "Argument 1", types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"] });
    }, headers = { fill: L, compareHeaderName: l2, Headers: k, HeadersList: S }, headers;
  }
  o2(requireHeaders, "requireHeaders");
  var response;
  var hasRequiredResponse;
  function requireResponse() {
    if (hasRequiredResponse)
      return response;
    hasRequiredResponse = 1;
    const { Headers: e2, HeadersList: A, fill: t2 } = requireHeaders(), { extractBody: n, cloneBody: r, mixinBody: s2 } = requireBody(), i2 = util$m, E = require$$0__default$1, { kEnumerableProperty: Q } = i2, { isValidReasonPhrase: C, isCancelled: I, isAborted: a2, isBlobLike: f, serializeJavascriptValueToJSONString: h2, isErrorLike: L, isomorphicEncode: c } = requireUtil$5(), { redirectStatusSet: l2, nullBodyStatus: S } = requireConstants$2(), { kState: k, kHeaders: w, kGuard: U, kRealm: M } = requireSymbols$3(), { webidl: B } = requireWebidl(), { FormData: D } = requireFormdata(), { getGlobalOrigin: G } = requireGlobal(), { URLSerializer: g } = requireDataUrl(), { kHeadersList: d, kConstruct: F } = symbols$4, N = require$$0__default, { types: u } = require$$0__default$1, b = new TextEncoder("utf-8"), $ = class $2 {
      static error() {
        const q = { settingsObject: {} };
        return X(Z(), "immutable", q);
      }
      static json(q, z = {}) {
        B.argumentLengthCheck(arguments, 1, { header: "Response.json" }), z !== null && (z = B.converters.ResponseInit(z));
        const rA = b.encode(h2(q)), iA = n(rA), gA = { settingsObject: {} }, BA = X(v({}), "response", gA);
        return aA(BA, z, { body: iA[0], type: "application/json" }), BA;
      }
      static redirect(q, z = 302) {
        const rA = { settingsObject: {} };
        B.argumentLengthCheck(arguments, 1, { header: "Response.redirect" }), q = B.converters.USVString(q), z = B.converters["unsigned short"](z);
        let iA;
        try {
          iA = new URL(q, G());
        } catch (sA) {
          throw new TypeError(`Failed to parse URL from ${q}`, { cause: sA });
        }
        if (!l2.has(z))
          throw new RangeError(`Invalid status code ${z}`);
        const gA = X(v({}), "immutable", rA);
        gA[k].status = z;
        const BA = c(g(iA));
        return gA[k].headersList.append("location", BA, true), gA;
      }
      constructor(q = null, z = {}) {
        if (q === F)
          return;
        q !== null && (q = B.converters.BodyInit(q)), z = B.converters.ResponseInit(z), this[M] = { settingsObject: {} }, this[k] = v({}), this[w] = new e2(F), this[w][U] = "response", this[w][d] = this[k].headersList, this[w][M] = this[M];
        let rA = null;
        if (q != null) {
          const [iA, gA] = n(q);
          rA = { body: iA, type: gA };
        }
        aA(this, z, rA);
      }
      get type() {
        return B.brandCheck(this, $2), this[k].type;
      }
      get url() {
        B.brandCheck(this, $2);
        const q = this[k].urlList, z = q[q.length - 1] ?? null;
        return z === null ? "" : g(z, true);
      }
      get redirected() {
        return B.brandCheck(this, $2), this[k].urlList.length > 1;
      }
      get status() {
        return B.brandCheck(this, $2), this[k].status;
      }
      get ok() {
        return B.brandCheck(this, $2), this[k].status >= 200 && this[k].status <= 299;
      }
      get statusText() {
        return B.brandCheck(this, $2), this[k].statusText;
      }
      get headers() {
        return B.brandCheck(this, $2), this[w];
      }
      get body() {
        return B.brandCheck(this, $2), this[k].body ? this[k].body.stream : null;
      }
      get bodyUsed() {
        return B.brandCheck(this, $2), !!this[k].body && i2.isDisturbed(this[k].body.stream);
      }
      clone() {
        if (B.brandCheck(this, $2), this.bodyUsed || this.body?.locked)
          throw B.errors.exception({ header: "Response.clone", message: "Body has already been consumed." });
        const q = T(this[k]);
        return X(q, this[w][U], this[M]);
      }
      [E.inspect.custom](q, z) {
        z.depth === null && (z.depth = 2), z.colors ?? (z.colors = true);
        const rA = { status: this.status, statusText: this.statusText, headers: this.headers, body: this.body, bodyUsed: this.bodyUsed, ok: this.ok, redirected: this.redirected, type: this.type, url: this.url };
        return `Response ${E.formatWithOptions(z, rA)}`;
      }
    };
    o2($, "Response");
    let m = $;
    s2(m), Object.defineProperties(m.prototype, { type: Q, url: Q, status: Q, ok: Q, redirected: Q, statusText: Q, headers: Q, clone: Q, body: Q, bodyUsed: Q, [Symbol.toStringTag]: { value: "Response", configurable: true } }), Object.defineProperties(m, { json: Q, redirect: Q, error: Q });
    function T(V) {
      if (V.internalResponse)
        return K(T(V.internalResponse), V.type);
      const q = v({ ...V, body: null });
      return V.body != null && (q.body = r(V.body)), q;
    }
    o2(T, "cloneResponse");
    function v(V) {
      return { aborted: false, rangeRequested: false, timingAllowPassed: false, requestIncludesCredentials: false, type: "default", status: 200, timingInfo: null, cacheState: "", statusText: "", ...V, headersList: V?.headersList ? new A(V?.headersList) : new A, urlList: V?.urlList ? [...V.urlList] : [] };
    }
    o2(v, "makeResponse");
    function Z(V) {
      const q = L(V);
      return v({ type: "error", status: 0, error: q ? V : new Error(V && String(V)), aborted: V && V.name === "AbortError" });
    }
    o2(Z, "makeNetworkError");
    function P(V) {
      return V.type === "error" && V.status === 0;
    }
    o2(P, "isNetworkError");
    function AA(V, q) {
      return q = { internalResponse: V, ...q }, new Proxy(V, { get(z, rA) {
        return rA in q ? q[rA] : z[rA];
      }, set(z, rA, iA) {
        return N(!(rA in q)), z[rA] = iA, true;
      } });
    }
    o2(AA, "makeFilteredResponse");
    function K(V, q) {
      if (q === "basic")
        return AA(V, { type: "basic", headersList: V.headersList });
      if (q === "cors")
        return AA(V, { type: "cors", headersList: V.headersList });
      if (q === "opaque")
        return AA(V, { type: "opaque", urlList: Object.freeze([]), status: 0, statusText: "", body: null });
      if (q === "opaqueredirect")
        return AA(V, { type: "opaqueredirect", status: 0, statusText: "", headersList: [], body: null });
      N(false);
    }
    o2(K, "filterResponse");
    function tA(V, q = null) {
      return N(I(V)), a2(V) ? Z(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: q })) : Z(Object.assign(new DOMException("Request was cancelled."), { cause: q }));
    }
    o2(tA, "makeAppropriateNetworkError");
    function aA(V, q, z) {
      if (q.status !== null && (q.status < 200 || q.status > 599))
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      if ("statusText" in q && q.statusText != null && !C(String(q.statusText)))
        throw new TypeError("Invalid statusText");
      if ("status" in q && q.status != null && (V[k].status = q.status), "statusText" in q && q.statusText != null && (V[k].statusText = q.statusText), "headers" in q && q.headers != null && t2(V[w], q.headers), z) {
        if (S.includes(V.status))
          throw B.errors.exception({ header: "Response constructor", message: `Invalid response status code ${V.status}` });
        V[k].body = z.body, z.type != null && !V[k].headersList.contains("content-type", true) && V[k].headersList.append("content-type", z.type, true);
      }
    }
    o2(aA, "initializeResponse");
    function X(V, q, z) {
      const rA = new m(F);
      return rA[k] = V, rA[M] = z, rA[w] = new e2(F), rA[w][d] = V.headersList, rA[w][U] = q, rA[w][M] = z, rA;
    }
    return o2(X, "fromInnerResponse"), B.converters.ReadableStream = B.interfaceConverter(ReadableStream), B.converters.FormData = B.interfaceConverter(D), B.converters.URLSearchParams = B.interfaceConverter(URLSearchParams), B.converters.XMLHttpRequestBodyInit = function(V) {
      return typeof V == "string" ? B.converters.USVString(V) : f(V) ? B.converters.Blob(V, { strict: false }) : ArrayBuffer.isView(V) || u.isArrayBuffer(V) ? B.converters.BufferSource(V) : i2.isFormDataLike(V) ? B.converters.FormData(V, { strict: false }) : V instanceof URLSearchParams ? B.converters.URLSearchParams(V) : B.converters.DOMString(V);
    }, B.converters.BodyInit = function(V) {
      return V instanceof ReadableStream ? B.converters.ReadableStream(V) : V?.[Symbol.asyncIterator] ? V : B.converters.XMLHttpRequestBodyInit(V);
    }, B.converters.ResponseInit = B.dictionaryConverter([{ key: "status", converter: B.converters["unsigned short"], defaultValue: 200 }, { key: "statusText", converter: B.converters.ByteString, defaultValue: "" }, { key: "headers", converter: B.converters.HeadersInit }]), response = { isNetworkError: P, makeNetworkError: Z, makeResponse: v, makeAppropriateNetworkError: tA, filterResponse: K, Response: m, cloneResponse: T, fromInnerResponse: X }, response;
  }
  o2(requireResponse, "requireResponse");
  var dispatcherWeakref;
  var hasRequiredDispatcherWeakref;
  function requireDispatcherWeakref() {
    if (hasRequiredDispatcherWeakref)
      return dispatcherWeakref;
    hasRequiredDispatcherWeakref = 1;
    const { kConnected: e2, kSize: A } = symbols$4, r = class r2 {
      constructor(E) {
        this.value = E;
      }
      deref() {
        return this.value[e2] === 0 && this.value[A] === 0 ? undefined : this.value;
      }
    };
    o2(r, "CompatWeakRef");
    let t2 = r;
    const s2 = class s3 {
      constructor(E) {
        this.finalizer = E;
      }
      register(E, Q) {
        E.on && E.on("disconnect", () => {
          E[e2] === 0 && E[A] === 0 && this.finalizer(Q);
        });
      }
      unregister(E) {}
    };
    o2(s2, "CompatFinalizer");
    let n = s2;
    return dispatcherWeakref = o2(function() {
      return process.env.NODE_V8_COVERAGE ? { WeakRef: t2, FinalizationRegistry: n } : { WeakRef, FinalizationRegistry };
    }, "dispatcherWeakref"), dispatcherWeakref;
  }
  o2(requireDispatcherWeakref, "requireDispatcherWeakref");
  var request;
  var hasRequiredRequest;
  function requireRequest() {
    if (hasRequiredRequest)
      return request;
    hasRequiredRequest = 1;
    const { extractBody: e2, mixinBody: A, cloneBody: t2 } = requireBody(), { Headers: n, fill: r, HeadersList: s2 } = requireHeaders(), { FinalizationRegistry: i2 } = requireDispatcherWeakref()(), E = util$m, Q = require$$0__default$1, { isValidHTTPToken: C, sameOrigin: I, normalizeMethod: a2, makePolicyContainer: f, normalizeMethodRecord: h2 } = requireUtil$5(), { forbiddenMethodsSet: L, corsSafeListedMethodsSet: c, referrerPolicy: l2, requestRedirect: S, requestMode: k, requestCredentials: w, requestCache: U, requestDuplex: M } = requireConstants$2(), { kEnumerableProperty: B } = E, { kHeaders: D, kSignal: G, kState: g, kGuard: d, kRealm: F, kDispatcher: N } = requireSymbols$3(), { webidl: u } = requireWebidl(), { getGlobalOrigin: b } = requireGlobal(), { URLSerializer: m } = requireDataUrl(), { kHeadersList: T, kConstruct: v } = symbols$4, Z = require$$0__default, { getMaxListeners: P, setMaxListeners: AA, getEventListeners: K, defaultMaxListeners: tA } = require$$0__default$3, aA = Symbol("abortController"), X = new i2(({ signal: gA, abort: BA }) => {
      gA.removeEventListener("abort", BA);
    });
    let $ = false;
    const iA = class iA2 {
      constructor(BA, sA = {}) {
        if (BA === v)
          return;
        u.argumentLengthCheck(arguments, 1, { header: "Request constructor" }), BA = u.converters.RequestInfo(BA), sA = u.converters.RequestInit(sA), this[F] = { settingsObject: { baseUrl: b(), get origin() {
          return this.baseUrl?.origin;
        }, policyContainer: f() } };
        let eA = null, yA = null;
        const WA = this[F].settingsObject.baseUrl;
        let wA = null;
        if (typeof BA == "string") {
          this[N] = sA.dispatcher;
          let IA;
          try {
            IA = new URL(BA, WA);
          } catch (hA) {
            throw new TypeError("Failed to parse URL from " + BA, { cause: hA });
          }
          if (IA.username || IA.password)
            throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + BA);
          eA = q({ urlList: [IA] }), yA = "cors";
        } else
          this[N] = sA.dispatcher || BA[N], Z(BA instanceof iA2), eA = BA[g], wA = BA[G];
        const qA = this[F].settingsObject.origin;
        let MA = "client";
        if (eA.window?.constructor?.name === "EnvironmentSettingsObject" && I(eA.window, qA) && (MA = eA.window), sA.window != null)
          throw new TypeError(`'window' option '${MA}' must be null`);
        "window" in sA && (MA = "no-window"), eA = q({ method: eA.method, headersList: eA.headersList, unsafeRequest: eA.unsafeRequest, client: this[F].settingsObject, window: MA, priority: eA.priority, origin: eA.origin, referrer: eA.referrer, referrerPolicy: eA.referrerPolicy, mode: eA.mode, credentials: eA.credentials, cache: eA.cache, redirect: eA.redirect, integrity: eA.integrity, keepalive: eA.keepalive, reloadNavigation: eA.reloadNavigation, historyNavigation: eA.historyNavigation, urlList: [...eA.urlList] });
        const HA = Object.keys(sA).length !== 0;
        if (HA && (eA.mode === "navigate" && (eA.mode = "same-origin"), eA.reloadNavigation = false, eA.historyNavigation = false, eA.origin = "client", eA.referrer = "client", eA.referrerPolicy = "", eA.url = eA.urlList[eA.urlList.length - 1], eA.urlList = [eA.url]), sA.referrer !== undefined) {
          const IA = sA.referrer;
          if (IA === "")
            eA.referrer = "no-referrer";
          else {
            let hA;
            try {
              hA = new URL(IA, WA);
            } catch (SA) {
              throw new TypeError(`Referrer "${IA}" is not a valid URL.`, { cause: SA });
            }
            hA.protocol === "about:" && hA.hostname === "client" || qA && !I(hA, this[F].settingsObject.baseUrl) ? eA.referrer = "client" : eA.referrer = hA;
          }
        }
        sA.referrerPolicy !== undefined && (eA.referrerPolicy = sA.referrerPolicy);
        let pA;
        if (sA.mode !== undefined ? pA = sA.mode : pA = yA, pA === "navigate")
          throw u.errors.exception({ header: "Request constructor", message: "invalid request mode navigate." });
        if (pA != null && (eA.mode = pA), sA.credentials !== undefined && (eA.credentials = sA.credentials), sA.cache !== undefined && (eA.cache = sA.cache), eA.cache === "only-if-cached" && eA.mode !== "same-origin")
          throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
        if (sA.redirect !== undefined && (eA.redirect = sA.redirect), sA.integrity != null && (eA.integrity = String(sA.integrity)), sA.keepalive !== undefined && (eA.keepalive = !!sA.keepalive), sA.method !== undefined) {
          let IA = sA.method;
          const hA = h2[IA];
          if (hA !== undefined)
            eA.method = hA;
          else {
            if (!C(IA))
              throw new TypeError(`'${IA}' is not a valid HTTP method.`);
            if (L.has(IA.toUpperCase()))
              throw new TypeError(`'${IA}' HTTP method is unsupported.`);
            IA = a2(IA), eA.method = IA;
          }
          !$ && eA.method === "patch" && (process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", { code: "UNDICI-FETCH-patch" }), $ = true);
        }
        sA.signal !== undefined && (wA = sA.signal), this[g] = eA;
        const YA = new AbortController;
        if (this[G] = YA.signal, this[G][F] = this[F], wA != null) {
          if (!wA || typeof wA.aborted != "boolean" || typeof wA.addEventListener != "function")
            throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
          if (wA.aborted)
            YA.abort(wA.reason);
          else {
            this[aA] = YA;
            const IA = new WeakRef(YA), hA = o2(function() {
              const SA = IA.deref();
              SA !== undefined && (X.unregister(hA), this.removeEventListener("abort", hA), SA.abort(this.reason));
            }, "abort");
            try {
              (typeof P == "function" && P(wA) === tA || K(wA, "abort").length >= tA) && AA(100, wA);
            } catch {}
            E.addAbortListener(wA, hA), X.register(YA, { signal: wA, abort: hA }, hA);
          }
        }
        if (this[D] = new n(v), this[D][T] = eA.headersList, this[D][d] = "request", this[D][F] = this[F], pA === "no-cors") {
          if (!c.has(eA.method))
            throw new TypeError(`'${eA.method} is unsupported in no-cors mode.`);
          this[D][d] = "request-no-cors";
        }
        if (HA) {
          const IA = this[D][T], hA = sA.headers !== undefined ? sA.headers : new s2(IA);
          if (IA.clear(), hA instanceof s2) {
            for (const [SA, PA] of hA)
              IA.append(SA, PA);
            IA.cookies = hA.cookies;
          } else
            r(this[D], hA);
        }
        const UA = BA instanceof iA2 ? BA[g].body : null;
        if ((sA.body != null || UA != null) && (eA.method === "GET" || eA.method === "HEAD"))
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        let JA = null;
        if (sA.body != null) {
          const [IA, hA] = e2(sA.body, eA.keepalive);
          JA = IA, hA && !this[D][T].contains("content-type", true) && this[D].append("content-type", hA);
        }
        const VA = JA ?? UA;
        if (VA != null && VA.source == null) {
          if (JA != null && sA.duplex == null)
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          if (eA.mode !== "same-origin" && eA.mode !== "cors")
            throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
          eA.useCORSPreflightFlag = true;
        }
        let OA = VA;
        if (JA == null && UA != null) {
          if (E.isDisturbed(UA.stream) || UA.stream.locked)
            throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
          const IA = new TransformStream;
          UA.stream.pipeThrough(IA), OA = { source: UA.source, length: UA.length, stream: IA.readable };
        }
        this[g].body = OA;
      }
      get method() {
        return u.brandCheck(this, iA2), this[g].method;
      }
      get url() {
        return u.brandCheck(this, iA2), m(this[g].url);
      }
      get headers() {
        return u.brandCheck(this, iA2), this[D];
      }
      get destination() {
        return u.brandCheck(this, iA2), this[g].destination;
      }
      get referrer() {
        return u.brandCheck(this, iA2), this[g].referrer === "no-referrer" ? "" : this[g].referrer === "client" ? "about:client" : this[g].referrer.toString();
      }
      get referrerPolicy() {
        return u.brandCheck(this, iA2), this[g].referrerPolicy;
      }
      get mode() {
        return u.brandCheck(this, iA2), this[g].mode;
      }
      get credentials() {
        return this[g].credentials;
      }
      get cache() {
        return u.brandCheck(this, iA2), this[g].cache;
      }
      get redirect() {
        return u.brandCheck(this, iA2), this[g].redirect;
      }
      get integrity() {
        return u.brandCheck(this, iA2), this[g].integrity;
      }
      get keepalive() {
        return u.brandCheck(this, iA2), this[g].keepalive;
      }
      get isReloadNavigation() {
        return u.brandCheck(this, iA2), this[g].reloadNavigation;
      }
      get isHistoryNavigation() {
        return u.brandCheck(this, iA2), this[g].historyNavigation;
      }
      get signal() {
        return u.brandCheck(this, iA2), this[G];
      }
      get body() {
        return u.brandCheck(this, iA2), this[g].body ? this[g].body.stream : null;
      }
      get bodyUsed() {
        return u.brandCheck(this, iA2), !!this[g].body && E.isDisturbed(this[g].body.stream);
      }
      get duplex() {
        return u.brandCheck(this, iA2), "half";
      }
      clone() {
        if (u.brandCheck(this, iA2), this.bodyUsed || this.body?.locked)
          throw new TypeError("unusable");
        const BA = z(this[g]), sA = new AbortController;
        return this.signal.aborted ? sA.abort(this.signal.reason) : E.addAbortListener(this.signal, () => {
          sA.abort(this.signal.reason);
        }), rA(BA, sA.signal, this[D][d], this[F]);
      }
      [Q.inspect.custom](BA, sA) {
        sA.depth === null && (sA.depth = 2), sA.colors ?? (sA.colors = true);
        const eA = { method: this.method, url: this.url, headers: this.headers, destination: this.destination, referrer: this.referrer, referrerPolicy: this.referrerPolicy, mode: this.mode, credentials: this.credentials, cache: this.cache, redirect: this.redirect, integrity: this.integrity, keepalive: this.keepalive, isReloadNavigation: this.isReloadNavigation, isHistoryNavigation: this.isHistoryNavigation, signal: this.signal };
        return `Request ${Q.formatWithOptions(sA, eA)}`;
      }
    };
    o2(iA, "Request");
    let V = iA;
    A(V);
    function q(gA) {
      const BA = { method: "GET", localURLsOnly: false, unsafeRequest: false, body: null, client: null, reservedClient: null, replacesClientId: "", window: "client", keepalive: false, serviceWorkers: "all", initiator: "", destination: "", priority: null, origin: "client", policyContainer: "client", referrer: "client", referrerPolicy: "", mode: "no-cors", useCORSPreflightFlag: false, credentials: "same-origin", useCredentials: false, cache: "default", redirect: "follow", integrity: "", cryptoGraphicsNonceMetadata: "", parserMetadata: "", reloadNavigation: false, historyNavigation: false, userActivation: false, taintedOrigin: false, redirectCount: 0, responseTainting: "basic", preventNoCacheCacheControlHeaderModification: false, done: false, timingAllowFailed: false, ...gA, headersList: gA.headersList ? new s2(gA.headersList) : new s2 };
      return BA.url = BA.urlList[0], BA;
    }
    o2(q, "makeRequest");
    function z(gA) {
      const BA = q({ ...gA, body: null });
      return gA.body != null && (BA.body = t2(gA.body)), BA;
    }
    o2(z, "cloneRequest");
    function rA(gA, BA, sA, eA) {
      const yA = new V(v);
      return yA[g] = gA, yA[F] = eA, yA[G] = BA, yA[G][F] = eA, yA[D] = new n(v), yA[D][T] = gA.headersList, yA[D][d] = sA, yA[D][F] = eA, yA;
    }
    return o2(rA, "fromInnerRequest"), Object.defineProperties(V.prototype, { method: B, url: B, headers: B, redirect: B, clone: B, signal: B, duplex: B, destination: B, body: B, bodyUsed: B, isHistoryNavigation: B, isReloadNavigation: B, keepalive: B, integrity: B, cache: B, credentials: B, attribute: B, referrerPolicy: B, referrer: B, mode: B, [Symbol.toStringTag]: { value: "Request", configurable: true } }), u.converters.Request = u.interfaceConverter(V), u.converters.RequestInfo = function(gA) {
      return typeof gA == "string" ? u.converters.USVString(gA) : gA instanceof V ? u.converters.Request(gA) : u.converters.USVString(gA);
    }, u.converters.AbortSignal = u.interfaceConverter(AbortSignal), u.converters.RequestInit = u.dictionaryConverter([{ key: "method", converter: u.converters.ByteString }, { key: "headers", converter: u.converters.HeadersInit }, { key: "body", converter: u.nullableConverter(u.converters.BodyInit) }, { key: "referrer", converter: u.converters.USVString }, { key: "referrerPolicy", converter: u.converters.DOMString, allowedValues: l2 }, { key: "mode", converter: u.converters.DOMString, allowedValues: k }, { key: "credentials", converter: u.converters.DOMString, allowedValues: w }, { key: "cache", converter: u.converters.DOMString, allowedValues: U }, { key: "redirect", converter: u.converters.DOMString, allowedValues: S }, { key: "integrity", converter: u.converters.DOMString }, { key: "keepalive", converter: u.converters.boolean }, { key: "signal", converter: u.nullableConverter((gA) => u.converters.AbortSignal(gA, { strict: false })) }, { key: "window", converter: u.converters.any }, { key: "duplex", converter: u.converters.DOMString, allowedValues: M }, { key: "dispatcher", converter: u.converters.any }]), request = { Request: V, makeRequest: q, fromInnerRequest: rA, cloneRequest: z }, request;
  }
  o2(requireRequest, "requireRequest");
  var fetch_1;
  var hasRequiredFetch;
  function requireFetch() {
    if (hasRequiredFetch)
      return fetch_1;
    hasRequiredFetch = 1;
    const { makeNetworkError: e2, makeAppropriateNetworkError: A, filterResponse: t2, makeResponse: n, fromInnerResponse: r } = requireResponse(), { HeadersList: s2 } = requireHeaders(), { Request: i2, cloneRequest: E } = requireRequest(), Q = zlib__default, { bytesMatch: C, makePolicyContainer: I, clonePolicyContainer: a2, requestBadPort: f, TAOCheck: h2, appendRequestOriginHeader: L, responseLocationURL: c, requestCurrentURL: l2, setRequestReferrerPolicyOnRedirect: S, tryUpgradeRequestToAPotentiallyTrustworthyURL: k, createOpaqueTimingInfo: w, appendFetchMetadata: U, corsCheck: M, crossOriginResourcePolicyCheck: B, determineRequestsReferrer: D, coarsenedSharedCurrentTime: G, createDeferredPromise: g, isBlobLike: d, sameOrigin: F, isCancelled: N, isAborted: u, isErrorLike: b, fullyReadBody: m, readableStreamClose: T, isomorphicEncode: v, urlIsLocal: Z, urlIsHttpHttpsScheme: P, urlHasHttpsScheme: AA, clampAndCoarsenConnectionTimingInfo: K, simpleRangeHeaderValue: tA, buildContentRange: aA, createInflate: X, extractMimeType: $ } = requireUtil$5(), { kState: V, kDispatcher: q } = requireSymbols$3(), z = require$$0__default, { safelyExtractBody: rA, extractBody: iA } = requireBody(), { redirectStatusSet: gA, nullBodyStatus: BA, safeMethodsSet: sA, requestBodyHeader: eA, subresourceSet: yA } = requireConstants$2(), WA = require$$0__default$3, { Readable: wA, pipeline: qA } = Stream__default, { addAbortListener: MA, isErrored: HA, isReadable: pA, nodeMajor: YA, nodeMinor: UA, bufferToLowerCasedHeaderName: JA } = util$m, { dataURLProcessor: VA, serializeAMimeType: OA, minimizeSupportedMimeType: IA } = requireDataUrl(), { getGlobalDispatcher: hA } = global2, { webidl: SA } = requireWebidl(), { STATUS_CODES: PA } = http__default, Pe = ["GET", "HEAD"], ee = typeof __UNDICI_IS_NODE__ < "u" || typeof esbuildDetection < "u" ? "node" : "undici";
    let ZA;
    const nA = class nA2 extends WA {
      constructor(O) {
        super(), this.dispatcher = O, this.connection = null, this.dump = false, this.state = "ongoing";
      }
      terminate(O) {
        this.state === "ongoing" && (this.state = "terminated", this.connection?.destroy(O), this.emit("terminated", O));
      }
      abort(O) {
        this.state === "ongoing" && (this.state = "aborted", O || (O = new DOMException("The operation was aborted.", "AbortError")), this.serializedAbortReason = O, this.connection?.destroy(O), this.emit("terminated", O));
      }
    };
    o2(nA, "Fetch");
    let XA = nA;
    function Ze(R, O = undefined) {
      SA.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      const H = g();
      let J;
      try {
        J = new i2(R, O);
      } catch (oA) {
        return H.reject(oA), H.promise;
      }
      const _ = J[V];
      if (J.signal.aborted)
        return te(H, _, null, J.signal.reason), H.promise;
      _.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope" && (_.serviceWorkers = "none");
      let QA = null;
      const lA = null;
      let uA = false, cA = null;
      return MA(J.signal, () => {
        uA = true, z(cA != null), cA.abort(J.signal.reason), te(H, _, QA, J.signal.reason);
      }), cA = Ve({ request: _, processResponseEndOfBody: o2((oA) => KA(oA, "fetch"), "handleFetchDone"), processResponse: o2((oA) => {
        if (!uA) {
          if (oA.aborted) {
            te(H, _, QA, cA.serializedAbortReason);
            return;
          }
          if (oA.type === "error") {
            H.reject(new TypeError("fetch failed", { cause: oA.error }));
            return;
          }
          QA = r(oA, "immutable", lA), H.resolve(QA);
        }
      }, "processResponse"), dispatcher: J[q] }), H.promise;
    }
    o2(Ze, "fetch");
    function KA(R, O = "other") {
      if (R.type === "error" && R.aborted || !R.urlList?.length)
        return;
      const H = R.urlList[0];
      let { timingInfo: J, cacheState: _ } = R;
      P(H) && J !== null && (R.timingAllowPassed || (J = w({ startTime: J.startTime }), _ = ""), J.endTime = G(), R.timingInfo = J, He(J, H.href, O, globalThis, _));
    }
    o2(KA, "finalizeAndReportTiming");
    const He = YA > 18 || YA === 18 && UA >= 2 ? performance.markResourceTiming : () => {};
    function te(R, O, H, J) {
      if (R.reject(J), O.body != null && pA(O.body?.stream) && O.body.stream.cancel(J).catch((x) => {
        if (x.code !== "ERR_INVALID_STATE")
          throw x;
      }), H == null)
        return;
      const _ = H[V];
      _.body != null && pA(_.body?.stream) && _.body.stream.cancel(J).catch((x) => {
        if (x.code !== "ERR_INVALID_STATE")
          throw x;
      });
    }
    o2(te, "abortFetch");
    function Ve({ request: R, processRequestBodyChunkLength: O, processRequestEndOfBody: H, processResponse: J, processResponseEndOfBody: _, processResponseConsumeBody: x, useParallelQueue: QA = false, dispatcher: lA = hA() }) {
      z(lA);
      let uA = null, cA = false;
      R.client != null && (uA = R.client.globalObject, cA = R.client.crossOriginIsolatedCapability);
      const fA = G(cA), mA = w({ startTime: fA }), oA = { controller: new XA(lA), request: R, timingInfo: mA, processRequestBodyChunkLength: O, processRequestEndOfBody: H, processResponse: J, processResponseConsumeBody: x, processResponseEndOfBody: _, taskDestination: uA, crossOriginIsolatedCapability: cA };
      return z(!R.body || R.body.stream), R.window === "client" && (R.window = R.client?.globalObject?.constructor?.name === "Window" ? R.client : "no-window"), R.origin === "client" && (R.origin = R.client?.origin), R.policyContainer === "client" && (R.client != null ? R.policyContainer = a2(R.client.policyContainer) : R.policyContainer = I()), R.headersList.contains("accept", true) || R.headersList.append("accept", "*/*", true), R.headersList.contains("accept-language", true) || R.headersList.append("accept-language", "*", true), R.priority, yA.has(R.destination), re(oA).catch((RA) => {
        oA.controller.terminate(RA);
      }), oA.controller;
    }
    o2(Ve, "fetching");
    async function re(R, O = false) {
      const H = R.request;
      let J = null;
      if (H.localURLsOnly && !Z(l2(H)) && (J = e2("local URLs only")), k(H), f(H) === "blocked" && (J = e2("bad port")), H.referrerPolicy === "" && (H.referrerPolicy = H.policyContainer.referrerPolicy), H.referrer !== "no-referrer" && (H.referrer = D(H)), J === null && (J = await (async () => {
        const x = l2(H);
        return F(x, H.url) && H.responseTainting === "basic" || x.protocol === "data:" || H.mode === "navigate" || H.mode === "websocket" ? (H.responseTainting = "basic", await ve(R)) : H.mode === "same-origin" ? e2('request mode cannot be "same-origin"') : H.mode === "no-cors" ? H.redirect !== "follow" ? e2('redirect mode cannot be "follow" for "no-cors" request') : (H.responseTainting = "opaque", await ve(R)) : P(l2(H)) ? (H.responseTainting = "cors", await y(R)) : e2("URL scheme must be a HTTP(S) scheme");
      })()), O)
        return J;
      J.status !== 0 && !J.internalResponse && (H.responseTainting, H.responseTainting === "basic" ? J = t2(J, "basic") : H.responseTainting === "cors" ? J = t2(J, "cors") : H.responseTainting === "opaque" ? J = t2(J, "opaque") : z(false));
      let _ = J.status === 0 ? J : J.internalResponse;
      if (_.urlList.length === 0 && _.urlList.push(...H.urlList), H.timingAllowFailed || (J.timingAllowPassed = true), J.type === "opaque" && _.status === 206 && _.rangeRequested && !H.headers.contains("range", true) && (J = _ = e2()), J.status !== 0 && (H.method === "HEAD" || H.method === "CONNECT" || BA.includes(_.status)) && (_.body = null, R.controller.dump = true), H.integrity) {
        const x = o2((lA) => vA(R, e2(lA)), "processBodyError");
        if (H.responseTainting === "opaque" || J.body == null) {
          x(J.error);
          return;
        }
        const QA = o2((lA) => {
          if (!C(lA, H.integrity)) {
            x("integrity mismatch");
            return;
          }
          J.body = rA(lA)[0], vA(R, J);
        }, "processBody");
        await m(J.body, QA, x);
      } else
        vA(R, J);
    }
    o2(re, "mainFetch");
    function ve(R) {
      if (N(R) && R.request.redirectCount === 0)
        return Promise.resolve(A(R));
      const { request: O } = R, { protocol: H } = l2(O);
      switch (H) {
        case "about:":
          return Promise.resolve(e2("about scheme is not supported"));
        case "blob:": {
          ZA || (ZA = require$$6__default.resolveObjectURL);
          const J = l2(O);
          if (J.search.length !== 0)
            return Promise.resolve(e2("NetworkError when attempting to fetch resource."));
          const _ = ZA(J.toString());
          if (O.method !== "GET" || !d(_))
            return Promise.resolve(e2("invalid method"));
          const x = n(), QA = _.size, lA = v(`${QA}`), uA = _.type;
          if (O.headersList.contains("range", true)) {
            x.rangeRequested = true;
            const cA = O.headersList.get("range", true), fA = tA(cA, true);
            if (fA === "failure")
              return Promise.resolve(e2("failed to fetch the data URL"));
            let { rangeStartValue: mA, rangeEndValue: oA } = fA;
            if (mA === null)
              mA = QA - oA, oA = mA + oA - 1;
            else {
              if (mA >= QA)
                return Promise.resolve(e2("Range start is greater than the blob's size."));
              (oA === null || oA >= QA) && (oA = QA - 1);
            }
            const RA = _.slice(mA, oA, uA), bA = iA(RA);
            x.body = bA[0];
            const dA = v(`${RA.size}`), GA = aA(mA, oA, QA);
            x.status = 206, x.statusText = "Partial Content", x.headersList.set("content-length", dA, true), x.headersList.set("content-type", uA, true), x.headersList.set("content-range", GA, true);
          } else {
            const cA = iA(_);
            x.statusText = "OK", x.body = cA[0], x.headersList.set("content-length", lA, true), x.headersList.set("content-type", uA, true);
          }
          return Promise.resolve(x);
        }
        case "data:": {
          const J = l2(O), _ = VA(J);
          if (_ === "failure")
            return Promise.resolve(e2("failed to fetch the data URL"));
          const x = OA(_.mimeType);
          return Promise.resolve(n({ statusText: "OK", headersList: [["content-type", { name: "Content-Type", value: x }]], body: rA(_.body)[0] }));
        }
        case "file:":
          return Promise.resolve(e2("not implemented... yet..."));
        case "http:":
        case "https:":
          return y(R).catch((J) => e2(J));
        default:
          return Promise.resolve(e2("unknown scheme"));
      }
    }
    o2(ve, "schemeFetch");
    function Xe(R, O) {
      R.request.done = true, R.processResponseDone != null && queueMicrotask(() => R.processResponseDone(O));
    }
    o2(Xe, "finalizeResponse");
    function vA(R, O) {
      let H = R.timingInfo;
      const J = o2(() => {
        const x = Date.now();
        R.request.destination === "document" && (R.controller.fullTimingInfo = H), R.controller.reportTimingSteps = () => {
          if (R.request.url.protocol !== "https:")
            return;
          H.endTime = x;
          let lA = O.cacheState;
          const uA = O.bodyInfo;
          O.timingAllowPassed || (H = w(H), lA = "");
          let cA = 0;
          if (R.request.mode !== "navigator" || !O.hasCrossOriginRedirects) {
            cA = O.status;
            const fA = $(O.headersList);
            fA !== "failure" && (uA.contentType = IA(fA));
          }
          R.request.initiatorType != null && He(H, R.request.url.href, R.request.initiatorType, globalThis, lA, uA, cA);
        };
        const QA = o2(() => {
          R.request.done = true, R.processResponseEndOfBody != null && queueMicrotask(() => R.processResponseEndOfBody(O)), R.request.initiatorType != null && R.controller.reportTimingSteps();
        }, "processResponseEndOfBodyTask");
        queueMicrotask(() => QA());
      }, "processResponseEndOfBody");
      R.processResponse != null && queueMicrotask(() => R.processResponse(O));
      const _ = O.type === "error" ? O : O.internalResponse ?? O;
      if (_.body == null)
        J();
      else {
        const x = new TransformStream({ start() {}, transform(lA, uA) {
          uA.enqueue(lA);
        }, flush: J });
        _.body.stream.pipeThrough(x);
        const QA = new ReadableStream({ readableStream: x.readable, async start() {
          this._bodyReader = this.readableStream.getReader();
        }, async pull(lA) {
          for (;lA.desiredSize >= 0; ) {
            const { done: uA, value: cA } = await this._bodyReader.read();
            if (uA) {
              queueMicrotask(() => T(lA));
              break;
            }
            lA.enqueue(cA);
          }
        }, type: "bytes" });
        _.body.stream = QA;
      }
    }
    o2(vA, "fetchFinale");
    async function y(R) {
      const O = R.request;
      let H = null, J = null;
      const _ = R.timingInfo;
      if (O.serviceWorkers, H === null) {
        if (O.redirect === "follow" && (O.serviceWorkers = "none"), J = H = await W(R), O.responseTainting === "cors" && M(O, H) === "failure")
          return e2("cors failure");
        h2(O, H) === "failure" && (O.timingAllowFailed = true);
      }
      return (O.responseTainting === "opaque" || H.type === "opaque") && B(O.origin, O.client, O.destination, J) === "blocked" ? e2("blocked") : (gA.has(J.status) && (O.redirect !== "manual" && R.controller.connection.destroy(undefined, false), O.redirect === "error" ? H = e2("unexpected redirect") : O.redirect === "manual" ? H = J : O.redirect === "follow" ? H = await Y(R, H) : z(false)), H.timingInfo = _, H);
    }
    o2(y, "httpFetch");
    function Y(R, O) {
      const H = R.request, J = O.internalResponse ? O.internalResponse : O;
      let _;
      try {
        if (_ = c(J, l2(H).hash), _ == null)
          return O;
      } catch (QA) {
        return Promise.resolve(e2(QA));
      }
      if (!P(_))
        return Promise.resolve(e2("URL scheme must be a HTTP(S) scheme"));
      if (H.redirectCount === 20)
        return Promise.resolve(e2("redirect count exceeded"));
      if (H.redirectCount += 1, H.mode === "cors" && (_.username || _.password) && !F(H, _))
        return Promise.resolve(e2('cross origin not allowed for request mode "cors"'));
      if (H.responseTainting === "cors" && (_.username || _.password))
        return Promise.resolve(e2('URL cannot contain credentials for request mode "cors"'));
      if (J.status !== 303 && H.body != null && H.body.source == null)
        return Promise.resolve(e2());
      if ([301, 302].includes(J.status) && H.method === "POST" || J.status === 303 && !Pe.includes(H.method)) {
        H.method = "GET", H.body = null;
        for (const QA of eA)
          H.headersList.delete(QA);
      }
      F(l2(H), _) || (H.headersList.delete("authorization", true), H.headersList.delete("proxy-authorization", true), H.headersList.delete("cookie", true), H.headersList.delete("host", true)), H.body != null && (z(H.body.source != null), H.body = rA(H.body.source)[0]);
      const x = R.timingInfo;
      return x.redirectEndTime = x.postRedirectStartTime = G(R.crossOriginIsolatedCapability), x.redirectStartTime === 0 && (x.redirectStartTime = x.startTime), H.urlList.push(_), S(H, J), re(R, true);
    }
    o2(Y, "httpRedirectFetch");
    async function W(R, O = false, H = false) {
      const J = R.request;
      let _ = null, x = null, QA = null;
      J.window === "no-window" && J.redirect === "error" ? (_ = R, x = J) : (x = E(J), _ = { ...R }, _.request = x);
      const lA = J.credentials === "include" || J.credentials === "same-origin" && J.responseTainting === "basic", uA = x.body ? x.body.length : null;
      let cA = null;
      if (x.body == null && ["POST", "PUT"].includes(x.method) && (cA = "0"), uA != null && (cA = v(`${uA}`)), cA != null && x.headersList.append("content-length", cA, true), uA != null && x.keepalive, x.referrer instanceof URL && x.headersList.append("referer", v(x.referrer.href), true), L(x), U(x), x.headersList.contains("user-agent", true) || x.headersList.append("user-agent", ee), x.cache === "default" && (x.headersList.contains("if-modified-since", true) || x.headersList.contains("if-none-match", true) || x.headersList.contains("if-unmodified-since", true) || x.headersList.contains("if-match", true) || x.headersList.contains("if-range", true)) && (x.cache = "no-store"), x.cache === "no-cache" && !x.preventNoCacheCacheControlHeaderModification && !x.headersList.contains("cache-control", true) && x.headersList.append("cache-control", "max-age=0", true), (x.cache === "no-store" || x.cache === "reload") && (x.headersList.contains("pragma", true) || x.headersList.append("pragma", "no-cache", true), x.headersList.contains("cache-control", true) || x.headersList.append("cache-control", "no-cache", true)), x.headersList.contains("range", true) && x.headersList.append("accept-encoding", "identity", true), x.headersList.contains("accept-encoding", true) || (AA(l2(x)) ? x.headersList.append("accept-encoding", "br, gzip, deflate", true) : x.headersList.append("accept-encoding", "gzip, deflate", true)), x.headersList.delete("host", true), x.cache = "no-store", x.mode !== "no-store" && x.mode, QA == null) {
        if (x.mode === "only-if-cached")
          return e2("only if cached");
        const fA = await j(_, lA, H);
        !sA.has(x.method) && fA.status >= 200 && fA.status <= 399, QA == null && (QA = fA);
      }
      if (QA.urlList = [...x.urlList], x.headersList.contains("range", true) && (QA.rangeRequested = true), QA.requestIncludesCredentials = lA, QA.status === 407)
        return J.window === "no-window" ? e2() : N(R) ? A(R) : e2("proxy authentication required");
      if (QA.status === 421 && !H && (J.body == null || J.body.source != null)) {
        if (N(R))
          return A(R);
        R.controller.connection.destroy(), QA = await W(R, O, true);
      }
      return QA;
    }
    o2(W, "httpNetworkOrCacheFetch");
    async function j(R, O = false, H = false) {
      z(!R.controller.connection || R.controller.connection.destroyed), R.controller.connection = { abort: null, destroyed: false, destroy(oA, RA = true) {
        this.destroyed || (this.destroyed = true, RA && this.abort?.(oA ?? new DOMException("The operation was aborted.", "AbortError")));
      } };
      const J = R.request;
      let _ = null;
      const x = R.timingInfo;
      J.cache = "no-store", J.mode;
      let QA = null;
      if (J.body == null && R.processRequestEndOfBody)
        queueMicrotask(() => R.processRequestEndOfBody());
      else if (J.body != null) {
        const oA = o2(async function* (dA) {
          N(R) || (yield dA, R.processRequestBodyChunkLength?.(dA.byteLength));
        }, "processBodyChunk"), RA = o2(() => {
          N(R) || R.processRequestEndOfBody && R.processRequestEndOfBody();
        }, "processEndOfBody"), bA = o2((dA) => {
          N(R) || (dA.name === "AbortError" ? R.controller.abort() : R.controller.terminate(dA));
        }, "processBodyError");
        QA = async function* () {
          try {
            for await (const dA of J.body.stream)
              yield* oA(dA);
            RA();
          } catch (dA) {
            bA(dA);
          }
        }();
      }
      try {
        const { body: oA, status: RA, statusText: bA, headersList: dA, socket: GA } = await mA({ body: QA });
        if (GA)
          _ = n({ status: RA, statusText: bA, headersList: dA, socket: GA });
        else {
          const DA = oA[Symbol.asyncIterator]();
          R.controller.next = () => DA.next(), _ = n({ status: RA, statusText: bA, headersList: dA });
        }
      } catch (oA) {
        return oA.name === "AbortError" ? (R.controller.connection.destroy(), A(R, oA)) : e2(oA);
      }
      const lA = o2(async () => {
        await R.controller.resume();
      }, "pullAlgorithm"), uA = o2((oA) => {
        R.controller.abort(oA);
      }, "cancelAlgorithm"), cA = new ReadableStream({ async start(oA) {
        R.controller.controller = oA;
      }, async pull(oA) {
        await lA();
      }, async cancel(oA) {
        await uA(oA);
      }, type: "bytes" });
      _.body = { stream: cA, source: null, length: null }, R.controller.onAborted = fA, R.controller.on("terminated", fA), R.controller.resume = async () => {
        for (;; ) {
          let oA, RA;
          try {
            const { done: dA, value: GA } = await R.controller.next();
            if (u(R))
              break;
            oA = dA ? undefined : GA;
          } catch (dA) {
            R.controller.ended && !x.encodedBodySize ? oA = undefined : (oA = dA, RA = true);
          }
          if (oA === undefined) {
            T(R.controller.controller), Xe(R, _);
            return;
          }
          if (x.decodedBodySize += oA?.byteLength ?? 0, RA) {
            R.controller.terminate(oA);
            return;
          }
          const bA = new Uint8Array(oA);
          if (bA.byteLength && R.controller.controller.enqueue(bA), HA(cA)) {
            R.controller.terminate();
            return;
          }
          if (R.controller.controller.desiredSize <= 0)
            return;
        }
      };
      function fA(oA) {
        u(R) ? (_.aborted = true, pA(cA) && R.controller.controller.error(R.controller.serializedAbortReason)) : pA(cA) && R.controller.controller.error(new TypeError("terminated", { cause: b(oA) ? oA : undefined })), R.controller.connection.destroy();
      }
      return o2(fA, "onAborted"), _;
      function mA({ body: oA }) {
        const RA = l2(J), bA = R.controller.dispatcher;
        return new Promise((dA, GA) => bA.dispatch({ path: RA.pathname + RA.search, origin: RA.origin, method: J.method, body: bA.isMockActive ? J.body && (J.body.source || J.body.stream) : oA, headers: J.headersList.entries, maxRedirections: 0, upgrade: J.mode === "websocket" ? "websocket" : undefined }, { body: null, abort: null, onConnect(DA) {
          const { connection: FA } = R.controller;
          x.finalConnectionTimingInfo = K(undefined, x.postRedirectStartTime, R.crossOriginIsolatedCapability), FA.destroyed ? DA(new DOMException("The operation was aborted.", "AbortError")) : (R.controller.on("terminated", DA), this.abort = FA.abort = DA), x.finalNetworkRequestStartTime = G(R.crossOriginIsolatedCapability);
        }, onResponseStarted() {
          x.finalNetworkResponseStartTime = G(R.crossOriginIsolatedCapability);
        }, onHeaders(DA, FA, Ke, xe) {
          if (DA < 200)
            return;
          let TA = [], ft = "";
          const We = new s2;
          if (Array.isArray(FA)) {
            for (let LA = 0;LA < FA.length; LA += 2)
              We.append(JA(FA[LA]), FA[LA + 1].toString("latin1"), true);
            const jA = We.get("content-encoding", true);
            jA && (TA = jA.toLowerCase().split(",").map((LA) => LA.trim())), ft = We.get("location", true);
          }
          this.body = new wA({ read: Ke });
          const zA = [], Nt = ft && J.redirect === "follow" && gA.has(DA);
          if (J.method !== "HEAD" && J.method !== "CONNECT" && !BA.includes(DA) && !Nt)
            for (let jA = 0;jA < TA.length; ++jA) {
              const LA = TA[jA];
              if (LA === "x-gzip" || LA === "gzip")
                zA.push(Q.createGunzip({ flush: Q.constants.Z_SYNC_FLUSH, finishFlush: Q.constants.Z_SYNC_FLUSH }));
              else if (LA === "deflate")
                zA.push(X());
              else if (LA === "br")
                zA.push(Q.createBrotliDecompress());
              else {
                zA.length = 0;
                break;
              }
            }
          return dA({ status: DA, statusText: xe, headersList: We, body: zA.length ? qA(this.body, ...zA, () => {}) : this.body.on("error", () => {}) }), true;
        }, onData(DA) {
          if (R.controller.dump)
            return;
          const FA = DA;
          return x.encodedBodySize += FA.byteLength, this.body.push(FA);
        }, onComplete() {
          this.abort && R.controller.off("terminated", this.abort), R.controller.onAborted && R.controller.off("terminated", R.controller.onAborted), R.controller.ended = true, this.body.push(null);
        }, onError(DA) {
          this.abort && R.controller.off("terminated", this.abort), this.body?.destroy(DA), R.controller.terminate(DA), GA(DA);
        }, onUpgrade(DA, FA, Ke) {
          if (DA !== 101)
            return;
          const xe = new s2;
          for (let TA = 0;TA < FA.length; TA += 2)
            xe.append(JA(FA[TA]), FA[TA + 1].toString("latin1"), true);
          return dA({ status: DA, statusText: PA[DA], headersList: xe, socket: Ke }), true;
        } }));
      }
      o2(mA, "dispatch");
    }
    return o2(j, "httpNetworkFetch"), fetch_1 = { fetch: Ze, Fetch: XA, fetching: Ve, finalizeAndReportTiming: KA }, fetch_1;
  }
  o2(requireFetch, "requireFetch");
  var symbols$2;
  var hasRequiredSymbols$2;
  function requireSymbols$2() {
    return hasRequiredSymbols$2 || (hasRequiredSymbols$2 = 1, symbols$2 = { kState: Symbol("FileReader state"), kResult: Symbol("FileReader result"), kError: Symbol("FileReader error"), kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"), kEvents: Symbol("FileReader events"), kAborted: Symbol("FileReader aborted") }), symbols$2;
  }
  o2(requireSymbols$2, "requireSymbols$2");
  var progressevent;
  var hasRequiredProgressevent;
  function requireProgressevent() {
    if (hasRequiredProgressevent)
      return progressevent;
    hasRequiredProgressevent = 1;
    const { webidl: e2 } = requireWebidl(), A = Symbol("ProgressEvent state"), n = class n2 extends Event {
      constructor(s2, i2 = {}) {
        s2 = e2.converters.DOMString(s2), i2 = e2.converters.ProgressEventInit(i2 ?? {}), super(s2, i2), this[A] = { lengthComputable: i2.lengthComputable, loaded: i2.loaded, total: i2.total };
      }
      get lengthComputable() {
        return e2.brandCheck(this, n2), this[A].lengthComputable;
      }
      get loaded() {
        return e2.brandCheck(this, n2), this[A].loaded;
      }
      get total() {
        return e2.brandCheck(this, n2), this[A].total;
      }
    };
    o2(n, "ProgressEvent");
    let t2 = n;
    return e2.converters.ProgressEventInit = e2.dictionaryConverter([{ key: "lengthComputable", converter: e2.converters.boolean, defaultValue: false }, { key: "loaded", converter: e2.converters["unsigned long long"], defaultValue: 0 }, { key: "total", converter: e2.converters["unsigned long long"], defaultValue: 0 }, { key: "bubbles", converter: e2.converters.boolean, defaultValue: false }, { key: "cancelable", converter: e2.converters.boolean, defaultValue: false }, { key: "composed", converter: e2.converters.boolean, defaultValue: false }]), progressevent = { ProgressEvent: t2 }, progressevent;
  }
  o2(requireProgressevent, "requireProgressevent");
  var encoding;
  var hasRequiredEncoding;
  function requireEncoding() {
    if (hasRequiredEncoding)
      return encoding;
    hasRequiredEncoding = 1;
    function e2(A) {
      if (!A)
        return "failure";
      switch (A.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    return o2(e2, "getEncoding"), encoding = { getEncoding: e2 }, encoding;
  }
  o2(requireEncoding, "requireEncoding");
  var util$5;
  var hasRequiredUtil$4;
  function requireUtil$4() {
    if (hasRequiredUtil$4)
      return util$5;
    hasRequiredUtil$4 = 1;
    const { kState: e2, kError: A, kResult: t2, kAborted: n, kLastProgressEventFired: r } = requireSymbols$2(), { ProgressEvent: s2 } = requireProgressevent(), { getEncoding: i2 } = requireEncoding(), { serializeAMimeType: E, parseMIMEType: Q } = requireDataUrl(), { types: C } = require$$0__default$1, { StringDecoder: I } = require$$5__default$2, { btoa: a2 } = require$$6__default, f = { enumerable: true, writable: false, configurable: false };
    function h2(w, U, M, B) {
      if (w[e2] === "loading")
        throw new DOMException("Invalid state", "InvalidStateError");
      w[e2] = "loading", w[t2] = null, w[A] = null;
      const G = U.stream().getReader(), g = [];
      let d = G.read(), F = true;
      (async () => {
        for (;!w[n]; )
          try {
            const { done: N, value: u } = await d;
            if (F && !w[n] && queueMicrotask(() => {
              L("loadstart", w);
            }), F = false, !N && C.isUint8Array(u))
              g.push(u), (w[r] === undefined || Date.now() - w[r] >= 50) && !w[n] && (w[r] = Date.now(), queueMicrotask(() => {
                L("progress", w);
              })), d = G.read();
            else if (N) {
              queueMicrotask(() => {
                w[e2] = "done";
                try {
                  const b = c(g, M, U.type, B);
                  if (w[n])
                    return;
                  w[t2] = b, L("load", w);
                } catch (b) {
                  w[A] = b, L("error", w);
                }
                w[e2] !== "loading" && L("loadend", w);
              });
              break;
            }
          } catch (N) {
            if (w[n])
              return;
            queueMicrotask(() => {
              w[e2] = "done", w[A] = N, L("error", w), w[e2] !== "loading" && L("loadend", w);
            });
            break;
          }
      })();
    }
    o2(h2, "readOperation");
    function L(w, U) {
      const M = new s2(w, { bubbles: false, cancelable: false });
      U.dispatchEvent(M);
    }
    o2(L, "fireAProgressEvent");
    function c(w, U, M, B) {
      switch (U) {
        case "DataURL": {
          let D = "data:";
          const G = Q(M || "application/octet-stream");
          G !== "failure" && (D += E(G)), D += ";base64,";
          const g = new I("latin1");
          for (const d of w)
            D += a2(g.write(d));
          return D += a2(g.end()), D;
        }
        case "Text": {
          let D = "failure";
          if (B && (D = i2(B)), D === "failure" && M) {
            const G = Q(M);
            G !== "failure" && (D = i2(G.parameters.get("charset")));
          }
          return D === "failure" && (D = "UTF-8"), l2(w, D);
        }
        case "ArrayBuffer":
          return k(w).buffer;
        case "BinaryString": {
          let D = "";
          const G = new I("latin1");
          for (const g of w)
            D += G.write(g);
          return D += G.end(), D;
        }
      }
    }
    o2(c, "packageData");
    function l2(w, U) {
      const M = k(w), B = S(M);
      let D = 0;
      B !== null && (U = B, D = B === "UTF-8" ? 3 : 2);
      const G = M.slice(D);
      return new TextDecoder(U).decode(G);
    }
    o2(l2, "decode");
    function S(w) {
      const [U, M, B] = w;
      return U === 239 && M === 187 && B === 191 ? "UTF-8" : U === 254 && M === 255 ? "UTF-16BE" : U === 255 && M === 254 ? "UTF-16LE" : null;
    }
    o2(S, "BOMSniffing");
    function k(w) {
      const U = w.reduce((B, D) => B + D.byteLength, 0);
      let M = 0;
      return w.reduce((B, D) => (B.set(D, M), M += D.byteLength, B), new Uint8Array(U));
    }
    return o2(k, "combineByteSequences"), util$5 = { staticPropertyDescriptors: f, readOperation: h2, fireAProgressEvent: L }, util$5;
  }
  o2(requireUtil$4, "requireUtil$4");
  var filereader;
  var hasRequiredFilereader;
  function requireFilereader() {
    if (hasRequiredFilereader)
      return filereader;
    hasRequiredFilereader = 1;
    const { staticPropertyDescriptors: e2, readOperation: A, fireAProgressEvent: t2 } = requireUtil$4(), { kState: n, kError: r, kResult: s2, kEvents: i2, kAborted: E } = requireSymbols$2(), { webidl: Q } = requireWebidl(), { kEnumerableProperty: C } = util$m, a2 = class a3 extends EventTarget {
      constructor() {
        super(), this[n] = "empty", this[s2] = null, this[r] = null, this[i2] = { loadend: null, error: null, abort: null, load: null, progress: null, loadstart: null };
      }
      readAsArrayBuffer(h2) {
        Q.brandCheck(this, a3), Q.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" }), h2 = Q.converters.Blob(h2, { strict: false }), A(this, h2, "ArrayBuffer");
      }
      readAsBinaryString(h2) {
        Q.brandCheck(this, a3), Q.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" }), h2 = Q.converters.Blob(h2, { strict: false }), A(this, h2, "BinaryString");
      }
      readAsText(h2, L = undefined) {
        Q.brandCheck(this, a3), Q.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" }), h2 = Q.converters.Blob(h2, { strict: false }), L !== undefined && (L = Q.converters.DOMString(L)), A(this, h2, "Text", L);
      }
      readAsDataURL(h2) {
        Q.brandCheck(this, a3), Q.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" }), h2 = Q.converters.Blob(h2, { strict: false }), A(this, h2, "DataURL");
      }
      abort() {
        if (this[n] === "empty" || this[n] === "done") {
          this[s2] = null;
          return;
        }
        this[n] === "loading" && (this[n] = "done", this[s2] = null), this[E] = true, t2("abort", this), this[n] !== "loading" && t2("loadend", this);
      }
      get readyState() {
        switch (Q.brandCheck(this, a3), this[n]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      get result() {
        return Q.brandCheck(this, a3), this[s2];
      }
      get error() {
        return Q.brandCheck(this, a3), this[r];
      }
      get onloadend() {
        return Q.brandCheck(this, a3), this[i2].loadend;
      }
      set onloadend(h2) {
        Q.brandCheck(this, a3), this[i2].loadend && this.removeEventListener("loadend", this[i2].loadend), typeof h2 == "function" ? (this[i2].loadend = h2, this.addEventListener("loadend", h2)) : this[i2].loadend = null;
      }
      get onerror() {
        return Q.brandCheck(this, a3), this[i2].error;
      }
      set onerror(h2) {
        Q.brandCheck(this, a3), this[i2].error && this.removeEventListener("error", this[i2].error), typeof h2 == "function" ? (this[i2].error = h2, this.addEventListener("error", h2)) : this[i2].error = null;
      }
      get onloadstart() {
        return Q.brandCheck(this, a3), this[i2].loadstart;
      }
      set onloadstart(h2) {
        Q.brandCheck(this, a3), this[i2].loadstart && this.removeEventListener("loadstart", this[i2].loadstart), typeof h2 == "function" ? (this[i2].loadstart = h2, this.addEventListener("loadstart", h2)) : this[i2].loadstart = null;
      }
      get onprogress() {
        return Q.brandCheck(this, a3), this[i2].progress;
      }
      set onprogress(h2) {
        Q.brandCheck(this, a3), this[i2].progress && this.removeEventListener("progress", this[i2].progress), typeof h2 == "function" ? (this[i2].progress = h2, this.addEventListener("progress", h2)) : this[i2].progress = null;
      }
      get onload() {
        return Q.brandCheck(this, a3), this[i2].load;
      }
      set onload(h2) {
        Q.brandCheck(this, a3), this[i2].load && this.removeEventListener("load", this[i2].load), typeof h2 == "function" ? (this[i2].load = h2, this.addEventListener("load", h2)) : this[i2].load = null;
      }
      get onabort() {
        return Q.brandCheck(this, a3), this[i2].abort;
      }
      set onabort(h2) {
        Q.brandCheck(this, a3), this[i2].abort && this.removeEventListener("abort", this[i2].abort), typeof h2 == "function" ? (this[i2].abort = h2, this.addEventListener("abort", h2)) : this[i2].abort = null;
      }
    };
    o2(a2, "FileReader");
    let I = a2;
    return I.EMPTY = I.prototype.EMPTY = 0, I.LOADING = I.prototype.LOADING = 1, I.DONE = I.prototype.DONE = 2, Object.defineProperties(I.prototype, { EMPTY: e2, LOADING: e2, DONE: e2, readAsArrayBuffer: C, readAsBinaryString: C, readAsText: C, readAsDataURL: C, abort: C, readyState: C, result: C, error: C, onloadstart: C, onprogress: C, onload: C, onabort: C, onerror: C, onloadend: C, [Symbol.toStringTag]: { value: "FileReader", writable: false, enumerable: false, configurable: true } }), Object.defineProperties(I, { EMPTY: e2, LOADING: e2, DONE: e2 }), filereader = { FileReader: I }, filereader;
  }
  o2(requireFilereader, "requireFilereader");
  var symbols$1;
  var hasRequiredSymbols$1;
  function requireSymbols$1() {
    return hasRequiredSymbols$1 || (hasRequiredSymbols$1 = 1, symbols$1 = { kConstruct: symbols$4.kConstruct }), symbols$1;
  }
  o2(requireSymbols$1, "requireSymbols$1");
  var util$4;
  var hasRequiredUtil$3;
  function requireUtil$3() {
    if (hasRequiredUtil$3)
      return util$4;
    hasRequiredUtil$3 = 1;
    const e2 = require$$0__default, { URLSerializer: A } = requireDataUrl(), { isValidHeaderName: t2 } = requireUtil$5();
    function n(s2, i2, E = false) {
      const Q = A(s2, E), C = A(i2, E);
      return Q === C;
    }
    o2(n, "urlEquals");
    function r(s2) {
      e2(s2 !== null);
      const i2 = [];
      for (let E of s2.split(","))
        E = E.trim(), t2(E) && i2.push(E);
      return i2;
    }
    return o2(r, "getFieldValues"), util$4 = { urlEquals: n, getFieldValues: r }, util$4;
  }
  o2(requireUtil$3, "requireUtil$3");
  var cache;
  var hasRequiredCache;
  function requireCache() {
    var w, U, qe, B, $A, G, wt, d, je;
    if (hasRequiredCache)
      return cache;
    hasRequiredCache = 1;
    const { kConstruct: e2 } = requireSymbols$1(), { urlEquals: A, getFieldValues: t2 } = requireUtil$3(), { kEnumerableProperty: n, isDisturbed: r } = util$m, { webidl: s2 } = requireWebidl(), { Response: i2, cloneResponse: E, fromInnerResponse: Q } = requireResponse(), { Request: C, fromInnerRequest: I } = requireRequest(), { kState: a2 } = requireSymbols$3(), { fetching: f } = requireFetch(), { urlIsHttpHttpsScheme: h2, createDeferredPromise: L, readAllBytes: c } = requireUtil$5(), l2 = require$$0__default, N = class N2 {
      constructor() {
        CA(this, U);
        CA(this, B);
        CA(this, G);
        CA(this, d);
        CA(this, w, undefined);
        arguments[0] !== e2 && s2.illegalConstructor(), EA(this, w, arguments[1]);
      }
      async match(b, m = {}) {
        s2.brandCheck(this, N2), s2.argumentLengthCheck(arguments, 1, { header: "Cache.match" }), b = s2.converters.RequestInfo(b), m = s2.converters.CacheQueryOptions(m);
        const T = kA(this, d, je).call(this, b, m, 1);
        if (T.length !== 0)
          return T[0];
      }
      async matchAll(b = undefined, m = {}) {
        return s2.brandCheck(this, N2), b !== undefined && (b = s2.converters.RequestInfo(b)), m = s2.converters.CacheQueryOptions(m), kA(this, d, je).call(this, b, m);
      }
      async add(b) {
        s2.brandCheck(this, N2), s2.argumentLengthCheck(arguments, 1, { header: "Cache.add" }), b = s2.converters.RequestInfo(b);
        const m = [b];
        return await this.addAll(m);
      }
      async addAll(b) {
        s2.brandCheck(this, N2), s2.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
        const m = [], T = [];
        for (let X of b) {
          if (X === undefined)
            throw s2.errors.conversionFailed({ prefix: "Cache.addAll", argument: "Argument 1", types: ["undefined is not allowed"] });
          if (X = s2.converters.RequestInfo(X), typeof X == "string")
            continue;
          const $ = X[a2];
          if (!h2($.url) || $.method !== "GET")
            throw s2.errors.exception({ header: "Cache.addAll", message: "Expected http/s scheme when method is not GET." });
        }
        const v = [];
        for (const X of b) {
          const $ = new C(X)[a2];
          if (!h2($.url))
            throw s2.errors.exception({ header: "Cache.addAll", message: "Expected http/s scheme." });
          $.initiator = "fetch", $.destination = "subresource", T.push($);
          const V = L();
          v.push(f({ request: $, processResponse(q) {
            if (q.type === "error" || q.status === 206 || q.status < 200 || q.status > 299)
              V.reject(s2.errors.exception({ header: "Cache.addAll", message: "Received an invalid status code or the request failed." }));
            else if (q.headersList.contains("vary")) {
              const z = t2(q.headersList.get("vary"));
              for (const rA of z)
                if (rA === "*") {
                  V.reject(s2.errors.exception({ header: "Cache.addAll", message: "invalid vary field value" }));
                  for (const iA of v)
                    iA.abort();
                  return;
                }
            }
          }, processResponseEndOfBody(q) {
            if (q.aborted) {
              V.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            V.resolve(q);
          } })), m.push(V.promise);
        }
        const P = await Promise.all(m), AA = [];
        let K = 0;
        for (const X of P) {
          const $ = { type: "put", request: T[K], response: X };
          AA.push($), K++;
        }
        const tA = L();
        let aA = null;
        try {
          kA(this, U, qe).call(this, AA);
        } catch (X) {
          aA = X;
        }
        return queueMicrotask(() => {
          aA === null ? tA.resolve(undefined) : tA.reject(aA);
        }), tA.promise;
      }
      async put(b, m) {
        s2.brandCheck(this, N2), s2.argumentLengthCheck(arguments, 2, { header: "Cache.put" }), b = s2.converters.RequestInfo(b), m = s2.converters.Response(m);
        let T = null;
        if (b instanceof C ? T = b[a2] : T = new C(b)[a2], !h2(T.url) || T.method !== "GET")
          throw s2.errors.exception({ header: "Cache.put", message: "Expected an http/s scheme when method is not GET" });
        const v = m[a2];
        if (v.status === 206)
          throw s2.errors.exception({ header: "Cache.put", message: "Got 206 status" });
        if (v.headersList.contains("vary")) {
          const $ = t2(v.headersList.get("vary"));
          for (const V of $)
            if (V === "*")
              throw s2.errors.exception({ header: "Cache.put", message: "Got * vary field value" });
        }
        if (v.body && (r(v.body.stream) || v.body.stream.locked))
          throw s2.errors.exception({ header: "Cache.put", message: "Response body is locked or disturbed" });
        const Z = E(v), P = L();
        if (v.body != null) {
          const V = v.body.stream.getReader();
          c(V).then(P.resolve, P.reject);
        } else
          P.resolve(undefined);
        const AA = [], K = { type: "put", request: T, response: Z };
        AA.push(K);
        const tA = await P.promise;
        Z.body != null && (Z.body.source = tA);
        const aA = L();
        let X = null;
        try {
          kA(this, U, qe).call(this, AA);
        } catch ($) {
          X = $;
        }
        return queueMicrotask(() => {
          X === null ? aA.resolve() : aA.reject(X);
        }), aA.promise;
      }
      async delete(b, m = {}) {
        s2.brandCheck(this, N2), s2.argumentLengthCheck(arguments, 1, { header: "Cache.delete" }), b = s2.converters.RequestInfo(b), m = s2.converters.CacheQueryOptions(m);
        let T = null;
        if (b instanceof C) {
          if (T = b[a2], T.method !== "GET" && !m.ignoreMethod)
            return false;
        } else
          l2(typeof b == "string"), T = new C(b)[a2];
        const v = [], Z = { type: "delete", request: T, options: m };
        v.push(Z);
        const P = L();
        let AA = null, K;
        try {
          K = kA(this, U, qe).call(this, v);
        } catch (tA) {
          AA = tA;
        }
        return queueMicrotask(() => {
          AA === null ? P.resolve(!!K?.length) : P.reject(AA);
        }), P.promise;
      }
      async keys(b = undefined, m = {}) {
        s2.brandCheck(this, N2), b !== undefined && (b = s2.converters.RequestInfo(b)), m = s2.converters.CacheQueryOptions(m);
        let T = null;
        if (b !== undefined)
          if (b instanceof C) {
            if (T = b[a2], T.method !== "GET" && !m.ignoreMethod)
              return [];
          } else
            typeof b == "string" && (T = new C(b)[a2]);
        const v = L(), Z = [];
        if (b === undefined)
          for (const P of p(this, w))
            Z.push(P[0]);
        else {
          const P = kA(this, B, $A).call(this, T, m);
          for (const AA of P)
            Z.push(AA[0]);
        }
        return queueMicrotask(() => {
          const P = [];
          for (const AA of Z) {
            const K = I(AA, new AbortController().signal, "immutable", { settingsObject: AA.client });
            P.push(K);
          }
          v.resolve(Object.freeze(P));
        }), v.promise;
      }
    };
    w = new WeakMap, U = new WeakSet, qe = o2(function(b) {
      const m = p(this, w), T = [...m], v = [], Z = [];
      try {
        for (const P of b) {
          if (P.type !== "delete" && P.type !== "put")
            throw s2.errors.exception({ header: "Cache.#batchCacheOperations", message: 'operation type does not match "delete" or "put"' });
          if (P.type === "delete" && P.response != null)
            throw s2.errors.exception({ header: "Cache.#batchCacheOperations", message: "delete operation should not have an associated response" });
          if (kA(this, B, $A).call(this, P.request, P.options, v).length)
            throw new DOMException("???", "InvalidStateError");
          let AA;
          if (P.type === "delete") {
            if (AA = kA(this, B, $A).call(this, P.request, P.options), AA.length === 0)
              return [];
            for (const K of AA) {
              const tA = m.indexOf(K);
              l2(tA !== -1), m.splice(tA, 1);
            }
          } else if (P.type === "put") {
            if (P.response == null)
              throw s2.errors.exception({ header: "Cache.#batchCacheOperations", message: "put operation should have an associated response" });
            const K = P.request;
            if (!h2(K.url))
              throw s2.errors.exception({ header: "Cache.#batchCacheOperations", message: "expected http or https scheme" });
            if (K.method !== "GET")
              throw s2.errors.exception({ header: "Cache.#batchCacheOperations", message: "not get method" });
            if (P.options != null)
              throw s2.errors.exception({ header: "Cache.#batchCacheOperations", message: "options must not be defined" });
            AA = kA(this, B, $A).call(this, P.request);
            for (const tA of AA) {
              const aA = m.indexOf(tA);
              l2(aA !== -1), m.splice(aA, 1);
            }
            m.push([P.request, P.response]), v.push([P.request, P.response]);
          }
          Z.push([P.request, P.response]);
        }
        return Z;
      } catch (P) {
        throw p(this, w).length = 0, EA(this, w, T), P;
      }
    }, "#batchCacheOperations"), B = new WeakSet, $A = o2(function(b, m, T) {
      const v = [], Z = T ?? p(this, w);
      for (const P of Z) {
        const [AA, K] = P;
        kA(this, G, wt).call(this, b, AA, K, m) && v.push(P);
      }
      return v;
    }, "#queryCache"), G = new WeakSet, wt = o2(function(b, m, T = null, v) {
      const Z = new URL(b.url), P = new URL(m.url);
      if (v?.ignoreSearch && (P.search = "", Z.search = ""), !A(Z, P, true))
        return false;
      if (T == null || v?.ignoreVary || !T.headersList.contains("vary"))
        return true;
      const AA = t2(T.headersList.get("vary"));
      for (const K of AA) {
        if (K === "*")
          return false;
        const tA = m.headersList.get(K), aA = b.headersList.get(K);
        if (tA !== aA)
          return false;
      }
      return true;
    }, "#requestMatchesCachedItem"), d = new WeakSet, je = o2(function(b, m, T = 1 / 0) {
      let v = null;
      if (b !== undefined)
        if (b instanceof C) {
          if (v = b[a2], v.method !== "GET" && !m.ignoreMethod)
            return [];
        } else
          typeof b == "string" && (v = new C(b)[a2]);
      const Z = [];
      if (b === undefined)
        for (const AA of p(this, w))
          Z.push(AA[1]);
      else {
        const AA = kA(this, B, $A).call(this, v, m);
        for (const K of AA)
          Z.push(K[1]);
      }
      const P = [];
      for (const AA of Z) {
        const K = Q(AA, "immutable", { settingsObject: {} });
        if (P.push(K.clone()), P.length >= T)
          break;
      }
      return Object.freeze(P);
    }, "#internalMatchAll"), o2(N, "Cache");
    let S = N;
    Object.defineProperties(S.prototype, { [Symbol.toStringTag]: { value: "Cache", configurable: true }, match: n, matchAll: n, add: n, addAll: n, put: n, delete: n, keys: n });
    const k = [{ key: "ignoreSearch", converter: s2.converters.boolean, defaultValue: false }, { key: "ignoreMethod", converter: s2.converters.boolean, defaultValue: false }, { key: "ignoreVary", converter: s2.converters.boolean, defaultValue: false }];
    return s2.converters.CacheQueryOptions = s2.dictionaryConverter(k), s2.converters.MultiCacheQueryOptions = s2.dictionaryConverter([...k, { key: "cacheName", converter: s2.converters.DOMString }]), s2.converters.Response = s2.interfaceConverter(i2), s2.converters["sequence<RequestInfo>"] = s2.sequenceConverter(s2.converters.RequestInfo), cache = { Cache: S }, cache;
  }
  o2(requireCache, "requireCache");
  var cachestorage;
  var hasRequiredCachestorage;
  function requireCachestorage() {
    var s2;
    if (hasRequiredCachestorage)
      return cachestorage;
    hasRequiredCachestorage = 1;
    const { kConstruct: e2 } = requireSymbols$1(), { Cache: A } = requireCache(), { webidl: t2 } = requireWebidl(), { kEnumerableProperty: n } = util$m, i2 = class i3 {
      constructor() {
        CA(this, s2, new Map);
        arguments[0] !== e2 && t2.illegalConstructor();
      }
      async match(Q, C = {}) {
        if (t2.brandCheck(this, i3), t2.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" }), Q = t2.converters.RequestInfo(Q), C = t2.converters.MultiCacheQueryOptions(C), C.cacheName != null) {
          if (p(this, s2).has(C.cacheName)) {
            const I = p(this, s2).get(C.cacheName);
            return await new A(e2, I).match(Q, C);
          }
        } else
          for (const I of p(this, s2).values()) {
            const f = await new A(e2, I).match(Q, C);
            if (f !== undefined)
              return f;
          }
      }
      async has(Q) {
        return t2.brandCheck(this, i3), t2.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" }), Q = t2.converters.DOMString(Q), p(this, s2).has(Q);
      }
      async open(Q) {
        if (t2.brandCheck(this, i3), t2.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" }), Q = t2.converters.DOMString(Q), p(this, s2).has(Q)) {
          const I = p(this, s2).get(Q);
          return new A(e2, I);
        }
        const C = [];
        return p(this, s2).set(Q, C), new A(e2, C);
      }
      async delete(Q) {
        return t2.brandCheck(this, i3), t2.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" }), Q = t2.converters.DOMString(Q), p(this, s2).delete(Q);
      }
      async keys() {
        return t2.brandCheck(this, i3), [...p(this, s2).keys()];
      }
    };
    s2 = new WeakMap, o2(i2, "CacheStorage");
    let r = i2;
    return Object.defineProperties(r.prototype, { [Symbol.toStringTag]: { value: "CacheStorage", configurable: true }, match: n, has: n, open: n, delete: n, keys: n }), cachestorage = { CacheStorage: r }, cachestorage;
  }
  o2(requireCachestorage, "requireCachestorage");
  var constants$1;
  var hasRequiredConstants$1;
  function requireConstants$1() {
    return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, constants$1 = { maxAttributeValueSize: 1024, maxNameValuePairSize: 4096 }), constants$1;
  }
  o2(requireConstants$1, "requireConstants$1");
  var util$3;
  var hasRequiredUtil$2;
  function requireUtil$2() {
    if (hasRequiredUtil$2)
      return util$3;
    hasRequiredUtil$2 = 1;
    const e2 = require$$0__default, { kHeadersList: A } = symbols$4;
    function t2(c) {
      for (let l2 = 0;l2 < c.length; ++l2) {
        const S = c.charCodeAt(l2);
        if (S >= 0 && S <= 8 || S >= 10 && S <= 31 || S === 127)
          return true;
      }
      return false;
    }
    o2(t2, "isCTLExcludingHtab");
    function n(c) {
      for (let l2 = 0;l2 < c.length; ++l2) {
        const S = c.charCodeAt(l2);
        if (S < 33 || S > 126 || S === 34 || S === 40 || S === 41 || S === 60 || S === 62 || S === 64 || S === 44 || S === 59 || S === 58 || S === 92 || S === 47 || S === 91 || S === 93 || S === 63 || S === 61 || S === 123 || S === 125)
          throw new Error("Invalid cookie name");
      }
    }
    o2(n, "validateCookieName");
    function r(c) {
      let l2 = c.length, S = 0;
      if (c[0] === '"') {
        if (l2 === 1 || c[l2 - 1] !== '"')
          throw new Error("Invalid cookie value");
        --l2, ++S;
      }
      for (;S < l2; ) {
        const k = c.charCodeAt(S++);
        if (k < 33 || k > 126 || k === 34 || k === 44 || k === 59 || k === 92)
          throw new Error("Invalid cookie value");
      }
    }
    o2(r, "validateCookieValue");
    function s2(c) {
      for (let l2 = 0;l2 < c.length; ++l2) {
        const S = c.charCodeAt(l2);
        if (S < 32 || S === 127 || S === 59)
          throw new Error("Invalid cookie path");
      }
    }
    o2(s2, "validateCookiePath");
    function i2(c) {
      if (c.startsWith("-") || c.endsWith(".") || c.endsWith("-"))
        throw new Error("Invalid cookie domain");
    }
    o2(i2, "validateCookieDomain");
    const E = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], Q = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], C = Array(61).fill(0).map((c, l2) => l2.toString().padStart(2, "0"));
    function I(c) {
      return typeof c == "number" && (c = new Date(c)), `${E[c.getUTCDay()]}, ${C[c.getUTCDate()]} ${Q[c.getUTCMonth()]} ${c.getUTCFullYear()} ${C[c.getUTCHours()]}:${C[c.getUTCMinutes()]}:${C[c.getUTCSeconds()]} GMT`;
    }
    o2(I, "toIMFDate");
    function a2(c) {
      if (c < 0)
        throw new Error("Invalid cookie max-age");
    }
    o2(a2, "validateCookieMaxAge");
    function f(c) {
      if (c.name.length === 0)
        return null;
      n(c.name), r(c.value);
      const l2 = [`${c.name}=${c.value}`];
      c.name.startsWith("__Secure-") && (c.secure = true), c.name.startsWith("__Host-") && (c.secure = true, c.domain = null, c.path = "/"), c.secure && l2.push("Secure"), c.httpOnly && l2.push("HttpOnly"), typeof c.maxAge == "number" && (a2(c.maxAge), l2.push(`Max-Age=${c.maxAge}`)), c.domain && (i2(c.domain), l2.push(`Domain=${c.domain}`)), c.path && (s2(c.path), l2.push(`Path=${c.path}`)), c.expires && c.expires.toString() !== "Invalid Date" && l2.push(`Expires=${I(c.expires)}`), c.sameSite && l2.push(`SameSite=${c.sameSite}`);
      for (const S of c.unparsed) {
        if (!S.includes("="))
          throw new Error("Invalid unparsed");
        const [k, ...w] = S.split("=");
        l2.push(`${k.trim()}=${w.join("=")}`);
      }
      return l2.join("; ");
    }
    o2(f, "stringify");
    let h2;
    function L(c) {
      if (c[A])
        return c[A];
      h2 || (h2 = Object.getOwnPropertySymbols(c).find((S) => S.description === "headers list"), e2(h2, "Headers cannot be parsed"));
      const l2 = c[h2];
      return e2(l2), l2;
    }
    return o2(L, "getHeadersList"), util$3 = { isCTLExcludingHtab: t2, validateCookieName: n, validateCookiePath: s2, validateCookieValue: r, toIMFDate: I, stringify: f, getHeadersList: L }, util$3;
  }
  o2(requireUtil$2, "requireUtil$2");
  var parse2;
  var hasRequiredParse;
  function requireParse() {
    if (hasRequiredParse)
      return parse2;
    hasRequiredParse = 1;
    const { maxNameValuePairSize: e2, maxAttributeValueSize: A } = requireConstants$1(), { isCTLExcludingHtab: t2 } = requireUtil$2(), { collectASequenceOfCodePointsFast: n } = requireDataUrl(), r = require$$0__default;
    function s2(E) {
      if (t2(E))
        return null;
      let Q = "", C = "", I = "", a2 = "";
      if (E.includes(";")) {
        const f = { position: 0 };
        Q = n(";", E, f), C = E.slice(f.position);
      } else
        Q = E;
      if (!Q.includes("="))
        a2 = Q;
      else {
        const f = { position: 0 };
        I = n("=", Q, f), a2 = Q.slice(f.position + 1);
      }
      return I = I.trim(), a2 = a2.trim(), I.length + a2.length > e2 ? null : { name: I, value: a2, ...i2(C) };
    }
    o2(s2, "parseSetCookie");
    function i2(E, Q = {}) {
      if (E.length === 0)
        return Q;
      r(E[0] === ";"), E = E.slice(1);
      let C = "";
      E.includes(";") ? (C = n(";", E, { position: 0 }), E = E.slice(C.length)) : (C = E, E = "");
      let I = "", a2 = "";
      if (C.includes("=")) {
        const h2 = { position: 0 };
        I = n("=", C, h2), a2 = C.slice(h2.position + 1);
      } else
        I = C;
      if (I = I.trim(), a2 = a2.trim(), a2.length > A)
        return i2(E, Q);
      const f = I.toLowerCase();
      if (f === "expires") {
        const h2 = new Date(a2);
        Q.expires = h2;
      } else if (f === "max-age") {
        const h2 = a2.charCodeAt(0);
        if ((h2 < 48 || h2 > 57) && a2[0] !== "-" || !/^\d+$/.test(a2))
          return i2(E, Q);
        const L = Number(a2);
        Q.maxAge = L;
      } else if (f === "domain") {
        let h2 = a2;
        h2[0] === "." && (h2 = h2.slice(1)), h2 = h2.toLowerCase(), Q.domain = h2;
      } else if (f === "path") {
        let h2 = "";
        a2.length === 0 || a2[0] !== "/" ? h2 = "/" : h2 = a2, Q.path = h2;
      } else if (f === "secure")
        Q.secure = true;
      else if (f === "httponly")
        Q.httpOnly = true;
      else if (f === "samesite") {
        let h2 = "Default";
        const L = a2.toLowerCase();
        L.includes("none") && (h2 = "None"), L.includes("strict") && (h2 = "Strict"), L.includes("lax") && (h2 = "Lax"), Q.sameSite = h2;
      } else
        Q.unparsed ?? (Q.unparsed = []), Q.unparsed.push(`${I}=${a2}`);
      return i2(E, Q);
    }
    return o2(i2, "parseUnparsedAttributes"), parse2 = { parseSetCookie: s2, parseUnparsedAttributes: i2 }, parse2;
  }
  o2(requireParse, "requireParse");
  var cookies;
  var hasRequiredCookies;
  function requireCookies() {
    if (hasRequiredCookies)
      return cookies;
    hasRequiredCookies = 1;
    const { parseSetCookie: e2 } = requireParse(), { stringify: A, getHeadersList: t2 } = requireUtil$2(), { webidl: n } = requireWebidl(), { Headers: r } = requireHeaders();
    function s2(C) {
      n.argumentLengthCheck(arguments, 1, { header: "getCookies" }), n.brandCheck(C, r, { strict: false });
      const I = C.get("cookie"), a2 = {};
      if (!I)
        return a2;
      for (const f of I.split(";")) {
        const [h2, ...L] = f.split("=");
        a2[h2.trim()] = L.join("=");
      }
      return a2;
    }
    o2(s2, "getCookies");
    function i2(C, I, a2) {
      n.argumentLengthCheck(arguments, 2, { header: "deleteCookie" }), n.brandCheck(C, r, { strict: false }), I = n.converters.DOMString(I), a2 = n.converters.DeleteCookieAttributes(a2), Q(C, { name: I, value: "", expires: new Date(0), ...a2 });
    }
    o2(i2, "deleteCookie");
    function E(C) {
      n.argumentLengthCheck(arguments, 1, { header: "getSetCookies" }), n.brandCheck(C, r, { strict: false });
      const I = t2(C).cookies;
      return I ? I.map((a2) => e2(Array.isArray(a2) ? a2[1] : a2)) : [];
    }
    o2(E, "getSetCookies");
    function Q(C, I) {
      n.argumentLengthCheck(arguments, 2, { header: "setCookie" }), n.brandCheck(C, r, { strict: false }), I = n.converters.Cookie(I);
      const a2 = A(I);
      a2 && C.append("Set-Cookie", a2);
    }
    return o2(Q, "setCookie"), n.converters.DeleteCookieAttributes = n.dictionaryConverter([{ converter: n.nullableConverter(n.converters.DOMString), key: "path", defaultValue: null }, { converter: n.nullableConverter(n.converters.DOMString), key: "domain", defaultValue: null }]), n.converters.Cookie = n.dictionaryConverter([{ converter: n.converters.DOMString, key: "name" }, { converter: n.converters.DOMString, key: "value" }, { converter: n.nullableConverter((C) => typeof C == "number" ? n.converters["unsigned long long"](C) : new Date(C)), key: "expires", defaultValue: null }, { converter: n.nullableConverter(n.converters["long long"]), key: "maxAge", defaultValue: null }, { converter: n.nullableConverter(n.converters.DOMString), key: "domain", defaultValue: null }, { converter: n.nullableConverter(n.converters.DOMString), key: "path", defaultValue: null }, { converter: n.nullableConverter(n.converters.boolean), key: "secure", defaultValue: null }, { converter: n.nullableConverter(n.converters.boolean), key: "httpOnly", defaultValue: null }, { converter: n.converters.USVString, key: "sameSite", allowedValues: ["Strict", "Lax", "None"] }, { converter: n.sequenceConverter(n.converters.DOMString), key: "unparsed", defaultValue: [] }]), cookies = { getCookies: s2, deleteCookie: i2, getSetCookies: E, setCookie: Q }, cookies;
  }
  o2(requireCookies, "requireCookies");
  var events;
  var hasRequiredEvents;
  function requireEvents() {
    var E, C, a2;
    if (hasRequiredEvents)
      return events;
    hasRequiredEvents = 1;
    const { webidl: e2 } = requireWebidl(), { kEnumerableProperty: A } = util$m, { MessagePort: t2 } = require$$2__default, Q = class Q2 extends Event {
      constructor(c, l2 = {}) {
        e2.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" }), c = e2.converters.DOMString(c), l2 = e2.converters.MessageEventInit(l2);
        super(c, l2);
        CA(this, E, undefined);
        EA(this, E, l2);
      }
      get data() {
        return e2.brandCheck(this, Q2), p(this, E).data;
      }
      get origin() {
        return e2.brandCheck(this, Q2), p(this, E).origin;
      }
      get lastEventId() {
        return e2.brandCheck(this, Q2), p(this, E).lastEventId;
      }
      get source() {
        return e2.brandCheck(this, Q2), p(this, E).source;
      }
      get ports() {
        return e2.brandCheck(this, Q2), Object.isFrozen(p(this, E).ports) || Object.freeze(p(this, E).ports), p(this, E).ports;
      }
      initMessageEvent(c, l2 = false, S = false, k = null, w = "", U = "", M = null, B = []) {
        return e2.brandCheck(this, Q2), e2.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" }), new Q2(c, { bubbles: l2, cancelable: S, data: k, origin: w, lastEventId: U, source: M, ports: B });
      }
    };
    E = new WeakMap, o2(Q, "MessageEvent");
    let n = Q;
    const I = class I2 extends Event {
      constructor(c, l2 = {}) {
        e2.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" }), c = e2.converters.DOMString(c), l2 = e2.converters.CloseEventInit(l2);
        super(c, l2);
        CA(this, C, undefined);
        EA(this, C, l2);
      }
      get wasClean() {
        return e2.brandCheck(this, I2), p(this, C).wasClean;
      }
      get code() {
        return e2.brandCheck(this, I2), p(this, C).code;
      }
      get reason() {
        return e2.brandCheck(this, I2), p(this, C).reason;
      }
    };
    C = new WeakMap, o2(I, "CloseEvent");
    let r = I;
    const f = class f2 extends Event {
      constructor(c, l2) {
        e2.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
        super(c, l2);
        CA(this, a2, undefined);
        c = e2.converters.DOMString(c), l2 = e2.converters.ErrorEventInit(l2 ?? {}), EA(this, a2, l2);
      }
      get message() {
        return e2.brandCheck(this, f2), p(this, a2).message;
      }
      get filename() {
        return e2.brandCheck(this, f2), p(this, a2).filename;
      }
      get lineno() {
        return e2.brandCheck(this, f2), p(this, a2).lineno;
      }
      get colno() {
        return e2.brandCheck(this, f2), p(this, a2).colno;
      }
      get error() {
        return e2.brandCheck(this, f2), p(this, a2).error;
      }
    };
    a2 = new WeakMap, o2(f, "ErrorEvent");
    let s2 = f;
    Object.defineProperties(n.prototype, { [Symbol.toStringTag]: { value: "MessageEvent", configurable: true }, data: A, origin: A, lastEventId: A, source: A, ports: A, initMessageEvent: A }), Object.defineProperties(r.prototype, { [Symbol.toStringTag]: { value: "CloseEvent", configurable: true }, reason: A, code: A, wasClean: A }), Object.defineProperties(s2.prototype, { [Symbol.toStringTag]: { value: "ErrorEvent", configurable: true }, message: A, filename: A, lineno: A, colno: A, error: A }), e2.converters.MessagePort = e2.interfaceConverter(t2), e2.converters["sequence<MessagePort>"] = e2.sequenceConverter(e2.converters.MessagePort);
    const i2 = [{ key: "bubbles", converter: e2.converters.boolean, defaultValue: false }, { key: "cancelable", converter: e2.converters.boolean, defaultValue: false }, { key: "composed", converter: e2.converters.boolean, defaultValue: false }];
    return e2.converters.MessageEventInit = e2.dictionaryConverter([...i2, { key: "data", converter: e2.converters.any, defaultValue: null }, { key: "origin", converter: e2.converters.USVString, defaultValue: "" }, { key: "lastEventId", converter: e2.converters.DOMString, defaultValue: "" }, { key: "source", converter: e2.nullableConverter(e2.converters.MessagePort), defaultValue: null }, { key: "ports", converter: e2.converters["sequence<MessagePort>"], get defaultValue() {
      return [];
    } }]), e2.converters.CloseEventInit = e2.dictionaryConverter([...i2, { key: "wasClean", converter: e2.converters.boolean, defaultValue: false }, { key: "code", converter: e2.converters["unsigned short"], defaultValue: 0 }, { key: "reason", converter: e2.converters.USVString, defaultValue: "" }]), e2.converters.ErrorEventInit = e2.dictionaryConverter([...i2, { key: "message", converter: e2.converters.DOMString, defaultValue: "" }, { key: "filename", converter: e2.converters.USVString, defaultValue: "" }, { key: "lineno", converter: e2.converters["unsigned long"], defaultValue: 0 }, { key: "colno", converter: e2.converters["unsigned long"], defaultValue: 0 }, { key: "error", converter: e2.converters.any }]), events = { MessageEvent: n, CloseEvent: r, ErrorEvent: s2 }, events;
  }
  o2(requireEvents, "requireEvents");
  var constants;
  var hasRequiredConstants;
  function requireConstants() {
    if (hasRequiredConstants)
      return constants;
    hasRequiredConstants = 1;
    const e2 = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", A = { enumerable: true, writable: false, configurable: false }, t2 = { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 }, n = { NOT_SENT: 0, PROCESSING: 1, SENT: 2 }, r = { CONTINUATION: 0, TEXT: 1, BINARY: 2, CLOSE: 8, PING: 9, PONG: 10 }, s2 = 2 ** 16 - 1, i2 = { INFO: 0, PAYLOADLENGTH_16: 2, PAYLOADLENGTH_64: 3, READ_DATA: 4 }, E = Buffer.allocUnsafe(0);
    return constants = { uid: e2, sentCloseFrameState: n, staticPropertyDescriptors: A, states: t2, opcodes: r, maxUnsigned16Bit: s2, parserStates: i2, emptyBuffer: E }, constants;
  }
  o2(requireConstants, "requireConstants");
  var symbols;
  var hasRequiredSymbols;
  function requireSymbols() {
    return hasRequiredSymbols || (hasRequiredSymbols = 1, symbols = { kWebSocketURL: Symbol("url"), kReadyState: Symbol("ready state"), kController: Symbol("controller"), kResponse: Symbol("response"), kBinaryType: Symbol("binary type"), kSentClose: Symbol("sent close"), kReceivedClose: Symbol("received close"), kByteParser: Symbol("byte parser") }), symbols;
  }
  o2(requireSymbols, "requireSymbols");
  var util$2;
  var hasRequiredUtil$1;
  function requireUtil$1() {
    if (hasRequiredUtil$1)
      return util$2;
    hasRequiredUtil$1 = 1;
    const { kReadyState: e2, kController: A, kResponse: t2, kBinaryType: n, kWebSocketURL: r } = requireSymbols(), { states: s2, opcodes: i2 } = requireConstants(), { MessageEvent: E, ErrorEvent: Q } = requireEvents(), { isUtf8: C } = require$$6__default;
    function I(B) {
      return B[e2] === s2.CONNECTING;
    }
    o2(I, "isConnecting");
    function a2(B) {
      return B[e2] === s2.OPEN;
    }
    o2(a2, "isEstablished");
    function f(B) {
      return B[e2] === s2.CLOSING;
    }
    o2(f, "isClosing");
    function h2(B) {
      return B[e2] === s2.CLOSED;
    }
    o2(h2, "isClosed");
    function L(B, D, G = Event, g = {}) {
      const d = new G(B, g);
      D.dispatchEvent(d);
    }
    o2(L, "fireEvent");
    function c(B, D, G) {
      if (B[e2] !== s2.OPEN)
        return;
      let g;
      if (D === i2.TEXT)
        try {
          g = M(G);
        } catch {
          k(B, "Received invalid UTF-8 in text frame.");
          return;
        }
      else
        D === i2.BINARY && (B[n] === "blob" ? g = new Blob([G]) : g = new Uint8Array(G).buffer);
      L("message", B, E, { origin: B[r].origin, data: g });
    }
    o2(c, "websocketMessageReceived");
    function l2(B) {
      if (B.length === 0)
        return false;
      for (let D = 0;D < B.length; ++D) {
        const G = B.charCodeAt(D);
        if (G < 33 || G > 126 || G === 34 || G === 40 || G === 41 || G === 44 || G === 47 || G === 58 || G === 59 || G === 60 || G === 61 || G === 62 || G === 63 || G === 64 || G === 91 || G === 92 || G === 93 || G === 123 || G === 125)
          return false;
      }
      return true;
    }
    o2(l2, "isValidSubprotocol");
    function S(B) {
      return B >= 1000 && B < 1015 ? B !== 1004 && B !== 1005 && B !== 1006 : B >= 3000 && B <= 4999;
    }
    o2(S, "isValidStatusCode");
    function k(B, D) {
      const { [A]: G, [t2]: g } = B;
      G.abort(), g?.socket && !g.socket.destroyed && g.socket.destroy(), D && L("error", B, Q, { error: new Error(D) });
    }
    o2(k, "failWebsocketConnection");
    const w = typeof process.versions.icu == "string", U = w ? new TextDecoder("utf-8", { fatal: true }) : undefined;
    function M(B) {
      if (w)
        return U.decode(B);
      if (!C?.(B))
        throw C || process.emitWarning("ICU is not supported and no fallback exists. Please upgrade to at least Node v18.14.0.", { code: "UNDICI-WS-NO-ICU" }), new TypeError("Invalid utf-8 received.");
      return B.toString("utf-8");
    }
    return o2(M, "utf8Decode"), util$2 = { isConnecting: I, isEstablished: a2, isClosing: f, isClosed: h2, fireEvent: L, isValidSubprotocol: l2, isValidStatusCode: S, failWebsocketConnection: k, websocketMessageReceived: c, utf8Decode: M }, util$2;
  }
  o2(requireUtil$1, "requireUtil$1");
  var connection;
  var hasRequiredConnection;
  function requireConnection() {
    if (hasRequiredConnection)
      return connection;
    hasRequiredConnection = 1;
    const { uid: e2, states: A, sentCloseFrameState: t2 } = requireConstants(), { kReadyState: n, kSentClose: r, kByteParser: s2, kReceivedClose: i2 } = requireSymbols(), { fireEvent: E, failWebsocketConnection: Q } = requireUtil$1(), { channels: C } = diagnostics, { CloseEvent: I } = requireEvents(), { makeRequest: a2 } = requireRequest(), { fetching: f } = requireFetch(), { Headers: h2 } = requireHeaders(), { getDecodeSplit: L } = requireUtil$5(), { kHeadersList: c } = symbols$4;
    let l2;
    try {
      l2 = __require("crypto");
    } catch {}
    function S(M, B, D, G, g) {
      const d = M;
      d.protocol = M.protocol === "ws:" ? "http:" : "https:";
      const F = a2({ urlList: [d], serviceWorkers: "none", referrer: "no-referrer", mode: "websocket", credentials: "include", cache: "no-store", redirect: "error" });
      if (g.headers) {
        const m = new h2(g.headers)[c];
        F.headersList = m;
      }
      const N = l2.randomBytes(16).toString("base64");
      F.headersList.append("sec-websocket-key", N), F.headersList.append("sec-websocket-version", "13");
      for (const m of B)
        F.headersList.append("sec-websocket-protocol", m);
      const u = "";
      return f({ request: F, useParallelQueue: true, dispatcher: g.dispatcher, processResponse(m) {
        if (m.type === "error" || m.status !== 101) {
          Q(D, "Received network error or non-101 status code.");
          return;
        }
        if (B.length !== 0 && !m.headersList.get("Sec-WebSocket-Protocol")) {
          Q(D, "Server did not respond with sent protocols.");
          return;
        }
        if (m.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          Q(D, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (m.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          Q(D, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const T = m.headersList.get("Sec-WebSocket-Accept"), v = l2.createHash("sha1").update(N + e2).digest("base64");
        if (T !== v) {
          Q(D, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const Z = m.headersList.get("Sec-WebSocket-Extensions");
        if (Z !== null && Z !== u) {
          Q(D, "Received different permessage-deflate than the one set.");
          return;
        }
        const P = m.headersList.get("Sec-WebSocket-Protocol");
        if (P !== null && !L("sec-websocket-protocol", F.headersList).includes(P)) {
          Q(D, "Protocol was not set in the opening handshake.");
          return;
        }
        m.socket.on("data", k), m.socket.on("close", w), m.socket.on("error", U), C.open.hasSubscribers && C.open.publish({ address: m.socket.address(), protocol: P, extensions: Z }), G(m);
      } });
    }
    o2(S, "establishWebSocketConnection");
    function k(M) {
      this.ws[s2].write(M) || this.pause();
    }
    o2(k, "onSocketData");
    function w() {
      const { ws: M } = this, B = M[r] === t2.SENT && M[i2];
      let D = 1005, G = "";
      const g = M[s2].closingInfo;
      g ? (D = g.code ?? 1005, G = g.reason) : M[r] !== t2.SENT && (D = 1006), M[n] = A.CLOSED, E("close", M, I, { wasClean: B, code: D, reason: G }), C.close.hasSubscribers && C.close.publish({ websocket: M, code: D, reason: G });
    }
    o2(w, "onSocketClose");
    function U(M) {
      const { ws: B } = this;
      B[n] = A.CLOSING, C.socketError.hasSubscribers && C.socketError.publish(M), this.destroy();
    }
    return o2(U, "onSocketError"), connection = { establishWebSocketConnection: S }, connection;
  }
  o2(requireConnection, "requireConnection");
  var frame;
  var hasRequiredFrame;
  function requireFrame() {
    if (hasRequiredFrame)
      return frame;
    hasRequiredFrame = 1;
    const { maxUnsigned16Bit: e2 } = requireConstants();
    let A;
    try {
      A = __require("crypto");
    } catch {}
    const n = class n2 {
      constructor(s2) {
        this.frameData = s2, this.maskKey = A.randomBytes(4);
      }
      createFrame(s2) {
        const i2 = this.frameData?.byteLength ?? 0;
        let E = i2, Q = 6;
        i2 > e2 ? (Q += 8, E = 127) : i2 > 125 && (Q += 2, E = 126);
        const C = Buffer.allocUnsafe(i2 + Q);
        C[0] = C[1] = 0, C[0] |= 128, C[0] = (C[0] & 240) + s2;
        /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
        C[Q - 4] = this.maskKey[0], C[Q - 3] = this.maskKey[1], C[Q - 2] = this.maskKey[2], C[Q - 1] = this.maskKey[3], C[1] = E, E === 126 ? C.writeUInt16BE(i2, 2) : E === 127 && (C[2] = C[3] = 0, C.writeUIntBE(i2, 4, 6)), C[1] |= 128;
        for (let I = 0;I < i2; I++)
          C[Q + I] = this.frameData[I] ^ this.maskKey[I % 4];
        return C;
      }
    };
    o2(n, "WebsocketFrameSend");
    let t2 = n;
    return frame = { WebsocketFrameSend: t2 }, frame;
  }
  o2(requireFrame, "requireFrame");
  var receiver;
  var hasRequiredReceiver;
  function requireReceiver() {
    var S, k, w, U, M;
    if (hasRequiredReceiver)
      return receiver;
    hasRequiredReceiver = 1;
    const { Writable: e2 } = Stream__default, { parserStates: A, opcodes: t2, states: n, emptyBuffer: r, sentCloseFrameState: s2 } = requireConstants(), { kReadyState: i2, kSentClose: E, kResponse: Q, kReceivedClose: C } = requireSymbols(), { channels: I } = diagnostics, { isValidStatusCode: a2, failWebsocketConnection: f, websocketMessageReceived: h2, utf8Decode: L } = requireUtil$1(), { WebsocketFrameSend: c } = requireFrame(), B = class B2 extends e2 {
      constructor(g) {
        super();
        CA(this, S, []);
        CA(this, k, 0);
        CA(this, w, A.INFO);
        CA(this, U, {});
        CA(this, M, []);
        this.ws = g;
      }
      _write(g, d, F) {
        p(this, S).push(g), EA(this, k, p(this, k) + g.length), this.run(F);
      }
      run(g) {
        var d;
        for (;; ) {
          if (p(this, w) === A.INFO) {
            if (p(this, k) < 2)
              return g();
            const F = this.consume(2);
            if (p(this, U).fin = (F[0] & 128) !== 0, p(this, U).opcode = F[0] & 15, (d = p(this, U)).originalOpcode ?? (d.originalOpcode = p(this, U).opcode), p(this, U).fragmented = !p(this, U).fin && p(this, U).opcode !== t2.CONTINUATION, p(this, U).fragmented && p(this, U).opcode !== t2.BINARY && p(this, U).opcode !== t2.TEXT) {
              f(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            const N = F[1] & 127;
            if (N <= 125 ? (p(this, U).payloadLength = N, EA(this, w, A.READ_DATA)) : N === 126 ? EA(this, w, A.PAYLOADLENGTH_16) : N === 127 && EA(this, w, A.PAYLOADLENGTH_64), p(this, U).fragmented && N > 125) {
              f(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((p(this, U).opcode === t2.PING || p(this, U).opcode === t2.PONG || p(this, U).opcode === t2.CLOSE) && N > 125) {
              f(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (p(this, U).opcode === t2.CLOSE) {
              if (N === 1) {
                f(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              const u = this.consume(N);
              if (p(this, U).closeInfo = this.parseCloseBody(u), this.ws[E] !== s2.SENT) {
                let b = r;
                p(this, U).closeInfo.code && (b = Buffer.allocUnsafe(2), b.writeUInt16BE(p(this, U).closeInfo.code, 0));
                const m = new c(b);
                this.ws[Q].socket.write(m.createFrame(t2.CLOSE), (T) => {
                  T || (this.ws[E] = s2.SENT);
                });
              }
              this.ws[i2] = n.CLOSING, this.ws[C] = true, this.end();
              return;
            } else if (p(this, U).opcode === t2.PING) {
              const u = this.consume(N);
              if (!this.ws[C]) {
                const b = new c(u);
                this.ws[Q].socket.write(b.createFrame(t2.PONG)), I.ping.hasSubscribers && I.ping.publish({ payload: u });
              }
              if (EA(this, w, A.INFO), p(this, k) > 0)
                continue;
              g();
              return;
            } else if (p(this, U).opcode === t2.PONG) {
              const u = this.consume(N);
              if (I.pong.hasSubscribers && I.pong.publish({ payload: u }), p(this, k) > 0)
                continue;
              g();
              return;
            }
          } else if (p(this, w) === A.PAYLOADLENGTH_16) {
            if (p(this, k) < 2)
              return g();
            const F = this.consume(2);
            p(this, U).payloadLength = F.readUInt16BE(0), EA(this, w, A.READ_DATA);
          } else if (p(this, w) === A.PAYLOADLENGTH_64) {
            if (p(this, k) < 8)
              return g();
            const F = this.consume(8), N = F.readUInt32BE(0);
            if (N > 2 ** 31 - 1) {
              f(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const u = F.readUInt32BE(4);
            p(this, U).payloadLength = (N << 8) + u, EA(this, w, A.READ_DATA);
          } else if (p(this, w) === A.READ_DATA) {
            if (p(this, k) < p(this, U).payloadLength)
              return g();
            if (p(this, k) >= p(this, U).payloadLength) {
              const F = this.consume(p(this, U).payloadLength);
              if (p(this, M).push(F), !p(this, U).fragmented || p(this, U).fin && p(this, U).opcode === t2.CONTINUATION) {
                const N = Buffer.concat(p(this, M));
                h2(this.ws, p(this, U).originalOpcode, N), EA(this, U, {}), p(this, M).length = 0;
              }
              EA(this, w, A.INFO);
            }
          }
          if (p(this, k) === 0) {
            g();
            break;
          }
        }
      }
      consume(g) {
        if (g > p(this, k))
          return null;
        if (g === 0)
          return r;
        if (p(this, S)[0].length === g)
          return EA(this, k, p(this, k) - p(this, S)[0].length), p(this, S).shift();
        const d = Buffer.allocUnsafe(g);
        let F = 0;
        for (;F !== g; ) {
          const N = p(this, S)[0], { length: u } = N;
          if (u + F === g) {
            d.set(p(this, S).shift(), F);
            break;
          } else if (u + F > g) {
            d.set(N.subarray(0, g - F), F), p(this, S)[0] = N.subarray(g - F);
            break;
          } else
            d.set(p(this, S).shift(), F), F += N.length;
        }
        return EA(this, k, p(this, k) - g), d;
      }
      parseCloseBody(g) {
        let d;
        g.length >= 2 && (d = g.readUInt16BE(0));
        let F = g.subarray(2);
        if (F[0] === 239 && F[1] === 187 && F[2] === 191 && (F = F.subarray(3)), d !== undefined && !a2(d))
          return null;
        try {
          F = L(F);
        } catch {
          return null;
        }
        return { code: d, reason: F };
      }
      get closingInfo() {
        return p(this, U).closeInfo;
      }
    };
    S = new WeakMap, k = new WeakMap, w = new WeakMap, U = new WeakMap, M = new WeakMap, o2(B, "ByteParser");
    let l2 = B;
    return receiver = { ByteParser: l2 }, receiver;
  }
  o2(requireReceiver, "requireReceiver");
  var websocket2;
  var hasRequiredWebsocket;
  function requireWebsocket() {
    var m, T, v, Z, P, kt;
    if (hasRequiredWebsocket)
      return websocket2;
    hasRequiredWebsocket = 1;
    const { webidl: e2 } = requireWebidl(), { URLSerializer: A } = requireDataUrl(), { getGlobalOrigin: t2 } = requireGlobal(), { staticPropertyDescriptors: n, states: r, sentCloseFrameState: s2, opcodes: i2, emptyBuffer: E } = requireConstants(), { kWebSocketURL: Q, kReadyState: C, kController: I, kBinaryType: a2, kResponse: f, kSentClose: h2, kByteParser: L } = requireSymbols(), { isConnecting: c, isEstablished: l2, isClosed: S, isClosing: k, isValidSubprotocol: w, failWebsocketConnection: U, fireEvent: M } = requireUtil$1(), { establishWebSocketConnection: B } = requireConnection(), { WebsocketFrameSend: D } = requireFrame(), { ByteParser: G } = requireReceiver(), { kEnumerableProperty: g, isBlobLike: d } = util$m, { getGlobalDispatcher: F } = global2, { types: N } = require$$0__default$1;
    let u = false;
    const K = class K2 extends EventTarget {
      constructor(X, $ = []) {
        super();
        CA(this, P);
        CA(this, m, { open: null, error: null, close: null, message: null });
        CA(this, T, 0);
        CA(this, v, "");
        CA(this, Z, "");
        e2.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" }), u || (u = true, process.emitWarning("WebSockets are experimental, expect them to change at any time.", { code: "UNDICI-WS" }));
        const V = e2.converters["DOMString or sequence<DOMString> or WebSocketInit"]($);
        X = e2.converters.USVString(X), $ = V.protocols;
        const q = t2();
        let z;
        try {
          z = new URL(X, q);
        } catch (rA) {
          throw new DOMException(rA, "SyntaxError");
        }
        if (z.protocol === "http:" ? z.protocol = "ws:" : z.protocol === "https:" && (z.protocol = "wss:"), z.protocol !== "ws:" && z.protocol !== "wss:")
          throw new DOMException(`Expected a ws: or wss: protocol, got ${z.protocol}`, "SyntaxError");
        if (z.hash || z.href.endsWith("#"))
          throw new DOMException("Got fragment", "SyntaxError");
        if (typeof $ == "string" && ($ = [$]), $.length !== new Set($.map((rA) => rA.toLowerCase())).size)
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        if ($.length > 0 && !$.every((rA) => w(rA)))
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        this[Q] = new URL(z.href), this[I] = B(z, $, this, (rA) => kA(this, P, kt).call(this, rA), V), this[C] = K2.CONNECTING, this[h2] = s2.NOT_SENT, this[a2] = "blob";
      }
      close(X = undefined, $ = undefined) {
        if (e2.brandCheck(this, K2), X !== undefined && (X = e2.converters["unsigned short"](X, { clamp: true })), $ !== undefined && ($ = e2.converters.USVString($)), X !== undefined && X !== 1000 && (X < 3000 || X > 4999))
          throw new DOMException("invalid code", "InvalidAccessError");
        let V = 0;
        if ($ !== undefined && (V = Buffer.byteLength($), V > 123))
          throw new DOMException(`Reason must be less than 123 bytes; received ${V}`, "SyntaxError");
        if (!(k(this) || S(this)))
          if (!l2(this))
            U(this, "Connection was closed before it was established."), this[C] = K2.CLOSING;
          else if (this[h2] === s2.NOT_SENT) {
            this[h2] = s2.PROCESSING;
            const q = new D;
            X !== undefined && $ === undefined ? (q.frameData = Buffer.allocUnsafe(2), q.frameData.writeUInt16BE(X, 0)) : X !== undefined && $ !== undefined ? (q.frameData = Buffer.allocUnsafe(2 + V), q.frameData.writeUInt16BE(X, 0), q.frameData.write($, 2, "utf-8")) : q.frameData = E, this[f].socket.write(q.createFrame(i2.CLOSE), (rA) => {
              rA || (this[h2] = s2.SENT);
            }), this[C] = r.CLOSING;
          } else
            this[C] = K2.CLOSING;
      }
      send(X) {
        if (e2.brandCheck(this, K2), e2.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" }), X = e2.converters.WebSocketSendData(X), c(this))
          throw new DOMException("Sent before connected.", "InvalidStateError");
        if (!l2(this) || k(this))
          return;
        const $ = this[f].socket;
        if (typeof X == "string") {
          const V = Buffer.from(X), z = new D(V).createFrame(i2.TEXT);
          EA(this, T, p(this, T) + V.byteLength), $.write(z, () => {
            EA(this, T, p(this, T) - V.byteLength);
          });
        } else if (N.isArrayBuffer(X)) {
          const V = Buffer.from(X), z = new D(V).createFrame(i2.BINARY);
          EA(this, T, p(this, T) + V.byteLength), $.write(z, () => {
            EA(this, T, p(this, T) - V.byteLength);
          });
        } else if (ArrayBuffer.isView(X)) {
          const V = Buffer.from(X, X.byteOffset, X.byteLength), z = new D(V).createFrame(i2.BINARY);
          EA(this, T, p(this, T) + V.byteLength), $.write(z, () => {
            EA(this, T, p(this, T) - V.byteLength);
          });
        } else if (d(X)) {
          const V = new D;
          X.arrayBuffer().then((q) => {
            const z = Buffer.from(q);
            V.frameData = z;
            const rA = V.createFrame(i2.BINARY);
            EA(this, T, p(this, T) + z.byteLength), $.write(rA, () => {
              EA(this, T, p(this, T) - z.byteLength);
            });
          });
        }
      }
      get readyState() {
        return e2.brandCheck(this, K2), this[C];
      }
      get bufferedAmount() {
        return e2.brandCheck(this, K2), p(this, T);
      }
      get url() {
        return e2.brandCheck(this, K2), A(this[Q]);
      }
      get extensions() {
        return e2.brandCheck(this, K2), p(this, Z);
      }
      get protocol() {
        return e2.brandCheck(this, K2), p(this, v);
      }
      get onopen() {
        return e2.brandCheck(this, K2), p(this, m).open;
      }
      set onopen(X) {
        e2.brandCheck(this, K2), p(this, m).open && this.removeEventListener("open", p(this, m).open), typeof X == "function" ? (p(this, m).open = X, this.addEventListener("open", X)) : p(this, m).open = null;
      }
      get onerror() {
        return e2.brandCheck(this, K2), p(this, m).error;
      }
      set onerror(X) {
        e2.brandCheck(this, K2), p(this, m).error && this.removeEventListener("error", p(this, m).error), typeof X == "function" ? (p(this, m).error = X, this.addEventListener("error", X)) : p(this, m).error = null;
      }
      get onclose() {
        return e2.brandCheck(this, K2), p(this, m).close;
      }
      set onclose(X) {
        e2.brandCheck(this, K2), p(this, m).close && this.removeEventListener("close", p(this, m).close), typeof X == "function" ? (p(this, m).close = X, this.addEventListener("close", X)) : p(this, m).close = null;
      }
      get onmessage() {
        return e2.brandCheck(this, K2), p(this, m).message;
      }
      set onmessage(X) {
        e2.brandCheck(this, K2), p(this, m).message && this.removeEventListener("message", p(this, m).message), typeof X == "function" ? (p(this, m).message = X, this.addEventListener("message", X)) : p(this, m).message = null;
      }
      get binaryType() {
        return e2.brandCheck(this, K2), this[a2];
      }
      set binaryType(X) {
        e2.brandCheck(this, K2), X !== "blob" && X !== "arraybuffer" ? this[a2] = "blob" : this[a2] = X;
      }
    };
    m = new WeakMap, T = new WeakMap, v = new WeakMap, Z = new WeakMap, P = new WeakSet, kt = o2(function(X) {
      this[f] = X;
      const $ = new G(this);
      $.on("drain", o2(function() {
        this.ws[f].socket.resume();
      }, "onParserDrain")), X.socket.ws = this, this[L] = $, this[C] = r.OPEN;
      const V = X.headersList.get("sec-websocket-extensions");
      V !== null && EA(this, Z, V);
      const q = X.headersList.get("sec-websocket-protocol");
      q !== null && EA(this, v, q), M("open", this);
    }, "#onConnectionEstablished"), o2(K, "WebSocket");
    let b = K;
    return b.CONNECTING = b.prototype.CONNECTING = r.CONNECTING, b.OPEN = b.prototype.OPEN = r.OPEN, b.CLOSING = b.prototype.CLOSING = r.CLOSING, b.CLOSED = b.prototype.CLOSED = r.CLOSED, Object.defineProperties(b.prototype, { CONNECTING: n, OPEN: n, CLOSING: n, CLOSED: n, url: g, readyState: g, bufferedAmount: g, onopen: g, onerror: g, onclose: g, close: g, onmessage: g, binaryType: g, send: g, extensions: g, protocol: g, [Symbol.toStringTag]: { value: "WebSocket", writable: false, enumerable: false, configurable: true } }), Object.defineProperties(b, { CONNECTING: n, OPEN: n, CLOSING: n, CLOSED: n }), e2.converters["sequence<DOMString>"] = e2.sequenceConverter(e2.converters.DOMString), e2.converters["DOMString or sequence<DOMString>"] = function(tA) {
      return e2.util.Type(tA) === "Object" && Symbol.iterator in tA ? e2.converters["sequence<DOMString>"](tA) : e2.converters.DOMString(tA);
    }, e2.converters.WebSocketInit = e2.dictionaryConverter([{ key: "protocols", converter: e2.converters["DOMString or sequence<DOMString>"], get defaultValue() {
      return [];
    } }, { key: "dispatcher", converter: (tA) => tA, get defaultValue() {
      return F();
    } }, { key: "headers", converter: e2.nullableConverter(e2.converters.HeadersInit) }]), e2.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(tA) {
      return e2.util.Type(tA) === "Object" && !(Symbol.iterator in tA) ? e2.converters.WebSocketInit(tA) : { protocols: e2.converters["DOMString or sequence<DOMString>"](tA) };
    }, e2.converters.WebSocketSendData = function(tA) {
      if (e2.util.Type(tA) === "Object") {
        if (d(tA))
          return e2.converters.Blob(tA, { strict: false });
        if (ArrayBuffer.isView(tA) || N.isArrayBuffer(tA))
          return e2.converters.BufferSource(tA);
      }
      return e2.converters.USVString(tA);
    }, websocket2 = { WebSocket: b }, websocket2;
  }
  o2(requireWebsocket, "requireWebsocket");
  var util$1;
  var hasRequiredUtil;
  function requireUtil() {
    if (hasRequiredUtil)
      return util$1;
    hasRequiredUtil = 1;
    function e2(n) {
      return n.indexOf("\x00") === -1;
    }
    o2(e2, "isValidLastEventId");
    function A(n) {
      if (n.length === 0)
        return false;
      for (let r = 0;r < n.length; r++)
        if (n.charCodeAt(r) < 48 || n.charCodeAt(r) > 57)
          return false;
      return true;
    }
    o2(A, "isASCIINumber");
    function t2(n) {
      return new Promise((r) => {
        setTimeout(r, n).unref();
      });
    }
    return o2(t2, "delay"), util$1 = { isValidLastEventId: e2, isASCIINumber: A, delay: t2 }, util$1;
  }
  o2(requireUtil, "requireUtil");
  var eventsourceStream;
  var hasRequiredEventsourceStream;
  function requireEventsourceStream() {
    if (hasRequiredEventsourceStream)
      return eventsourceStream;
    hasRequiredEventsourceStream = 1;
    const { Transform: e2 } = Stream__default, { isASCIINumber: A, isValidLastEventId: t2 } = requireUtil(), n = [239, 187, 191], r = 10, s2 = 13, i2 = 58, E = 32, C = class C2 extends e2 {
      constructor(f = {}) {
        f.readableObjectMode = true;
        super(f);
        NA(this, "state", null);
        NA(this, "checkBOM", true);
        NA(this, "crlfCheck", false);
        NA(this, "eventEndCheck", false);
        NA(this, "buffer", null);
        NA(this, "pos", 0);
        NA(this, "event", { data: undefined, event: undefined, id: undefined, retry: undefined });
        this.state = f.eventSourceSettings || {}, f.push && (this.push = f.push);
      }
      _transform(f, h2, L) {
        if (f.length === 0) {
          L();
          return;
        }
        if (this.buffer ? this.buffer = Buffer.concat([this.buffer, f]) : this.buffer = f, this.checkBOM)
          switch (this.buffer.length) {
            case 1:
              if (this.buffer[0] === n[0]) {
                L();
                return;
              }
              this.checkBOM = false, L();
              return;
            case 2:
              if (this.buffer[0] === n[0] && this.buffer[1] === n[1]) {
                L();
                return;
              }
              this.checkBOM = false;
              break;
            case 3:
              if (this.buffer[0] === n[0] && this.buffer[1] === n[1] && this.buffer[2] === n[2]) {
                this.buffer = Buffer.alloc(0), this.checkBOM = false, L();
                return;
              }
              this.checkBOM = false;
              break;
            default:
              this.buffer[0] === n[0] && this.buffer[1] === n[1] && this.buffer[2] === n[2] && (this.buffer = this.buffer.subarray(3)), this.checkBOM = false;
              break;
          }
        for (;this.pos < this.buffer.length; ) {
          if (this.eventEndCheck) {
            if (this.crlfCheck) {
              if (this.buffer[this.pos] === r) {
                this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.crlfCheck = false;
                continue;
              }
              this.crlfCheck = false;
            }
            if (this.buffer[this.pos] === r || this.buffer[this.pos] === s2) {
              this.buffer[this.pos] === s2 && (this.crlfCheck = true), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, (this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) && this.processEvent(this.event), this.clearEvent();
              continue;
            }
            this.eventEndCheck = false;
            continue;
          }
          if (this.buffer[this.pos] === r || this.buffer[this.pos] === s2) {
            this.buffer[this.pos] === s2 && (this.crlfCheck = true), this.parseLine(this.buffer.subarray(0, this.pos), this.event), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.eventEndCheck = true;
            continue;
          }
          this.pos++;
        }
        L();
      }
      parseLine(f, h2) {
        if (f.length === 0)
          return;
        const L = f.indexOf(i2);
        if (L === 0)
          return;
        let c = "", l2 = "";
        if (L !== -1) {
          c = f.subarray(0, L).toString("utf8");
          let S = L + 1;
          f[S] === E && ++S, l2 = f.subarray(S).toString("utf8");
        } else
          c = f.toString("utf8"), l2 = "";
        switch (c) {
          case "data":
            h2[c] === undefined ? h2[c] = l2 : h2[c] += `
${l2}`;
            break;
          case "retry":
            A(l2) && (h2[c] = l2);
            break;
          case "id":
            t2(l2) && (h2[c] = l2);
            break;
          case "event":
            l2.length > 0 && (h2[c] = l2);
            break;
        }
      }
      processEvent(f) {
        f.retry && A(f.retry) && (this.state.reconnectionTime = parseInt(f.retry, 10)), f.id && t2(f.id) && (this.state.lastEventId = f.id), f.data !== undefined && this.push({ type: f.event || "message", options: { data: f.data, lastEventId: this.state.lastEventId, origin: this.state.origin } });
      }
      clearEvent() {
        this.event = { data: undefined, event: undefined, id: undefined, retry: undefined };
      }
    };
    o2(C, "EventSourceStream");
    let Q = C;
    return eventsourceStream = { EventSourceStream: Q }, eventsourceStream;
  }
  o2(requireEventsourceStream, "requireEventsourceStream");
  var eventsource;
  var hasRequiredEventsource;
  function requireEventsource() {
    var U, M, B, D, G, g, d, F, $e, u, _e;
    if (hasRequiredEventsource)
      return eventsource;
    hasRequiredEventsource = 1;
    const { pipeline: e2 } = Stream__default, { fetching: A } = requireFetch(), { makeRequest: t2 } = requireRequest(), { getGlobalOrigin: n } = requireGlobal(), { webidl: r } = requireWebidl(), { EventSourceStream: s2 } = requireEventsourceStream(), { parseMIMEType: i2 } = requireDataUrl(), { MessageEvent: E } = requireEvents(), { isNetworkError: Q } = requireResponse(), { delay: C } = requireUtil(), { kEnumerableProperty: I } = util$m;
    let a2 = false;
    const f = 3000, h2 = 0, L = 1, c = 2, l2 = "anonymous", S = "use-credentials", m = class m2 extends EventTarget {
      constructor(Z, P = {}) {
        super();
        CA(this, F);
        CA(this, u);
        CA(this, U, { open: null, error: null, message: null });
        CA(this, M, null);
        CA(this, B, false);
        CA(this, D, h2);
        CA(this, G, null);
        CA(this, g, null);
        CA(this, d, null);
        r.argumentLengthCheck(arguments, 1, { header: "EventSource constructor" }), a2 || (a2 = true, process.emitWarning("EventSource is experimental, expect them to change at any time.", { code: "UNDICI-ES" })), Z = r.converters.USVString(Z), P = r.converters.EventSourceInitDict(P), EA(this, d, { origin: n(), policyContainer: { referrerPolicy: "no-referrer" }, lastEventId: "", reconnectionTime: f });
        let AA;
        try {
          AA = new URL(Z, p(this, d).origin), p(this, d).origin = AA.origin;
        } catch (aA) {
          throw new DOMException(aA, "SyntaxError");
        }
        EA(this, M, AA.href);
        let K = l2;
        P.withCredentials && (K = S, EA(this, B, true));
        const tA = { redirect: "follow", keepalive: true, mode: "cors", credentials: K === "anonymous" ? "same-origin" : "omit", referrer: "no-referrer" };
        tA.client = p(this, d), tA.headersList = [["accept", { name: "accept", value: "text/event-stream" }]], tA.cache = "no-store", tA.initiator = "other", tA.urlList = [new URL(p(this, M))], EA(this, G, t2(tA)), kA(this, F, $e).call(this);
      }
      get readyState() {
        return p(this, D);
      }
      get url() {
        return p(this, M);
      }
      get withCredentials() {
        return p(this, B);
      }
      close() {
        r.brandCheck(this, m2), p(this, D) !== c && (EA(this, D, c), clearTimeout(p(this, d).reconnectionTimer), p(this, g).abort(), p(this, G) && EA(this, G, null));
      }
      get onopen() {
        return p(this, U).open;
      }
      set onopen(Z) {
        p(this, U).open && this.removeEventListener("open", p(this, U).open), typeof Z == "function" ? (p(this, U).open = Z, this.addEventListener("open", Z)) : p(this, U).open = null;
      }
      get onmessage() {
        return p(this, U).message;
      }
      set onmessage(Z) {
        p(this, U).message && this.removeEventListener("message", p(this, U).message), typeof Z == "function" ? (p(this, U).message = Z, this.addEventListener("message", Z)) : p(this, U).message = null;
      }
      get onerror() {
        return p(this, U).error;
      }
      set onerror(Z) {
        p(this, U).error && this.removeEventListener("error", p(this, U).error), typeof Z == "function" ? (p(this, U).error = Z, this.addEventListener("error", Z)) : p(this, U).error = null;
      }
    };
    U = new WeakMap, M = new WeakMap, B = new WeakMap, D = new WeakMap, G = new WeakMap, g = new WeakMap, d = new WeakMap, F = new WeakSet, $e = o2(function() {
      if (p(this, D) === c)
        return;
      EA(this, D, h2);
      const Z = { request: p(this, G) }, P = o2((AA) => {
        Q(AA) && (this.dispatchEvent(new Event("error")), this.close()), kA(this, u, _e).call(this);
      }, "processEventSourceEndOfBody");
      Z.processResponseEndOfBody = P, Z.processResponse = (AA) => {
        if (Q(AA))
          if (AA.aborted) {
            this.close(), this.dispatchEvent(new Event("error"));
            return;
          } else {
            kA(this, u, _e).call(this);
            return;
          }
        const K = AA.headersList.get("content-type", true), tA = K !== null ? i2(K) : "failure", aA = tA !== "failure" && tA.essence === "text/event-stream";
        if (AA.status !== 200 || aA === false) {
          this.close(), this.dispatchEvent(new Event("error"));
          return;
        }
        EA(this, D, L), this.dispatchEvent(new Event("open")), p(this, d).origin = AA.urlList[AA.urlList.length - 1].origin;
        const X = new s2({ eventSourceSettings: p(this, d), push: ($) => {
          this.dispatchEvent(new E($.type, $.options));
        } });
        e2(AA.body.stream, X, ($) => {
          $?.aborted === false && (this.close(), this.dispatchEvent(new Event("error")));
        });
      }, EA(this, g, A(Z));
    }, "#connect"), u = new WeakSet, _e = o2(async function() {
      p(this, D) !== c && (EA(this, D, h2), this.dispatchEvent(new Event("error")), await C(p(this, d).reconnectionTime), p(this, D) === h2 && (p(this, d).lastEventId !== "" && p(this, G).headersList.set("last-event-id", p(this, d).lastEventId, true), kA(this, F, $e).call(this)));
    }, "#reconnect"), o2(m, "EventSource");
    let k = m;
    const w = { CONNECTING: { __proto__: null, configurable: false, enumerable: true, value: h2, writable: false }, OPEN: { __proto__: null, configurable: false, enumerable: true, value: L, writable: false }, CLOSED: { __proto__: null, configurable: false, enumerable: true, value: c, writable: false } };
    return Object.defineProperties(k, w), Object.defineProperties(k.prototype, w), Object.defineProperties(k.prototype, { close: I, onerror: I, onmessage: I, onopen: I, readyState: I, url: I, withCredentials: I }), r.converters.EventSourceInitDict = r.dictionaryConverter([{ key: "withCredentials", converter: r.converters.boolean, defaultValue: false }]), eventsource = { EventSource: k, defaultReconnectionTime: f }, eventsource;
  }
  o2(requireEventsource, "requireEventsource");
  var Dispatcher = dispatcher;
  var Agent = agent;
  var ProxyAgent = proxyAgent;
  var errors = errors$1;
  var util = util$m;
  var { InvalidArgumentError } = errors;
  var api = api$1;
  var { getGlobalDispatcher, setGlobalDispatcher } = global2;
  Object.assign(Dispatcher.prototype, api);
  var Agent_1 = Agent;
  var ProxyAgent_1 = ProxyAgent;
  util.parseHeaders, util.headerNameToString;
  function makeDispatcher(e2) {
    return (A, t2, n) => {
      if (typeof t2 == "function" && (n = t2, t2 = null), !A || typeof A != "string" && typeof A != "object" && !(A instanceof URL))
        throw new InvalidArgumentError("invalid url");
      if (t2 != null && typeof t2 != "object")
        throw new InvalidArgumentError("invalid opts");
      if (t2 && t2.path != null) {
        if (typeof t2.path != "string")
          throw new InvalidArgumentError("invalid opts.path");
        let i2 = t2.path;
        t2.path.startsWith("/") || (i2 = `/${i2}`), A = new URL(util.parseOrigin(A).origin + i2);
      } else
        t2 || (t2 = typeof A == "object" ? A : {}), A = util.parseURL(A);
      const { agent: r, dispatcher: s2 = getGlobalDispatcher() } = t2;
      if (r)
        throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
      return e2.call(s2, { ...t2, origin: A.origin, path: A.search ? `${A.pathname}${A.search}` : A.pathname, method: t2.method || (t2.body ? "PUT" : "GET") }, n);
    };
  }
  o2(makeDispatcher, "makeDispatcher"), requireFetch().fetch, requireHeaders().Headers, requireResponse().Response, requireRequest().Request, requireFormdata().FormData, requireFile().File, requireFilereader().FileReader, requireGlobal();
  var { CacheStorage } = requireCachestorage();
  var { kConstruct } = requireSymbols$1();
  new CacheStorage(kConstruct), requireCookies(), requireDataUrl(), requireEvents(), requireWebsocket().WebSocket, makeDispatcher(api.request), makeDispatcher(api.stream), makeDispatcher(api.pipeline), makeDispatcher(api.connect), makeDispatcher(api.upgrade), requireEventsource(), exports.Agent_1 = Agent_1, exports.ProxyAgent_1 = ProxyAgent_1;
});

// node_modules/node-fetch-native-with-agent/dist/agent.cjs
var exports_agent = {};
function createAgent(e2, t2 = {}) {
  const n = { rejectUnauthorized: t2.rejectUnauthorized }, c = e2?.startsWith("https:") ? new https.Agent(n) : new http.Agent, s2 = new index.Agent_1({ connect: n });
  return { agent: c, dispatcher: s2 };
}
function createFetch(e2 = {}) {
  const t2 = createAgent(undefined, e2);
  return (n, c) => nodeFetchNativeWithAgent.fetch(n, { ...t2, ...c });
}
var u, o2 = (e2, t2) => u(e2, "name", { value: t2, configurable: true }), http, https, index, nodeFetchNativeWithAgent, i2, r, fetch;
var init_agent = __esm(() => {
  u = Object.defineProperty;
  http = __require("http");
  https = __require("https");
  index = require_node_fetch_native_with_agent_df7e6bd6();
  nodeFetchNativeWithAgent = (init_native(), __toCommonJS(exports_native));
  __require("assert"), __require("net"), __require("stream"), __require("buffer"), __require("util"), __require("querystring"), __require("diagnostics_channel"), __require("events"), require_node_fetch_native_with_agent_61758d11(), __require("tls"), __require("zlib"), __require("perf_hooks"), __require("util/types"), __require("os"), __require("url"), __require("async_hooks"), __require("console"), __require("string_decoder"), __require("worker_threads");
  i2 = Object.defineProperty;
  r = o2((e2, t2) => i2(e2, "name", { value: t2, configurable: true }), "r");
  o2(createAgent, "createAgent"), r(createAgent, "createAgent");
  o2(createFetch, "createFetch"), r(createFetch, "createFetch");
  fetch = createFetch({});
  exports_agent.createAgent = createAgent, exports_agent.createFetch = createFetch, exports_agent.fetch = fetch;
});

// node_modules/node-appwrite/dist/query.js
var require_query = __commonJS((exports) => {
  var _Query = class _Query2 {
    constructor(method, attribute, values) {
      this.method = method;
      this.attribute = attribute;
      if (values !== undefined) {
        if (Array.isArray(values)) {
          this.values = values;
        } else {
          this.values = [values];
        }
      }
    }
    toString() {
      return JSON.stringify({
        method: this.method,
        attribute: this.attribute,
        values: this.values
      });
    }
  };
  _Query.equal = (attribute, value) => new _Query("equal", attribute, value).toString();
  _Query.notEqual = (attribute, value) => new _Query("notEqual", attribute, value).toString();
  _Query.lessThan = (attribute, value) => new _Query("lessThan", attribute, value).toString();
  _Query.lessThanEqual = (attribute, value) => new _Query("lessThanEqual", attribute, value).toString();
  _Query.greaterThan = (attribute, value) => new _Query("greaterThan", attribute, value).toString();
  _Query.greaterThanEqual = (attribute, value) => new _Query("greaterThanEqual", attribute, value).toString();
  _Query.isNull = (attribute) => new _Query("isNull", attribute).toString();
  _Query.isNotNull = (attribute) => new _Query("isNotNull", attribute).toString();
  _Query.between = (attribute, start, end) => new _Query("between", attribute, [start, end]).toString();
  _Query.startsWith = (attribute, value) => new _Query("startsWith", attribute, value).toString();
  _Query.endsWith = (attribute, value) => new _Query("endsWith", attribute, value).toString();
  _Query.select = (attributes) => new _Query("select", undefined, attributes).toString();
  _Query.search = (attribute, value) => new _Query("search", attribute, value).toString();
  _Query.orderDesc = (attribute) => new _Query("orderDesc", attribute).toString();
  _Query.orderAsc = (attribute) => new _Query("orderAsc", attribute).toString();
  _Query.orderRandom = () => new _Query("orderRandom").toString();
  _Query.cursorAfter = (documentId) => new _Query("cursorAfter", undefined, documentId).toString();
  _Query.cursorBefore = (documentId) => new _Query("cursorBefore", undefined, documentId).toString();
  _Query.limit = (limit) => new _Query("limit", undefined, limit).toString();
  _Query.offset = (offset) => new _Query("offset", undefined, offset).toString();
  _Query.contains = (attribute, value) => new _Query("contains", attribute, value).toString();
  _Query.notContains = (attribute, value) => new _Query("notContains", attribute, value).toString();
  _Query.notSearch = (attribute, value) => new _Query("notSearch", attribute, value).toString();
  _Query.notBetween = (attribute, start, end) => new _Query("notBetween", attribute, [start, end]).toString();
  _Query.notStartsWith = (attribute, value) => new _Query("notStartsWith", attribute, value).toString();
  _Query.notEndsWith = (attribute, value) => new _Query("notEndsWith", attribute, value).toString();
  _Query.createdBefore = (value) => _Query.lessThan("$createdAt", value);
  _Query.createdAfter = (value) => _Query.greaterThan("$createdAt", value);
  _Query.createdBetween = (start, end) => _Query.between("$createdAt", start, end);
  _Query.updatedBefore = (value) => _Query.lessThan("$updatedAt", value);
  _Query.updatedAfter = (value) => _Query.greaterThan("$updatedAt", value);
  _Query.updatedBetween = (start, end) => _Query.between("$updatedAt", start, end);
  _Query.or = (queries) => new _Query("or", undefined, queries.map((query) => JSON.parse(query))).toString();
  _Query.and = (queries) => new _Query("and", undefined, queries.map((query) => JSON.parse(query))).toString();
  _Query.distanceEqual = (attribute, values, distance, meters = true) => new _Query("distanceEqual", attribute, [[values, distance, meters]]).toString();
  _Query.distanceNotEqual = (attribute, values, distance, meters = true) => new _Query("distanceNotEqual", attribute, [[values, distance, meters]]).toString();
  _Query.distanceGreaterThan = (attribute, values, distance, meters = true) => new _Query("distanceGreaterThan", attribute, [[values, distance, meters]]).toString();
  _Query.distanceLessThan = (attribute, values, distance, meters = true) => new _Query("distanceLessThan", attribute, [[values, distance, meters]]).toString();
  _Query.intersects = (attribute, values) => new _Query("intersects", attribute, [values]).toString();
  _Query.notIntersects = (attribute, values) => new _Query("notIntersects", attribute, [values]).toString();
  _Query.crosses = (attribute, values) => new _Query("crosses", attribute, [values]).toString();
  _Query.notCrosses = (attribute, values) => new _Query("notCrosses", attribute, [values]).toString();
  _Query.overlaps = (attribute, values) => new _Query("overlaps", attribute, [values]).toString();
  _Query.notOverlaps = (attribute, values) => new _Query("notOverlaps", attribute, [values]).toString();
  _Query.touches = (attribute, values) => new _Query("touches", attribute, [values]).toString();
  _Query.notTouches = (attribute, values) => new _Query("notTouches", attribute, [values]).toString();
  var Query = _Query;
  exports.Query = Query;
});

// node_modules/node-appwrite/dist/client.js
var require_client = __commonJS((exports) => {
  var nodeFetchNativeWithAgent2 = (init_native(), __toCommonJS(exports_native));
  var agent = (init_agent(), __toCommonJS(exports_agent));
  var query = require_query();

  class AppwriteException extends Error {
    constructor(message, code = 0, type = "", response = "") {
      super(message);
      this.name = "AppwriteException";
      this.message = message;
      this.code = code;
      this.type = type;
      this.response = response;
    }
  }
  function getUserAgent() {
    let ua = "AppwriteNodeJSSDK/20.3.0";
    const platform = [];
    if (typeof process !== "undefined") {
      if (typeof process.platform === "string")
        platform.push(process.platform);
      if (typeof process.arch === "string")
        platform.push(process.arch);
    }
    if (platform.length > 0) {
      ua += ` (${platform.join("; ")})`;
    }
    if (typeof navigator !== "undefined" && typeof navigator.userAgent === "string") {
      ua += ` ${navigator.userAgent}`;
    } else if (typeof globalThis.EdgeRuntime === "string") {
      ua += ` EdgeRuntime`;
    } else if (typeof process !== "undefined" && typeof process.version === "string") {
      ua += ` Node.js/${process.version}`;
    }
    return ua;
  }
  var _Client = class _Client2 {
    constructor() {
      this.config = {
        endpoint: "https://cloud.appwrite.io/v1",
        selfSigned: false,
        project: "",
        key: "",
        jwt: "",
        locale: "",
        session: "",
        forwardeduseragent: ""
      };
      this.headers = {
        "x-sdk-name": "Node.js",
        "x-sdk-platform": "server",
        "x-sdk-language": "nodejs",
        "x-sdk-version": "20.3.0",
        "user-agent": getUserAgent(),
        "X-Appwrite-Response-Format": "1.8.0"
      };
    }
    setEndpoint(endpoint) {
      if (!endpoint.startsWith("http://") && !endpoint.startsWith("https://")) {
        throw new AppwriteException("Invalid endpoint URL: " + endpoint);
      }
      this.config.endpoint = endpoint;
      return this;
    }
    setSelfSigned(selfSigned) {
      if (typeof globalThis.EdgeRuntime !== "undefined") {
        console.warn("setSelfSigned is not supported in edge runtimes.");
      }
      this.config.selfSigned = selfSigned;
      return this;
    }
    addHeader(header, value) {
      this.headers[header.toLowerCase()] = value;
      return this;
    }
    setProject(value) {
      this.headers["X-Appwrite-Project"] = value;
      this.config.project = value;
      return this;
    }
    setKey(value) {
      this.headers["X-Appwrite-Key"] = value;
      this.config.key = value;
      return this;
    }
    setJWT(value) {
      this.headers["X-Appwrite-JWT"] = value;
      this.config.jwt = value;
      return this;
    }
    setLocale(value) {
      this.headers["X-Appwrite-Locale"] = value;
      this.config.locale = value;
      return this;
    }
    setSession(value) {
      this.headers["X-Appwrite-Session"] = value;
      this.config.session = value;
      return this;
    }
    setForwardedUserAgent(value) {
      this.headers["X-Forwarded-User-Agent"] = value;
      this.config.forwardeduseragent = value;
      return this;
    }
    prepareRequest(method, url, headers = {}, params = {}) {
      method = method.toUpperCase();
      headers = Object.assign({}, this.headers, headers);
      let options = {
        method,
        headers,
        ...agent.createAgent(this.config.endpoint, { rejectUnauthorized: !this.config.selfSigned })
      };
      if (method === "GET") {
        for (const [key, value] of Object.entries(_Client2.flatten(params))) {
          url.searchParams.append(key, value);
        }
      } else {
        switch (headers["content-type"]) {
          case "application/json":
            options.body = JSON.stringify(params);
            break;
          case "multipart/form-data":
            const formData = new nodeFetchNativeWithAgent2.FormData;
            for (const [key, value] of Object.entries(params)) {
              if (value instanceof nodeFetchNativeWithAgent2.File) {
                formData.append(key, value, value.name);
              } else if (Array.isArray(value)) {
                for (const nestedValue of value) {
                  formData.append(`${key}[]`, nestedValue);
                }
              } else {
                formData.append(key, value);
              }
            }
            options.body = formData;
            delete headers["content-type"];
            break;
        }
      }
      return { uri: url.toString(), options };
    }
    async chunkedUpload(method, url, headers = {}, originalPayload = {}, onProgress) {
      const [fileParam, file] = Object.entries(originalPayload).find(([_, value]) => value instanceof nodeFetchNativeWithAgent2.File) ?? [];
      if (!file || !fileParam) {
        throw new Error("File not found in payload");
      }
      if (file.size <= _Client2.CHUNK_SIZE) {
        return await this.call(method, url, headers, originalPayload);
      }
      let start = 0;
      let response = null;
      while (start < file.size) {
        let end = start + _Client2.CHUNK_SIZE;
        if (end >= file.size) {
          end = file.size;
        }
        headers["content-range"] = `bytes ${start}-${end - 1}/${file.size}`;
        const chunk = file.slice(start, end);
        let payload = { ...originalPayload };
        payload[fileParam] = new nodeFetchNativeWithAgent2.File([chunk], file.name);
        response = await this.call(method, url, headers, payload);
        if (onProgress && typeof onProgress === "function") {
          onProgress({
            $id: response.$id,
            progress: Math.round(end / file.size * 100),
            sizeUploaded: end,
            chunksTotal: Math.ceil(file.size / _Client2.CHUNK_SIZE),
            chunksUploaded: Math.ceil(end / _Client2.CHUNK_SIZE)
          });
        }
        if (response && response.$id) {
          headers["x-appwrite-id"] = response.$id;
        }
        start = end;
      }
      return response;
    }
    async ping() {
      return this.call("GET", new URL(this.config.endpoint + "/ping"));
    }
    async redirect(method, url, headers = {}, params = {}) {
      const { uri, options } = this.prepareRequest(method, url, headers, params);
      const response = await nodeFetchNativeWithAgent2.fetch(uri, {
        ...options,
        redirect: "manual"
      });
      if (response.status !== 301 && response.status !== 302) {
        throw new AppwriteException("Invalid redirect", response.status);
      }
      return response.headers.get("location") || "";
    }
    async call(method, url, headers = {}, params = {}, responseType = "json") {
      var _a, _b;
      const { uri, options } = this.prepareRequest(method, url, headers, params);
      let data = null;
      const response = await nodeFetchNativeWithAgent2.fetch(uri, options);
      const warnings = response.headers.get("x-appwrite-warning");
      if (warnings) {
        warnings.split(";").forEach((warning) => console.warn("Warning: " + warning));
      }
      if ((_a = response.headers.get("content-type")) == null ? undefined : _a.includes("application/json")) {
        data = await response.json();
      } else if (responseType === "arrayBuffer") {
        data = await response.arrayBuffer();
      } else {
        data = {
          message: await response.text()
        };
      }
      if (400 <= response.status) {
        let responseText = "";
        if (((_b = response.headers.get("content-type")) == null ? undefined : _b.includes("application/json")) || responseType === "arrayBuffer") {
          responseText = JSON.stringify(data);
        } else {
          responseText = data == null ? undefined : data.message;
        }
        throw new AppwriteException(data == null ? undefined : data.message, response.status, data == null ? undefined : data.type, responseText);
      }
      return data;
    }
    static flatten(data, prefix = "") {
      let output = {};
      for (const [key, value] of Object.entries(data)) {
        let finalKey = prefix ? prefix + "[" + key + "]" : key;
        if (Array.isArray(value)) {
          output = { ...output, ..._Client2.flatten(value, finalKey) };
        } else {
          output[finalKey] = value;
        }
      }
      return output;
    }
  };
  _Client.CHUNK_SIZE = 1024 * 1024 * 5;
  var Client = _Client;
  Object.defineProperty(exports, "Query", {
    enumerable: true,
    get: function() {
      return query.Query;
    }
  });
  exports.AppwriteException = AppwriteException;
  exports.Client = Client;
});

// node_modules/node-appwrite/dist/services/account.js
var require_account = __commonJS((exports) => {
  var client = require_client();

  class Account {
    constructor(client2) {
      this.client = client2;
    }
    get() {
      const apiPath = "/account";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          email: rest[0],
          password: rest[1],
          name: rest[2]
        };
      }
      const userId = params.userId;
      const email = params.email;
      const password = params.password;
      const name = params.name;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/account";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateEmail(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          email: paramsOrFirst,
          password: rest[0]
        };
      }
      const email = params.email;
      const password = params.password;
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/account/email";
      const payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    listIdentities(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst,
          total: rest[0]
        };
      }
      const queries = params.queries;
      const total = params.total;
      const apiPath = "/account/identities";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    deleteIdentity(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          identityId: paramsOrFirst
        };
      }
      const identityId = params.identityId;
      if (typeof identityId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "identityId"');
      }
      const apiPath = "/account/identities/{identityId}".replace("{identityId}", identityId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    createJWT() {
      const apiPath = "/account/jwts";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    listLogs(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst,
          total: rest[0]
        };
      }
      const queries = params.queries;
      const total = params.total;
      const apiPath = "/account/logs";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateMFA(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          mfa: paramsOrFirst
        };
      }
      const mfa = params.mfa;
      if (typeof mfa === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "mfa"');
      }
      const apiPath = "/account/mfa";
      const payload = {};
      if (typeof mfa !== "undefined") {
        payload["mfa"] = mfa;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createMfaAuthenticator(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          type: paramsOrFirst
        };
      }
      const type = params.type;
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createMFAAuthenticator(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          type: paramsOrFirst
        };
      }
      const type = params.type;
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateMfaAuthenticator(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          type: paramsOrFirst,
          otp: rest[0]
        };
      }
      const type = params.type;
      const otp = params.otp;
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      if (typeof otp === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "otp"');
      }
      const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
      const payload = {};
      if (typeof otp !== "undefined") {
        payload["otp"] = otp;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    updateMFAAuthenticator(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          type: paramsOrFirst,
          otp: rest[0]
        };
      }
      const type = params.type;
      const otp = params.otp;
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      if (typeof otp === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "otp"');
      }
      const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
      const payload = {};
      if (typeof otp !== "undefined") {
        payload["otp"] = otp;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    deleteMfaAuthenticator(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          type: paramsOrFirst
        };
      }
      const type = params.type;
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    deleteMFAAuthenticator(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          type: paramsOrFirst
        };
      }
      const type = params.type;
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    createMfaChallenge(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "factor" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          factor: paramsOrFirst
        };
      }
      const factor = params.factor;
      if (typeof factor === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "factor"');
      }
      const apiPath = "/account/mfa/challenge";
      const payload = {};
      if (typeof factor !== "undefined") {
        payload["factor"] = factor;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createMFAChallenge(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "factor" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          factor: paramsOrFirst
        };
      }
      const factor = params.factor;
      if (typeof factor === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "factor"');
      }
      const apiPath = "/account/mfa/challenge";
      const payload = {};
      if (typeof factor !== "undefined") {
        payload["factor"] = factor;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateMfaChallenge(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          challengeId: paramsOrFirst,
          otp: rest[0]
        };
      }
      const challengeId = params.challengeId;
      const otp = params.otp;
      if (typeof challengeId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "challengeId"');
      }
      if (typeof otp === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "otp"');
      }
      const apiPath = "/account/mfa/challenge";
      const payload = {};
      if (typeof challengeId !== "undefined") {
        payload["challengeId"] = challengeId;
      }
      if (typeof otp !== "undefined") {
        payload["otp"] = otp;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    updateMFAChallenge(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          challengeId: paramsOrFirst,
          otp: rest[0]
        };
      }
      const challengeId = params.challengeId;
      const otp = params.otp;
      if (typeof challengeId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "challengeId"');
      }
      if (typeof otp === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "otp"');
      }
      const apiPath = "/account/mfa/challenge";
      const payload = {};
      if (typeof challengeId !== "undefined") {
        payload["challengeId"] = challengeId;
      }
      if (typeof otp !== "undefined") {
        payload["otp"] = otp;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    listMfaFactors() {
      const apiPath = "/account/mfa/factors";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listMFAFactors() {
      const apiPath = "/account/mfa/factors";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getMfaRecoveryCodes() {
      const apiPath = "/account/mfa/recovery-codes";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getMFARecoveryCodes() {
      const apiPath = "/account/mfa/recovery-codes";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createMfaRecoveryCodes() {
      const apiPath = "/account/mfa/recovery-codes";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createMFARecoveryCodes() {
      const apiPath = "/account/mfa/recovery-codes";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateMfaRecoveryCodes() {
      const apiPath = "/account/mfa/recovery-codes";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    updateMFARecoveryCodes() {
      const apiPath = "/account/mfa/recovery-codes";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    updateName(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          name: paramsOrFirst
        };
      }
      const name = params.name;
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/account/name";
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    updatePassword(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          password: paramsOrFirst,
          oldPassword: rest[0]
        };
      }
      const password = params.password;
      const oldPassword = params.oldPassword;
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/account/password";
      const payload = {};
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof oldPassword !== "undefined") {
        payload["oldPassword"] = oldPassword;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    updatePhone(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          phone: paramsOrFirst,
          password: rest[0]
        };
      }
      const phone = params.phone;
      const password = params.password;
      if (typeof phone === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "phone"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/account/phone";
      const payload = {};
      if (typeof phone !== "undefined") {
        payload["phone"] = phone;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    getPrefs() {
      const apiPath = "/account/prefs";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updatePrefs(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "prefs" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          prefs: paramsOrFirst
        };
      }
      const prefs = params.prefs;
      if (typeof prefs === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "prefs"');
      }
      const apiPath = "/account/prefs";
      const payload = {};
      if (typeof prefs !== "undefined") {
        payload["prefs"] = prefs;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createRecovery(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          email: paramsOrFirst,
          url: rest[0]
        };
      }
      const email = params.email;
      const url = params.url;
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof url === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "url"');
      }
      const apiPath = "/account/recovery";
      const payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateRecovery(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          secret: rest[0],
          password: rest[1]
        };
      }
      const userId = params.userId;
      const secret = params.secret;
      const password = params.password;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/account/recovery";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    listSessions() {
      const apiPath = "/account/sessions";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    deleteSessions() {
      const apiPath = "/account/sessions";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    createAnonymousSession() {
      const apiPath = "/account/sessions/anonymous";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createEmailPasswordSession(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          email: paramsOrFirst,
          password: rest[0]
        };
      }
      const email = params.email;
      const password = params.password;
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/account/sessions/email";
      const payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateMagicURLSession(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          secret: rest[0]
        };
      }
      const userId = params.userId;
      const secret = params.secret;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      const apiPath = "/account/sessions/magic-url";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    updatePhoneSession(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          secret: rest[0]
        };
      }
      const userId = params.userId;
      const secret = params.secret;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      const apiPath = "/account/sessions/phone";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    createSession(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          secret: rest[0]
        };
      }
      const userId = params.userId;
      const secret = params.secret;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      const apiPath = "/account/sessions/token";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getSession(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          sessionId: paramsOrFirst
        };
      }
      const sessionId = params.sessionId;
      if (typeof sessionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "sessionId"');
      }
      const apiPath = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateSession(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          sessionId: paramsOrFirst
        };
      }
      const sessionId = params.sessionId;
      if (typeof sessionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "sessionId"');
      }
      const apiPath = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    deleteSession(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          sessionId: paramsOrFirst
        };
      }
      const sessionId = params.sessionId;
      if (typeof sessionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "sessionId"');
      }
      const apiPath = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    updateStatus() {
      const apiPath = "/account/status";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createEmailToken(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          email: rest[0],
          phrase: rest[1]
        };
      }
      const userId = params.userId;
      const email = params.email;
      const phrase = params.phrase;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      const apiPath = "/account/tokens/email";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof phrase !== "undefined") {
        payload["phrase"] = phrase;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createMagicURLToken(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          email: rest[0],
          url: rest[1],
          phrase: rest[2]
        };
      }
      const userId = params.userId;
      const email = params.email;
      const url = params.url;
      const phrase = params.phrase;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      const apiPath = "/account/tokens/magic-url";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      if (typeof phrase !== "undefined") {
        payload["phrase"] = phrase;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createOAuth2Token(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "provider" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          provider: paramsOrFirst,
          success: rest[0],
          failure: rest[1],
          scopes: rest[2]
        };
      }
      const provider = params.provider;
      const success = params.success;
      const failure = params.failure;
      const scopes = params.scopes;
      if (typeof provider === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "provider"');
      }
      const apiPath = "/account/tokens/oauth2/{provider}".replace("{provider}", provider);
      const payload = {};
      if (typeof success !== "undefined") {
        payload["success"] = success;
      }
      if (typeof failure !== "undefined") {
        payload["failure"] = failure;
      }
      if (typeof scopes !== "undefined") {
        payload["scopes"] = scopes;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.redirect("get", uri, apiHeaders, payload);
    }
    createPhoneToken(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          phone: rest[0]
        };
      }
      const userId = params.userId;
      const phone = params.phone;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof phone === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "phone"');
      }
      const apiPath = "/account/tokens/phone";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof phone !== "undefined") {
        payload["phone"] = phone;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createEmailVerification(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          url: paramsOrFirst
        };
      }
      const url = params.url;
      if (typeof url === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "url"');
      }
      const apiPath = "/account/verifications/email";
      const payload = {};
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createVerification(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          url: paramsOrFirst
        };
      }
      const url = params.url;
      if (typeof url === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "url"');
      }
      const apiPath = "/account/verifications/email";
      const payload = {};
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateEmailVerification(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          secret: rest[0]
        };
      }
      const userId = params.userId;
      const secret = params.secret;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      const apiPath = "/account/verifications/email";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    updateVerification(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          secret: rest[0]
        };
      }
      const userId = params.userId;
      const secret = params.secret;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      const apiPath = "/account/verifications/email";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    createPhoneVerification() {
      const apiPath = "/account/verifications/phone";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updatePhoneVerification(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          secret: rest[0]
        };
      }
      const userId = params.userId;
      const secret = params.secret;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      const apiPath = "/account/verifications/phone";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
  }
  exports.Account = Account;
});

// node_modules/node-appwrite/dist/services/avatars.js
var require_avatars = __commonJS((exports) => {
  var client = require_client();

  class Avatars {
    constructor(client2) {
      this.client = client2;
    }
    getBrowser(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "code" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          code: paramsOrFirst,
          width: rest[0],
          height: rest[1],
          quality: rest[2]
        };
      }
      const code = params.code;
      const width = params.width;
      const height = params.height;
      const quality = params.quality;
      if (typeof code === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "code"');
      }
      const apiPath = "/avatars/browsers/{code}".replace("{code}", code);
      const payload = {};
      if (typeof width !== "undefined") {
        payload["width"] = width;
      }
      if (typeof height !== "undefined") {
        payload["height"] = height;
      }
      if (typeof quality !== "undefined") {
        payload["quality"] = quality;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    getCreditCard(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "code" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          code: paramsOrFirst,
          width: rest[0],
          height: rest[1],
          quality: rest[2]
        };
      }
      const code = params.code;
      const width = params.width;
      const height = params.height;
      const quality = params.quality;
      if (typeof code === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "code"');
      }
      const apiPath = "/avatars/credit-cards/{code}".replace("{code}", code);
      const payload = {};
      if (typeof width !== "undefined") {
        payload["width"] = width;
      }
      if (typeof height !== "undefined") {
        payload["height"] = height;
      }
      if (typeof quality !== "undefined") {
        payload["quality"] = quality;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    getFavicon(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          url: paramsOrFirst
        };
      }
      const url = params.url;
      if (typeof url === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "url"');
      }
      const apiPath = "/avatars/favicon";
      const payload = {};
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    getFlag(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "code" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          code: paramsOrFirst,
          width: rest[0],
          height: rest[1],
          quality: rest[2]
        };
      }
      const code = params.code;
      const width = params.width;
      const height = params.height;
      const quality = params.quality;
      if (typeof code === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "code"');
      }
      const apiPath = "/avatars/flags/{code}".replace("{code}", code);
      const payload = {};
      if (typeof width !== "undefined") {
        payload["width"] = width;
      }
      if (typeof height !== "undefined") {
        payload["height"] = height;
      }
      if (typeof quality !== "undefined") {
        payload["quality"] = quality;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    getImage(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          url: paramsOrFirst,
          width: rest[0],
          height: rest[1]
        };
      }
      const url = params.url;
      const width = params.width;
      const height = params.height;
      if (typeof url === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "url"');
      }
      const apiPath = "/avatars/image";
      const payload = {};
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      if (typeof width !== "undefined") {
        payload["width"] = width;
      }
      if (typeof height !== "undefined") {
        payload["height"] = height;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    getInitials(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          name: paramsOrFirst,
          width: rest[0],
          height: rest[1],
          background: rest[2]
        };
      }
      const name = params.name;
      const width = params.width;
      const height = params.height;
      const background = params.background;
      const apiPath = "/avatars/initials";
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof width !== "undefined") {
        payload["width"] = width;
      }
      if (typeof height !== "undefined") {
        payload["height"] = height;
      }
      if (typeof background !== "undefined") {
        payload["background"] = background;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    getQR(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          text: paramsOrFirst,
          size: rest[0],
          margin: rest[1],
          download: rest[2]
        };
      }
      const text = params.text;
      const size = params.size;
      const margin = params.margin;
      const download = params.download;
      if (typeof text === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "text"');
      }
      const apiPath = "/avatars/qr";
      const payload = {};
      if (typeof text !== "undefined") {
        payload["text"] = text;
      }
      if (typeof size !== "undefined") {
        payload["size"] = size;
      }
      if (typeof margin !== "undefined") {
        payload["margin"] = margin;
      }
      if (typeof download !== "undefined") {
        payload["download"] = download;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
  }
  exports.Avatars = Avatars;
});

// node_modules/node-appwrite/dist/services/databases.js
var require_databases = __commonJS((exports) => {
  var client = require_client();

  class Databases {
    constructor(client2) {
      this.client = client2;
    }
    list(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst,
          search: rest[0],
          total: rest[1]
        };
      }
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      const apiPath = "/databases";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1]
        };
      }
      const databaseId = params.databaseId;
      const name = params.name;
      const enabled = params.enabled;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/databases";
      const payload = {};
      if (typeof databaseId !== "undefined") {
        payload["databaseId"] = databaseId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    listTransactions(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst
        };
      }
      const queries = params.queries;
      const apiPath = "/databases/transactions";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createTransaction(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          ttl: paramsOrFirst
        };
      }
      const ttl = params.ttl;
      const apiPath = "/databases/transactions";
      const payload = {};
      if (typeof ttl !== "undefined") {
        payload["ttl"] = ttl;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getTransaction(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          transactionId: paramsOrFirst
        };
      }
      const transactionId = params.transactionId;
      if (typeof transactionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "transactionId"');
      }
      const apiPath = "/databases/transactions/{transactionId}".replace("{transactionId}", transactionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateTransaction(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          transactionId: paramsOrFirst,
          commit: rest[0],
          rollback: rest[1]
        };
      }
      const transactionId = params.transactionId;
      const commit = params.commit;
      const rollback = params.rollback;
      if (typeof transactionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "transactionId"');
      }
      const apiPath = "/databases/transactions/{transactionId}".replace("{transactionId}", transactionId);
      const payload = {};
      if (typeof commit !== "undefined") {
        payload["commit"] = commit;
      }
      if (typeof rollback !== "undefined") {
        payload["rollback"] = rollback;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    deleteTransaction(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          transactionId: paramsOrFirst
        };
      }
      const transactionId = params.transactionId;
      if (typeof transactionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "transactionId"');
      }
      const apiPath = "/databases/transactions/{transactionId}".replace("{transactionId}", transactionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    createOperations(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          transactionId: paramsOrFirst,
          operations: rest[0]
        };
      }
      const transactionId = params.transactionId;
      const operations = params.operations;
      if (typeof transactionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "transactionId"');
      }
      const apiPath = "/databases/transactions/{transactionId}/operations".replace("{transactionId}", transactionId);
      const payload = {};
      if (typeof operations !== "undefined") {
        payload["operations"] = operations;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst
        };
      }
      const databaseId = params.databaseId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      const apiPath = "/databases/{databaseId}".replace("{databaseId}", databaseId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    update(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1]
        };
      }
      const databaseId = params.databaseId;
      const name = params.name;
      const enabled = params.enabled;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/databases/{databaseId}".replace("{databaseId}", databaseId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst
        };
      }
      const databaseId = params.databaseId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      const apiPath = "/databases/{databaseId}".replace("{databaseId}", databaseId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    listCollections(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          queries: rest[0],
          search: rest[1],
          total: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      const apiPath = "/databases/{databaseId}/collections".replace("{databaseId}", databaseId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createCollection(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          name: rest[1],
          permissions: rest[2],
          documentSecurity: rest[3],
          enabled: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const name = params.name;
      const permissions = params.permissions;
      const documentSecurity = params.documentSecurity;
      const enabled = params.enabled;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/databases/{databaseId}/collections".replace("{databaseId}", databaseId);
      const payload = {};
      if (typeof collectionId !== "undefined") {
        payload["collectionId"] = collectionId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof documentSecurity !== "undefined") {
        payload["documentSecurity"] = documentSecurity;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getCollection(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateCollection(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          name: rest[1],
          permissions: rest[2],
          documentSecurity: rest[3],
          enabled: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const name = params.name;
      const permissions = params.permissions;
      const documentSecurity = params.documentSecurity;
      const enabled = params.enabled;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof documentSecurity !== "undefined") {
        payload["documentSecurity"] = documentSecurity;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    deleteCollection(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    listAttributes(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          queries: rest[1],
          total: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const queries = params.queries;
      const total = params.total;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createBooleanAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          array: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/boolean".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateBooleanAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/boolean/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createDatetimeAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          array: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/datetime".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateDatetimeAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/datetime/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createEmailAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          array: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/email".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateEmailAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/email/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createEnumAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          elements: rest[2],
          required: rest[3],
          xdefault: rest[4],
          array: rest[5]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const elements = params.elements;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof elements === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "elements"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/enum".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof elements !== "undefined") {
        payload["elements"] = elements;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateEnumAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          elements: rest[2],
          required: rest[3],
          xdefault: rest[4],
          newKey: rest[5]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const elements = params.elements;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof elements === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "elements"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/enum/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof elements !== "undefined") {
        payload["elements"] = elements;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createFloatAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          min: rest[3],
          max: rest[4],
          xdefault: rest[5],
          array: rest[6]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const min = params.min;
      const max = params.max;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/float".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateFloatAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          min: rest[4],
          max: rest[5],
          newKey: rest[6]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const min = params.min;
      const max = params.max;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/float/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createIntegerAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          min: rest[3],
          max: rest[4],
          xdefault: rest[5],
          array: rest[6]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const min = params.min;
      const max = params.max;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/integer".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateIntegerAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          min: rest[4],
          max: rest[5],
          newKey: rest[6]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const min = params.min;
      const max = params.max;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/integer/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createIpAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          array: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/ip".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateIpAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/ip/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createLineAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/line".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateLineAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/line/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createPointAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/point".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updatePointAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/point/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createPolygonAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/polygon".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updatePolygonAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/polygon/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createRelationshipAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          relatedCollectionId: rest[1],
          type: rest[2],
          twoWay: rest[3],
          key: rest[4],
          twoWayKey: rest[5],
          onDelete: rest[6]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const relatedCollectionId = params.relatedCollectionId;
      const type = params.type;
      const twoWay = params.twoWay;
      const key = params.key;
      const twoWayKey = params.twoWayKey;
      const onDelete = params.onDelete;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof relatedCollectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "relatedCollectionId"');
      }
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/relationship".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof relatedCollectionId !== "undefined") {
        payload["relatedCollectionId"] = relatedCollectionId;
      }
      if (typeof type !== "undefined") {
        payload["type"] = type;
      }
      if (typeof twoWay !== "undefined") {
        payload["twoWay"] = twoWay;
      }
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof twoWayKey !== "undefined") {
        payload["twoWayKey"] = twoWayKey;
      }
      if (typeof onDelete !== "undefined") {
        payload["onDelete"] = onDelete;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createStringAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          size: rest[2],
          required: rest[3],
          xdefault: rest[4],
          array: rest[5],
          encrypt: rest[6]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const size = params.size;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      const encrypt = params.encrypt;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof size === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "size"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/string".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof size !== "undefined") {
        payload["size"] = size;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      if (typeof encrypt !== "undefined") {
        payload["encrypt"] = encrypt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateStringAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          size: rest[4],
          newKey: rest[5]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const size = params.size;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/string/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof size !== "undefined") {
        payload["size"] = size;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createUrlAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          array: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/url".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateUrlAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/url/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    getAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    deleteAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    updateRelationshipAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          onDelete: rest[2],
          newKey: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const onDelete = params.onDelete;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/{key}/relationship".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof onDelete !== "undefined") {
        payload["onDelete"] = onDelete;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    listDocuments(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          queries: rest[1],
          transactionId: rest[2],
          total: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const queries = params.queries;
      const transactionId = params.transactionId;
      const total = params.total;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createDocument(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          documentId: rest[1],
          data: rest[2],
          permissions: rest[3],
          transactionId: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const documentId = params.documentId;
      const data = params.data;
      const permissions = params.permissions;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "documentId"');
      }
      if (typeof data === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "data"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof documentId !== "undefined") {
        payload["documentId"] = documentId;
      }
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createDocuments(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          documents: rest[1],
          transactionId: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const documents = params.documents;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documents === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "documents"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof documents !== "undefined") {
        payload["documents"] = documents;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    upsertDocuments(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          documents: rest[1],
          transactionId: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const documents = params.documents;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documents === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "documents"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof documents !== "undefined") {
        payload["documents"] = documents;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    updateDocuments(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          data: rest[1],
          queries: rest[2],
          transactionId: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const data = params.data;
      const queries = params.queries;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    deleteDocuments(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          queries: rest[1],
          transactionId: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const queries = params.queries;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    getDocument(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          documentId: rest[1],
          queries: rest[2],
          transactionId: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const documentId = params.documentId;
      const queries = params.queries;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "documentId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    upsertDocument(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          documentId: rest[1],
          data: rest[2],
          permissions: rest[3],
          transactionId: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const documentId = params.documentId;
      const data = params.data;
      const permissions = params.permissions;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "documentId"');
      }
      if (typeof data === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "data"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
      const payload = {};
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    updateDocument(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          documentId: rest[1],
          data: rest[2],
          permissions: rest[3],
          transactionId: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const documentId = params.documentId;
      const data = params.data;
      const permissions = params.permissions;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "documentId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
      const payload = {};
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    deleteDocument(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          documentId: rest[1],
          transactionId: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const documentId = params.documentId;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "documentId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
      const payload = {};
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    decrementDocumentAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          documentId: rest[1],
          attribute: rest[2],
          value: rest[3],
          min: rest[4],
          transactionId: rest[5]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const documentId = params.documentId;
      const attribute = params.attribute;
      const value = params.value;
      const min = params.min;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "documentId"');
      }
      if (typeof attribute === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "attribute"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/decrement".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId).replace("{attribute}", attribute);
      const payload = {};
      if (typeof value !== "undefined") {
        payload["value"] = value;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    incrementDocumentAttribute(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          documentId: rest[1],
          attribute: rest[2],
          value: rest[3],
          max: rest[4],
          transactionId: rest[5]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const documentId = params.documentId;
      const attribute = params.attribute;
      const value = params.value;
      const max = params.max;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "documentId"');
      }
      if (typeof attribute === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "attribute"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/increment".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId).replace("{attribute}", attribute);
      const payload = {};
      if (typeof value !== "undefined") {
        payload["value"] = value;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    listIndexes(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          queries: rest[1],
          total: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const queries = params.queries;
      const total = params.total;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/indexes".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createIndex(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1],
          type: rest[2],
          attributes: rest[3],
          orders: rest[4],
          lengths: rest[5]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      const type = params.type;
      const attributes = params.attributes;
      const orders = params.orders;
      const lengths = params.lengths;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      if (typeof attributes === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "attributes"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/indexes".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof type !== "undefined") {
        payload["type"] = type;
      }
      if (typeof attributes !== "undefined") {
        payload["attributes"] = attributes;
      }
      if (typeof orders !== "undefined") {
        payload["orders"] = orders;
      }
      if (typeof lengths !== "undefined") {
        payload["lengths"] = lengths;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getIndex(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/indexes/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    deleteIndex(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          collectionId: rest[0],
          key: rest[1]
        };
      }
      const databaseId = params.databaseId;
      const collectionId = params.collectionId;
      const key = params.key;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/indexes/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
  }
  exports.Databases = Databases;
});

// node_modules/node-appwrite/dist/services/functions.js
var require_functions = __commonJS((exports) => {
  var client = require_client();

  class Functions {
    constructor(client2) {
      this.client = client2;
    }
    list(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst,
          search: rest[0],
          total: rest[1]
        };
      }
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      const apiPath = "/functions";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          name: rest[0],
          runtime: rest[1],
          execute: rest[2],
          events: rest[3],
          schedule: rest[4],
          timeout: rest[5],
          enabled: rest[6],
          logging: rest[7],
          entrypoint: rest[8],
          commands: rest[9],
          scopes: rest[10],
          installationId: rest[11],
          providerRepositoryId: rest[12],
          providerBranch: rest[13],
          providerSilentMode: rest[14],
          providerRootDirectory: rest[15],
          specification: rest[16]
        };
      }
      const functionId = params.functionId;
      const name = params.name;
      const runtime = params.runtime;
      const execute = params.execute;
      const events = params.events;
      const schedule = params.schedule;
      const timeout = params.timeout;
      const enabled = params.enabled;
      const logging = params.logging;
      const entrypoint = params.entrypoint;
      const commands = params.commands;
      const scopes = params.scopes;
      const installationId = params.installationId;
      const providerRepositoryId = params.providerRepositoryId;
      const providerBranch = params.providerBranch;
      const providerSilentMode = params.providerSilentMode;
      const providerRootDirectory = params.providerRootDirectory;
      const specification = params.specification;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      if (typeof runtime === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "runtime"');
      }
      const apiPath = "/functions";
      const payload = {};
      if (typeof functionId !== "undefined") {
        payload["functionId"] = functionId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof runtime !== "undefined") {
        payload["runtime"] = runtime;
      }
      if (typeof execute !== "undefined") {
        payload["execute"] = execute;
      }
      if (typeof events !== "undefined") {
        payload["events"] = events;
      }
      if (typeof schedule !== "undefined") {
        payload["schedule"] = schedule;
      }
      if (typeof timeout !== "undefined") {
        payload["timeout"] = timeout;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof logging !== "undefined") {
        payload["logging"] = logging;
      }
      if (typeof entrypoint !== "undefined") {
        payload["entrypoint"] = entrypoint;
      }
      if (typeof commands !== "undefined") {
        payload["commands"] = commands;
      }
      if (typeof scopes !== "undefined") {
        payload["scopes"] = scopes;
      }
      if (typeof installationId !== "undefined") {
        payload["installationId"] = installationId;
      }
      if (typeof providerRepositoryId !== "undefined") {
        payload["providerRepositoryId"] = providerRepositoryId;
      }
      if (typeof providerBranch !== "undefined") {
        payload["providerBranch"] = providerBranch;
      }
      if (typeof providerSilentMode !== "undefined") {
        payload["providerSilentMode"] = providerSilentMode;
      }
      if (typeof providerRootDirectory !== "undefined") {
        payload["providerRootDirectory"] = providerRootDirectory;
      }
      if (typeof specification !== "undefined") {
        payload["specification"] = specification;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    listRuntimes() {
      const apiPath = "/functions/runtimes";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listSpecifications() {
      const apiPath = "/functions/specifications";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst
        };
      }
      const functionId = params.functionId;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      const apiPath = "/functions/{functionId}".replace("{functionId}", functionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    update(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          name: rest[0],
          runtime: rest[1],
          execute: rest[2],
          events: rest[3],
          schedule: rest[4],
          timeout: rest[5],
          enabled: rest[6],
          logging: rest[7],
          entrypoint: rest[8],
          commands: rest[9],
          scopes: rest[10],
          installationId: rest[11],
          providerRepositoryId: rest[12],
          providerBranch: rest[13],
          providerSilentMode: rest[14],
          providerRootDirectory: rest[15],
          specification: rest[16]
        };
      }
      const functionId = params.functionId;
      const name = params.name;
      const runtime = params.runtime;
      const execute = params.execute;
      const events = params.events;
      const schedule = params.schedule;
      const timeout = params.timeout;
      const enabled = params.enabled;
      const logging = params.logging;
      const entrypoint = params.entrypoint;
      const commands = params.commands;
      const scopes = params.scopes;
      const installationId = params.installationId;
      const providerRepositoryId = params.providerRepositoryId;
      const providerBranch = params.providerBranch;
      const providerSilentMode = params.providerSilentMode;
      const providerRootDirectory = params.providerRootDirectory;
      const specification = params.specification;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/functions/{functionId}".replace("{functionId}", functionId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof runtime !== "undefined") {
        payload["runtime"] = runtime;
      }
      if (typeof execute !== "undefined") {
        payload["execute"] = execute;
      }
      if (typeof events !== "undefined") {
        payload["events"] = events;
      }
      if (typeof schedule !== "undefined") {
        payload["schedule"] = schedule;
      }
      if (typeof timeout !== "undefined") {
        payload["timeout"] = timeout;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof logging !== "undefined") {
        payload["logging"] = logging;
      }
      if (typeof entrypoint !== "undefined") {
        payload["entrypoint"] = entrypoint;
      }
      if (typeof commands !== "undefined") {
        payload["commands"] = commands;
      }
      if (typeof scopes !== "undefined") {
        payload["scopes"] = scopes;
      }
      if (typeof installationId !== "undefined") {
        payload["installationId"] = installationId;
      }
      if (typeof providerRepositoryId !== "undefined") {
        payload["providerRepositoryId"] = providerRepositoryId;
      }
      if (typeof providerBranch !== "undefined") {
        payload["providerBranch"] = providerBranch;
      }
      if (typeof providerSilentMode !== "undefined") {
        payload["providerSilentMode"] = providerSilentMode;
      }
      if (typeof providerRootDirectory !== "undefined") {
        payload["providerRootDirectory"] = providerRootDirectory;
      }
      if (typeof specification !== "undefined") {
        payload["specification"] = specification;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst
        };
      }
      const functionId = params.functionId;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      const apiPath = "/functions/{functionId}".replace("{functionId}", functionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    updateFunctionDeployment(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          deploymentId: rest[0]
        };
      }
      const functionId = params.functionId;
      const deploymentId = params.deploymentId;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/functions/{functionId}/deployment".replace("{functionId}", functionId);
      const payload = {};
      if (typeof deploymentId !== "undefined") {
        payload["deploymentId"] = deploymentId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    listDeployments(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          queries: rest[0],
          search: rest[1],
          total: rest[2]
        };
      }
      const functionId = params.functionId;
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      const apiPath = "/functions/{functionId}/deployments".replace("{functionId}", functionId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createDeployment(paramsOrFirst, ...rest) {
      let params;
      let onProgress;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
        onProgress = paramsOrFirst == null ? undefined : paramsOrFirst.onProgress;
      } else {
        params = {
          functionId: paramsOrFirst,
          code: rest[0],
          activate: rest[1],
          entrypoint: rest[2],
          commands: rest[3]
        };
        onProgress = rest[4];
      }
      const functionId = params.functionId;
      const code = params.code;
      const activate = params.activate;
      const entrypoint = params.entrypoint;
      const commands = params.commands;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof code === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "code"');
      }
      if (typeof activate === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "activate"');
      }
      const apiPath = "/functions/{functionId}/deployments".replace("{functionId}", functionId);
      const payload = {};
      if (typeof entrypoint !== "undefined") {
        payload["entrypoint"] = entrypoint;
      }
      if (typeof commands !== "undefined") {
        payload["commands"] = commands;
      }
      if (typeof code !== "undefined") {
        payload["code"] = code;
      }
      if (typeof activate !== "undefined") {
        payload["activate"] = activate;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "multipart/form-data"
      };
      return this.client.chunkedUpload("post", uri, apiHeaders, payload, onProgress);
    }
    createDuplicateDeployment(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          deploymentId: rest[0],
          buildId: rest[1]
        };
      }
      const functionId = params.functionId;
      const deploymentId = params.deploymentId;
      const buildId = params.buildId;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/functions/{functionId}/deployments/duplicate".replace("{functionId}", functionId);
      const payload = {};
      if (typeof deploymentId !== "undefined") {
        payload["deploymentId"] = deploymentId;
      }
      if (typeof buildId !== "undefined") {
        payload["buildId"] = buildId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createTemplateDeployment(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          repository: rest[0],
          owner: rest[1],
          rootDirectory: rest[2],
          version: rest[3],
          activate: rest[4]
        };
      }
      const functionId = params.functionId;
      const repository = params.repository;
      const owner = params.owner;
      const rootDirectory = params.rootDirectory;
      const version = params.version;
      const activate = params.activate;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof repository === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "repository"');
      }
      if (typeof owner === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "owner"');
      }
      if (typeof rootDirectory === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "rootDirectory"');
      }
      if (typeof version === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "version"');
      }
      const apiPath = "/functions/{functionId}/deployments/template".replace("{functionId}", functionId);
      const payload = {};
      if (typeof repository !== "undefined") {
        payload["repository"] = repository;
      }
      if (typeof owner !== "undefined") {
        payload["owner"] = owner;
      }
      if (typeof rootDirectory !== "undefined") {
        payload["rootDirectory"] = rootDirectory;
      }
      if (typeof version !== "undefined") {
        payload["version"] = version;
      }
      if (typeof activate !== "undefined") {
        payload["activate"] = activate;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createVcsDeployment(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          type: rest[0],
          reference: rest[1],
          activate: rest[2]
        };
      }
      const functionId = params.functionId;
      const type = params.type;
      const reference = params.reference;
      const activate = params.activate;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      if (typeof reference === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "reference"');
      }
      const apiPath = "/functions/{functionId}/deployments/vcs".replace("{functionId}", functionId);
      const payload = {};
      if (typeof type !== "undefined") {
        payload["type"] = type;
      }
      if (typeof reference !== "undefined") {
        payload["reference"] = reference;
      }
      if (typeof activate !== "undefined") {
        payload["activate"] = activate;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getDeployment(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          deploymentId: rest[0]
        };
      }
      const functionId = params.functionId;
      const deploymentId = params.deploymentId;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/functions/{functionId}/deployments/{deploymentId}".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    deleteDeployment(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          deploymentId: rest[0]
        };
      }
      const functionId = params.functionId;
      const deploymentId = params.deploymentId;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/functions/{functionId}/deployments/{deploymentId}".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    getDeploymentDownload(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          deploymentId: rest[0],
          type: rest[1]
        };
      }
      const functionId = params.functionId;
      const deploymentId = params.deploymentId;
      const type = params.type;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/functions/{functionId}/deployments/{deploymentId}/download".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
      const payload = {};
      if (typeof type !== "undefined") {
        payload["type"] = type;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    updateDeploymentStatus(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          deploymentId: rest[0]
        };
      }
      const functionId = params.functionId;
      const deploymentId = params.deploymentId;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/functions/{functionId}/deployments/{deploymentId}/status".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    listExecutions(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          queries: rest[0],
          total: rest[1]
        };
      }
      const functionId = params.functionId;
      const queries = params.queries;
      const total = params.total;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      const apiPath = "/functions/{functionId}/executions".replace("{functionId}", functionId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createExecution(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          body: rest[0],
          async: rest[1],
          xpath: rest[2],
          method: rest[3],
          headers: rest[4],
          scheduledAt: rest[5]
        };
      }
      const functionId = params.functionId;
      const body = params.body;
      const async = params.async;
      const xpath = params.xpath;
      const method = params.method;
      const headers = params.headers;
      const scheduledAt = params.scheduledAt;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      const apiPath = "/functions/{functionId}/executions".replace("{functionId}", functionId);
      const payload = {};
      if (typeof body !== "undefined") {
        payload["body"] = body;
      }
      if (typeof async !== "undefined") {
        payload["async"] = async;
      }
      if (typeof xpath !== "undefined") {
        payload["path"] = xpath;
      }
      if (typeof method !== "undefined") {
        payload["method"] = method;
      }
      if (typeof headers !== "undefined") {
        payload["headers"] = headers;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getExecution(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          executionId: rest[0]
        };
      }
      const functionId = params.functionId;
      const executionId = params.executionId;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof executionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "executionId"');
      }
      const apiPath = "/functions/{functionId}/executions/{executionId}".replace("{functionId}", functionId).replace("{executionId}", executionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    deleteExecution(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          executionId: rest[0]
        };
      }
      const functionId = params.functionId;
      const executionId = params.executionId;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof executionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "executionId"');
      }
      const apiPath = "/functions/{functionId}/executions/{executionId}".replace("{functionId}", functionId).replace("{executionId}", executionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    listVariables(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst
        };
      }
      const functionId = params.functionId;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      const apiPath = "/functions/{functionId}/variables".replace("{functionId}", functionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createVariable(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          key: rest[0],
          value: rest[1],
          secret: rest[2]
        };
      }
      const functionId = params.functionId;
      const key = params.key;
      const value = params.value;
      const secret = params.secret;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof value === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "value"');
      }
      const apiPath = "/functions/{functionId}/variables".replace("{functionId}", functionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof value !== "undefined") {
        payload["value"] = value;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getVariable(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          variableId: rest[0]
        };
      }
      const functionId = params.functionId;
      const variableId = params.variableId;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof variableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "variableId"');
      }
      const apiPath = "/functions/{functionId}/variables/{variableId}".replace("{functionId}", functionId).replace("{variableId}", variableId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateVariable(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          variableId: rest[0],
          key: rest[1],
          value: rest[2],
          secret: rest[3]
        };
      }
      const functionId = params.functionId;
      const variableId = params.variableId;
      const key = params.key;
      const value = params.value;
      const secret = params.secret;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof variableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "variableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/functions/{functionId}/variables/{variableId}".replace("{functionId}", functionId).replace("{variableId}", variableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof value !== "undefined") {
        payload["value"] = value;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    deleteVariable(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          functionId: paramsOrFirst,
          variableId: rest[0]
        };
      }
      const functionId = params.functionId;
      const variableId = params.variableId;
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof variableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "variableId"');
      }
      const apiPath = "/functions/{functionId}/variables/{variableId}".replace("{functionId}", functionId).replace("{variableId}", variableId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
  }
  exports.Functions = Functions;
});

// node_modules/node-appwrite/dist/services/graphql.js
var require_graphql = __commonJS((exports) => {
  var client = require_client();

  class Graphql {
    constructor(client2) {
      this.client = client2;
    }
    query(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "query" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          query: paramsOrFirst
        };
      }
      const query = params.query;
      if (typeof query === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "query"');
      }
      const apiPath = "/graphql";
      const payload = {};
      if (typeof query !== "undefined") {
        payload["query"] = query;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "x-sdk-graphql": "true",
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    mutation(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "query" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          query: paramsOrFirst
        };
      }
      const query = params.query;
      if (typeof query === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "query"');
      }
      const apiPath = "/graphql/mutation";
      const payload = {};
      if (typeof query !== "undefined") {
        payload["query"] = query;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "x-sdk-graphql": "true",
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
  }
  exports.Graphql = Graphql;
});

// node_modules/node-appwrite/dist/services/health.js
var require_health = __commonJS((exports) => {
  var client = require_client();

  class Health {
    constructor(client2) {
      this.client = client2;
    }
    get() {
      const apiPath = "/health";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getAntivirus() {
      const apiPath = "/health/anti-virus";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getCache() {
      const apiPath = "/health/cache";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getCertificate(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          domain: paramsOrFirst
        };
      }
      const domain = params.domain;
      const apiPath = "/health/certificate";
      const payload = {};
      if (typeof domain !== "undefined") {
        payload["domain"] = domain;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getDB() {
      const apiPath = "/health/db";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getPubSub() {
      const apiPath = "/health/pubsub";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getQueueBuilds(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          threshold: paramsOrFirst
        };
      }
      const threshold = params.threshold;
      const apiPath = "/health/queue/builds";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getQueueCertificates(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          threshold: paramsOrFirst
        };
      }
      const threshold = params.threshold;
      const apiPath = "/health/queue/certificates";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getQueueDatabases(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          name: paramsOrFirst,
          threshold: rest[0]
        };
      }
      const name = params.name;
      const threshold = params.threshold;
      const apiPath = "/health/queue/databases";
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getQueueDeletes(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          threshold: paramsOrFirst
        };
      }
      const threshold = params.threshold;
      const apiPath = "/health/queue/deletes";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getFailedJobs(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "name" in paramsOrFirst) {
        params = paramsOrFirst || {};
      } else {
        params = {
          name: paramsOrFirst,
          threshold: rest[0]
        };
      }
      const name = params.name;
      const threshold = params.threshold;
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/health/queue/failed/{name}".replace("{name}", name);
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getQueueFunctions(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          threshold: paramsOrFirst
        };
      }
      const threshold = params.threshold;
      const apiPath = "/health/queue/functions";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getQueueLogs(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          threshold: paramsOrFirst
        };
      }
      const threshold = params.threshold;
      const apiPath = "/health/queue/logs";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getQueueMails(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          threshold: paramsOrFirst
        };
      }
      const threshold = params.threshold;
      const apiPath = "/health/queue/mails";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getQueueMessaging(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          threshold: paramsOrFirst
        };
      }
      const threshold = params.threshold;
      const apiPath = "/health/queue/messaging";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getQueueMigrations(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          threshold: paramsOrFirst
        };
      }
      const threshold = params.threshold;
      const apiPath = "/health/queue/migrations";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getQueueStatsResources(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          threshold: paramsOrFirst
        };
      }
      const threshold = params.threshold;
      const apiPath = "/health/queue/stats-resources";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getQueueUsage(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          threshold: paramsOrFirst
        };
      }
      const threshold = params.threshold;
      const apiPath = "/health/queue/stats-usage";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getQueueWebhooks(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          threshold: paramsOrFirst
        };
      }
      const threshold = params.threshold;
      const apiPath = "/health/queue/webhooks";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getStorage() {
      const apiPath = "/health/storage";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getStorageLocal() {
      const apiPath = "/health/storage/local";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getTime() {
      const apiPath = "/health/time";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
  }
  exports.Health = Health;
});

// node_modules/node-appwrite/dist/services/locale.js
var require_locale = __commonJS((exports) => {
  class Locale {
    constructor(client) {
      this.client = client;
    }
    get() {
      const apiPath = "/locale";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listCodes() {
      const apiPath = "/locale/codes";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listContinents() {
      const apiPath = "/locale/continents";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listCountries() {
      const apiPath = "/locale/countries";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listCountriesEU() {
      const apiPath = "/locale/countries/eu";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listCountriesPhones() {
      const apiPath = "/locale/countries/phones";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listCurrencies() {
      const apiPath = "/locale/currencies";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listLanguages() {
      const apiPath = "/locale/languages";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
  }
  exports.Locale = Locale;
});

// node_modules/node-appwrite/dist/services/messaging.js
var require_messaging = __commonJS((exports) => {
  var client = require_client();

  class Messaging {
    constructor(client2) {
      this.client = client2;
    }
    listMessages(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst,
          search: rest[0],
          total: rest[1]
        };
      }
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      const apiPath = "/messaging/messages";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createEmail(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          messageId: paramsOrFirst,
          subject: rest[0],
          content: rest[1],
          topics: rest[2],
          users: rest[3],
          targets: rest[4],
          cc: rest[5],
          bcc: rest[6],
          attachments: rest[7],
          draft: rest[8],
          html: rest[9],
          scheduledAt: rest[10]
        };
      }
      const messageId = params.messageId;
      const subject = params.subject;
      const content = params.content;
      const topics = params.topics;
      const users = params.users;
      const targets = params.targets;
      const cc = params.cc;
      const bcc = params.bcc;
      const attachments = params.attachments;
      const draft = params.draft;
      const html = params.html;
      const scheduledAt = params.scheduledAt;
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      if (typeof subject === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "subject"');
      }
      if (typeof content === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "content"');
      }
      const apiPath = "/messaging/messages/email";
      const payload = {};
      if (typeof messageId !== "undefined") {
        payload["messageId"] = messageId;
      }
      if (typeof subject !== "undefined") {
        payload["subject"] = subject;
      }
      if (typeof content !== "undefined") {
        payload["content"] = content;
      }
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof cc !== "undefined") {
        payload["cc"] = cc;
      }
      if (typeof bcc !== "undefined") {
        payload["bcc"] = bcc;
      }
      if (typeof attachments !== "undefined") {
        payload["attachments"] = attachments;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof html !== "undefined") {
        payload["html"] = html;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateEmail(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          messageId: paramsOrFirst,
          topics: rest[0],
          users: rest[1],
          targets: rest[2],
          subject: rest[3],
          content: rest[4],
          draft: rest[5],
          html: rest[6],
          cc: rest[7],
          bcc: rest[8],
          scheduledAt: rest[9],
          attachments: rest[10]
        };
      }
      const messageId = params.messageId;
      const topics = params.topics;
      const users = params.users;
      const targets = params.targets;
      const subject = params.subject;
      const content = params.content;
      const draft = params.draft;
      const html = params.html;
      const cc = params.cc;
      const bcc = params.bcc;
      const scheduledAt = params.scheduledAt;
      const attachments = params.attachments;
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/email/{messageId}".replace("{messageId}", messageId);
      const payload = {};
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof subject !== "undefined") {
        payload["subject"] = subject;
      }
      if (typeof content !== "undefined") {
        payload["content"] = content;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof html !== "undefined") {
        payload["html"] = html;
      }
      if (typeof cc !== "undefined") {
        payload["cc"] = cc;
      }
      if (typeof bcc !== "undefined") {
        payload["bcc"] = bcc;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      if (typeof attachments !== "undefined") {
        payload["attachments"] = attachments;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createPush(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          messageId: paramsOrFirst,
          title: rest[0],
          body: rest[1],
          topics: rest[2],
          users: rest[3],
          targets: rest[4],
          data: rest[5],
          action: rest[6],
          image: rest[7],
          icon: rest[8],
          sound: rest[9],
          color: rest[10],
          tag: rest[11],
          badge: rest[12],
          draft: rest[13],
          scheduledAt: rest[14],
          contentAvailable: rest[15],
          critical: rest[16],
          priority: rest[17]
        };
      }
      const messageId = params.messageId;
      const title3 = params.title;
      const body = params.body;
      const topics = params.topics;
      const users = params.users;
      const targets = params.targets;
      const data = params.data;
      const action = params.action;
      const image = params.image;
      const icon = params.icon;
      const sound = params.sound;
      const color = params.color;
      const tag = params.tag;
      const badge = params.badge;
      const draft = params.draft;
      const scheduledAt = params.scheduledAt;
      const contentAvailable = params.contentAvailable;
      const critical = params.critical;
      const priority = params.priority;
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/push";
      const payload = {};
      if (typeof messageId !== "undefined") {
        payload["messageId"] = messageId;
      }
      if (typeof title3 !== "undefined") {
        payload["title"] = title3;
      }
      if (typeof body !== "undefined") {
        payload["body"] = body;
      }
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof action !== "undefined") {
        payload["action"] = action;
      }
      if (typeof image !== "undefined") {
        payload["image"] = image;
      }
      if (typeof icon !== "undefined") {
        payload["icon"] = icon;
      }
      if (typeof sound !== "undefined") {
        payload["sound"] = sound;
      }
      if (typeof color !== "undefined") {
        payload["color"] = color;
      }
      if (typeof tag !== "undefined") {
        payload["tag"] = tag;
      }
      if (typeof badge !== "undefined") {
        payload["badge"] = badge;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      if (typeof contentAvailable !== "undefined") {
        payload["contentAvailable"] = contentAvailable;
      }
      if (typeof critical !== "undefined") {
        payload["critical"] = critical;
      }
      if (typeof priority !== "undefined") {
        payload["priority"] = priority;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updatePush(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          messageId: paramsOrFirst,
          topics: rest[0],
          users: rest[1],
          targets: rest[2],
          title: rest[3],
          body: rest[4],
          data: rest[5],
          action: rest[6],
          image: rest[7],
          icon: rest[8],
          sound: rest[9],
          color: rest[10],
          tag: rest[11],
          badge: rest[12],
          draft: rest[13],
          scheduledAt: rest[14],
          contentAvailable: rest[15],
          critical: rest[16],
          priority: rest[17]
        };
      }
      const messageId = params.messageId;
      const topics = params.topics;
      const users = params.users;
      const targets = params.targets;
      const title3 = params.title;
      const body = params.body;
      const data = params.data;
      const action = params.action;
      const image = params.image;
      const icon = params.icon;
      const sound = params.sound;
      const color = params.color;
      const tag = params.tag;
      const badge = params.badge;
      const draft = params.draft;
      const scheduledAt = params.scheduledAt;
      const contentAvailable = params.contentAvailable;
      const critical = params.critical;
      const priority = params.priority;
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/push/{messageId}".replace("{messageId}", messageId);
      const payload = {};
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof title3 !== "undefined") {
        payload["title"] = title3;
      }
      if (typeof body !== "undefined") {
        payload["body"] = body;
      }
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof action !== "undefined") {
        payload["action"] = action;
      }
      if (typeof image !== "undefined") {
        payload["image"] = image;
      }
      if (typeof icon !== "undefined") {
        payload["icon"] = icon;
      }
      if (typeof sound !== "undefined") {
        payload["sound"] = sound;
      }
      if (typeof color !== "undefined") {
        payload["color"] = color;
      }
      if (typeof tag !== "undefined") {
        payload["tag"] = tag;
      }
      if (typeof badge !== "undefined") {
        payload["badge"] = badge;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      if (typeof contentAvailable !== "undefined") {
        payload["contentAvailable"] = contentAvailable;
      }
      if (typeof critical !== "undefined") {
        payload["critical"] = critical;
      }
      if (typeof priority !== "undefined") {
        payload["priority"] = priority;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createSms(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          messageId: paramsOrFirst,
          content: rest[0],
          topics: rest[1],
          users: rest[2],
          targets: rest[3],
          draft: rest[4],
          scheduledAt: rest[5]
        };
      }
      const messageId = params.messageId;
      const content = params.content;
      const topics = params.topics;
      const users = params.users;
      const targets = params.targets;
      const draft = params.draft;
      const scheduledAt = params.scheduledAt;
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      if (typeof content === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "content"');
      }
      const apiPath = "/messaging/messages/sms";
      const payload = {};
      if (typeof messageId !== "undefined") {
        payload["messageId"] = messageId;
      }
      if (typeof content !== "undefined") {
        payload["content"] = content;
      }
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createSMS(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          messageId: paramsOrFirst,
          content: rest[0],
          topics: rest[1],
          users: rest[2],
          targets: rest[3],
          draft: rest[4],
          scheduledAt: rest[5]
        };
      }
      const messageId = params.messageId;
      const content = params.content;
      const topics = params.topics;
      const users = params.users;
      const targets = params.targets;
      const draft = params.draft;
      const scheduledAt = params.scheduledAt;
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      if (typeof content === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "content"');
      }
      const apiPath = "/messaging/messages/sms";
      const payload = {};
      if (typeof messageId !== "undefined") {
        payload["messageId"] = messageId;
      }
      if (typeof content !== "undefined") {
        payload["content"] = content;
      }
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateSms(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          messageId: paramsOrFirst,
          topics: rest[0],
          users: rest[1],
          targets: rest[2],
          content: rest[3],
          draft: rest[4],
          scheduledAt: rest[5]
        };
      }
      const messageId = params.messageId;
      const topics = params.topics;
      const users = params.users;
      const targets = params.targets;
      const content = params.content;
      const draft = params.draft;
      const scheduledAt = params.scheduledAt;
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/sms/{messageId}".replace("{messageId}", messageId);
      const payload = {};
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof content !== "undefined") {
        payload["content"] = content;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    updateSMS(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          messageId: paramsOrFirst,
          topics: rest[0],
          users: rest[1],
          targets: rest[2],
          content: rest[3],
          draft: rest[4],
          scheduledAt: rest[5]
        };
      }
      const messageId = params.messageId;
      const topics = params.topics;
      const users = params.users;
      const targets = params.targets;
      const content = params.content;
      const draft = params.draft;
      const scheduledAt = params.scheduledAt;
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/sms/{messageId}".replace("{messageId}", messageId);
      const payload = {};
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof content !== "undefined") {
        payload["content"] = content;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    getMessage(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          messageId: paramsOrFirst
        };
      }
      const messageId = params.messageId;
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/{messageId}".replace("{messageId}", messageId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          messageId: paramsOrFirst
        };
      }
      const messageId = params.messageId;
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/{messageId}".replace("{messageId}", messageId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    listMessageLogs(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          messageId: paramsOrFirst,
          queries: rest[0],
          total: rest[1]
        };
      }
      const messageId = params.messageId;
      const queries = params.queries;
      const total = params.total;
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/{messageId}/logs".replace("{messageId}", messageId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listTargets(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          messageId: paramsOrFirst,
          queries: rest[0],
          total: rest[1]
        };
      }
      const messageId = params.messageId;
      const queries = params.queries;
      const total = params.total;
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/{messageId}/targets".replace("{messageId}", messageId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listProviders(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst,
          search: rest[0],
          total: rest[1]
        };
      }
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      const apiPath = "/messaging/providers";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createApnsProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          authKey: rest[1],
          authKeyId: rest[2],
          teamId: rest[3],
          bundleId: rest[4],
          sandbox: rest[5],
          enabled: rest[6]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const authKey = params.authKey;
      const authKeyId = params.authKeyId;
      const teamId = params.teamId;
      const bundleId = params.bundleId;
      const sandbox = params.sandbox;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/apns";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof authKey !== "undefined") {
        payload["authKey"] = authKey;
      }
      if (typeof authKeyId !== "undefined") {
        payload["authKeyId"] = authKeyId;
      }
      if (typeof teamId !== "undefined") {
        payload["teamId"] = teamId;
      }
      if (typeof bundleId !== "undefined") {
        payload["bundleId"] = bundleId;
      }
      if (typeof sandbox !== "undefined") {
        payload["sandbox"] = sandbox;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createAPNSProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          authKey: rest[1],
          authKeyId: rest[2],
          teamId: rest[3],
          bundleId: rest[4],
          sandbox: rest[5],
          enabled: rest[6]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const authKey = params.authKey;
      const authKeyId = params.authKeyId;
      const teamId = params.teamId;
      const bundleId = params.bundleId;
      const sandbox = params.sandbox;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/apns";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof authKey !== "undefined") {
        payload["authKey"] = authKey;
      }
      if (typeof authKeyId !== "undefined") {
        payload["authKeyId"] = authKeyId;
      }
      if (typeof teamId !== "undefined") {
        payload["teamId"] = teamId;
      }
      if (typeof bundleId !== "undefined") {
        payload["bundleId"] = bundleId;
      }
      if (typeof sandbox !== "undefined") {
        payload["sandbox"] = sandbox;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateApnsProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1],
          authKey: rest[2],
          authKeyId: rest[3],
          teamId: rest[4],
          bundleId: rest[5],
          sandbox: rest[6]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const enabled = params.enabled;
      const authKey = params.authKey;
      const authKeyId = params.authKeyId;
      const teamId = params.teamId;
      const bundleId = params.bundleId;
      const sandbox = params.sandbox;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/apns/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof authKey !== "undefined") {
        payload["authKey"] = authKey;
      }
      if (typeof authKeyId !== "undefined") {
        payload["authKeyId"] = authKeyId;
      }
      if (typeof teamId !== "undefined") {
        payload["teamId"] = teamId;
      }
      if (typeof bundleId !== "undefined") {
        payload["bundleId"] = bundleId;
      }
      if (typeof sandbox !== "undefined") {
        payload["sandbox"] = sandbox;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    updateAPNSProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1],
          authKey: rest[2],
          authKeyId: rest[3],
          teamId: rest[4],
          bundleId: rest[5],
          sandbox: rest[6]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const enabled = params.enabled;
      const authKey = params.authKey;
      const authKeyId = params.authKeyId;
      const teamId = params.teamId;
      const bundleId = params.bundleId;
      const sandbox = params.sandbox;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/apns/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof authKey !== "undefined") {
        payload["authKey"] = authKey;
      }
      if (typeof authKeyId !== "undefined") {
        payload["authKeyId"] = authKeyId;
      }
      if (typeof teamId !== "undefined") {
        payload["teamId"] = teamId;
      }
      if (typeof bundleId !== "undefined") {
        payload["bundleId"] = bundleId;
      }
      if (typeof sandbox !== "undefined") {
        payload["sandbox"] = sandbox;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createFcmProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          serviceAccountJSON: rest[1],
          enabled: rest[2]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const serviceAccountJSON = params.serviceAccountJSON;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/fcm";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof serviceAccountJSON !== "undefined") {
        payload["serviceAccountJSON"] = serviceAccountJSON;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createFCMProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          serviceAccountJSON: rest[1],
          enabled: rest[2]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const serviceAccountJSON = params.serviceAccountJSON;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/fcm";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof serviceAccountJSON !== "undefined") {
        payload["serviceAccountJSON"] = serviceAccountJSON;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateFcmProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1],
          serviceAccountJSON: rest[2]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const enabled = params.enabled;
      const serviceAccountJSON = params.serviceAccountJSON;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/fcm/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof serviceAccountJSON !== "undefined") {
        payload["serviceAccountJSON"] = serviceAccountJSON;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    updateFCMProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1],
          serviceAccountJSON: rest[2]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const enabled = params.enabled;
      const serviceAccountJSON = params.serviceAccountJSON;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/fcm/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof serviceAccountJSON !== "undefined") {
        payload["serviceAccountJSON"] = serviceAccountJSON;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createMailgunProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          apiKey: rest[1],
          domain: rest[2],
          isEuRegion: rest[3],
          fromName: rest[4],
          fromEmail: rest[5],
          replyToName: rest[6],
          replyToEmail: rest[7],
          enabled: rest[8]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const apiKey = params.apiKey;
      const domain = params.domain;
      const isEuRegion = params.isEuRegion;
      const fromName = params.fromName;
      const fromEmail = params.fromEmail;
      const replyToName = params.replyToName;
      const replyToEmail = params.replyToEmail;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/mailgun";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof domain !== "undefined") {
        payload["domain"] = domain;
      }
      if (typeof isEuRegion !== "undefined") {
        payload["isEuRegion"] = isEuRegion;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateMailgunProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          apiKey: rest[1],
          domain: rest[2],
          isEuRegion: rest[3],
          enabled: rest[4],
          fromName: rest[5],
          fromEmail: rest[6],
          replyToName: rest[7],
          replyToEmail: rest[8]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const apiKey = params.apiKey;
      const domain = params.domain;
      const isEuRegion = params.isEuRegion;
      const enabled = params.enabled;
      const fromName = params.fromName;
      const fromEmail = params.fromEmail;
      const replyToName = params.replyToName;
      const replyToEmail = params.replyToEmail;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/mailgun/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof domain !== "undefined") {
        payload["domain"] = domain;
      }
      if (typeof isEuRegion !== "undefined") {
        payload["isEuRegion"] = isEuRegion;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createMsg91Provider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          templateId: rest[1],
          senderId: rest[2],
          authKey: rest[3],
          enabled: rest[4]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const templateId = params.templateId;
      const senderId = params.senderId;
      const authKey = params.authKey;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/msg91";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof templateId !== "undefined") {
        payload["templateId"] = templateId;
      }
      if (typeof senderId !== "undefined") {
        payload["senderId"] = senderId;
      }
      if (typeof authKey !== "undefined") {
        payload["authKey"] = authKey;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateMsg91Provider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1],
          templateId: rest[2],
          senderId: rest[3],
          authKey: rest[4]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const enabled = params.enabled;
      const templateId = params.templateId;
      const senderId = params.senderId;
      const authKey = params.authKey;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/msg91/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof templateId !== "undefined") {
        payload["templateId"] = templateId;
      }
      if (typeof senderId !== "undefined") {
        payload["senderId"] = senderId;
      }
      if (typeof authKey !== "undefined") {
        payload["authKey"] = authKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createResendProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          apiKey: rest[1],
          fromName: rest[2],
          fromEmail: rest[3],
          replyToName: rest[4],
          replyToEmail: rest[5],
          enabled: rest[6]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const apiKey = params.apiKey;
      const fromName = params.fromName;
      const fromEmail = params.fromEmail;
      const replyToName = params.replyToName;
      const replyToEmail = params.replyToEmail;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/resend";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateResendProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1],
          apiKey: rest[2],
          fromName: rest[3],
          fromEmail: rest[4],
          replyToName: rest[5],
          replyToEmail: rest[6]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const enabled = params.enabled;
      const apiKey = params.apiKey;
      const fromName = params.fromName;
      const fromEmail = params.fromEmail;
      const replyToName = params.replyToName;
      const replyToEmail = params.replyToEmail;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/resend/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createSendgridProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          apiKey: rest[1],
          fromName: rest[2],
          fromEmail: rest[3],
          replyToName: rest[4],
          replyToEmail: rest[5],
          enabled: rest[6]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const apiKey = params.apiKey;
      const fromName = params.fromName;
      const fromEmail = params.fromEmail;
      const replyToName = params.replyToName;
      const replyToEmail = params.replyToEmail;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/sendgrid";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateSendgridProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1],
          apiKey: rest[2],
          fromName: rest[3],
          fromEmail: rest[4],
          replyToName: rest[5],
          replyToEmail: rest[6]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const enabled = params.enabled;
      const apiKey = params.apiKey;
      const fromName = params.fromName;
      const fromEmail = params.fromEmail;
      const replyToName = params.replyToName;
      const replyToEmail = params.replyToEmail;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/sendgrid/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createSmtpProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          host: rest[1],
          port: rest[2],
          username: rest[3],
          password: rest[4],
          encryption: rest[5],
          autoTLS: rest[6],
          mailer: rest[7],
          fromName: rest[8],
          fromEmail: rest[9],
          replyToName: rest[10],
          replyToEmail: rest[11],
          enabled: rest[12]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const host = params.host;
      const port = params.port;
      const username = params.username;
      const password = params.password;
      const encryption = params.encryption;
      const autoTLS = params.autoTLS;
      const mailer = params.mailer;
      const fromName = params.fromName;
      const fromEmail = params.fromEmail;
      const replyToName = params.replyToName;
      const replyToEmail = params.replyToEmail;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      if (typeof host === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "host"');
      }
      const apiPath = "/messaging/providers/smtp";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof host !== "undefined") {
        payload["host"] = host;
      }
      if (typeof port !== "undefined") {
        payload["port"] = port;
      }
      if (typeof username !== "undefined") {
        payload["username"] = username;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof encryption !== "undefined") {
        payload["encryption"] = encryption;
      }
      if (typeof autoTLS !== "undefined") {
        payload["autoTLS"] = autoTLS;
      }
      if (typeof mailer !== "undefined") {
        payload["mailer"] = mailer;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createSMTPProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          host: rest[1],
          port: rest[2],
          username: rest[3],
          password: rest[4],
          encryption: rest[5],
          autoTLS: rest[6],
          mailer: rest[7],
          fromName: rest[8],
          fromEmail: rest[9],
          replyToName: rest[10],
          replyToEmail: rest[11],
          enabled: rest[12]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const host = params.host;
      const port = params.port;
      const username = params.username;
      const password = params.password;
      const encryption = params.encryption;
      const autoTLS = params.autoTLS;
      const mailer = params.mailer;
      const fromName = params.fromName;
      const fromEmail = params.fromEmail;
      const replyToName = params.replyToName;
      const replyToEmail = params.replyToEmail;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      if (typeof host === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "host"');
      }
      const apiPath = "/messaging/providers/smtp";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof host !== "undefined") {
        payload["host"] = host;
      }
      if (typeof port !== "undefined") {
        payload["port"] = port;
      }
      if (typeof username !== "undefined") {
        payload["username"] = username;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof encryption !== "undefined") {
        payload["encryption"] = encryption;
      }
      if (typeof autoTLS !== "undefined") {
        payload["autoTLS"] = autoTLS;
      }
      if (typeof mailer !== "undefined") {
        payload["mailer"] = mailer;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateSmtpProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          host: rest[1],
          port: rest[2],
          username: rest[3],
          password: rest[4],
          encryption: rest[5],
          autoTLS: rest[6],
          mailer: rest[7],
          fromName: rest[8],
          fromEmail: rest[9],
          replyToName: rest[10],
          replyToEmail: rest[11],
          enabled: rest[12]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const host = params.host;
      const port = params.port;
      const username = params.username;
      const password = params.password;
      const encryption = params.encryption;
      const autoTLS = params.autoTLS;
      const mailer = params.mailer;
      const fromName = params.fromName;
      const fromEmail = params.fromEmail;
      const replyToName = params.replyToName;
      const replyToEmail = params.replyToEmail;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/smtp/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof host !== "undefined") {
        payload["host"] = host;
      }
      if (typeof port !== "undefined") {
        payload["port"] = port;
      }
      if (typeof username !== "undefined") {
        payload["username"] = username;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof encryption !== "undefined") {
        payload["encryption"] = encryption;
      }
      if (typeof autoTLS !== "undefined") {
        payload["autoTLS"] = autoTLS;
      }
      if (typeof mailer !== "undefined") {
        payload["mailer"] = mailer;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    updateSMTPProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          host: rest[1],
          port: rest[2],
          username: rest[3],
          password: rest[4],
          encryption: rest[5],
          autoTLS: rest[6],
          mailer: rest[7],
          fromName: rest[8],
          fromEmail: rest[9],
          replyToName: rest[10],
          replyToEmail: rest[11],
          enabled: rest[12]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const host = params.host;
      const port = params.port;
      const username = params.username;
      const password = params.password;
      const encryption = params.encryption;
      const autoTLS = params.autoTLS;
      const mailer = params.mailer;
      const fromName = params.fromName;
      const fromEmail = params.fromEmail;
      const replyToName = params.replyToName;
      const replyToEmail = params.replyToEmail;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/smtp/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof host !== "undefined") {
        payload["host"] = host;
      }
      if (typeof port !== "undefined") {
        payload["port"] = port;
      }
      if (typeof username !== "undefined") {
        payload["username"] = username;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof encryption !== "undefined") {
        payload["encryption"] = encryption;
      }
      if (typeof autoTLS !== "undefined") {
        payload["autoTLS"] = autoTLS;
      }
      if (typeof mailer !== "undefined") {
        payload["mailer"] = mailer;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createTelesignProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          from: rest[1],
          customerId: rest[2],
          apiKey: rest[3],
          enabled: rest[4]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const from = params.from;
      const customerId = params.customerId;
      const apiKey = params.apiKey;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/telesign";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      if (typeof customerId !== "undefined") {
        payload["customerId"] = customerId;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateTelesignProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1],
          customerId: rest[2],
          apiKey: rest[3],
          from: rest[4]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const enabled = params.enabled;
      const customerId = params.customerId;
      const apiKey = params.apiKey;
      const from = params.from;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/telesign/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof customerId !== "undefined") {
        payload["customerId"] = customerId;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createTextmagicProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          from: rest[1],
          username: rest[2],
          apiKey: rest[3],
          enabled: rest[4]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const from = params.from;
      const username = params.username;
      const apiKey = params.apiKey;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/textmagic";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      if (typeof username !== "undefined") {
        payload["username"] = username;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateTextmagicProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1],
          username: rest[2],
          apiKey: rest[3],
          from: rest[4]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const enabled = params.enabled;
      const username = params.username;
      const apiKey = params.apiKey;
      const from = params.from;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/textmagic/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof username !== "undefined") {
        payload["username"] = username;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createTwilioProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          from: rest[1],
          accountSid: rest[2],
          authToken: rest[3],
          enabled: rest[4]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const from = params.from;
      const accountSid = params.accountSid;
      const authToken = params.authToken;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/twilio";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      if (typeof accountSid !== "undefined") {
        payload["accountSid"] = accountSid;
      }
      if (typeof authToken !== "undefined") {
        payload["authToken"] = authToken;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateTwilioProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1],
          accountSid: rest[2],
          authToken: rest[3],
          from: rest[4]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const enabled = params.enabled;
      const accountSid = params.accountSid;
      const authToken = params.authToken;
      const from = params.from;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/twilio/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof accountSid !== "undefined") {
        payload["accountSid"] = accountSid;
      }
      if (typeof authToken !== "undefined") {
        payload["authToken"] = authToken;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createVonageProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          from: rest[1],
          apiKey: rest[2],
          apiSecret: rest[3],
          enabled: rest[4]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const from = params.from;
      const apiKey = params.apiKey;
      const apiSecret = params.apiSecret;
      const enabled = params.enabled;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/vonage";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof apiSecret !== "undefined") {
        payload["apiSecret"] = apiSecret;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateVonageProvider(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1],
          apiKey: rest[2],
          apiSecret: rest[3],
          from: rest[4]
        };
      }
      const providerId = params.providerId;
      const name = params.name;
      const enabled = params.enabled;
      const apiKey = params.apiKey;
      const apiSecret = params.apiSecret;
      const from = params.from;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/vonage/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof apiSecret !== "undefined") {
        payload["apiSecret"] = apiSecret;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    getProvider(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst
        };
      }
      const providerId = params.providerId;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    deleteProvider(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst
        };
      }
      const providerId = params.providerId;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    listProviderLogs(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          providerId: paramsOrFirst,
          queries: rest[0],
          total: rest[1]
        };
      }
      const providerId = params.providerId;
      const queries = params.queries;
      const total = params.total;
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/{providerId}/logs".replace("{providerId}", providerId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listSubscriberLogs(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          subscriberId: paramsOrFirst,
          queries: rest[0],
          total: rest[1]
        };
      }
      const subscriberId = params.subscriberId;
      const queries = params.queries;
      const total = params.total;
      if (typeof subscriberId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "subscriberId"');
      }
      const apiPath = "/messaging/subscribers/{subscriberId}/logs".replace("{subscriberId}", subscriberId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listTopics(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst,
          search: rest[0],
          total: rest[1]
        };
      }
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      const apiPath = "/messaging/topics";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createTopic(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          topicId: paramsOrFirst,
          name: rest[0],
          subscribe: rest[1]
        };
      }
      const topicId = params.topicId;
      const name = params.name;
      const subscribe = params.subscribe;
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/topics";
      const payload = {};
      if (typeof topicId !== "undefined") {
        payload["topicId"] = topicId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof subscribe !== "undefined") {
        payload["subscribe"] = subscribe;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getTopic(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          topicId: paramsOrFirst
        };
      }
      const topicId = params.topicId;
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      const apiPath = "/messaging/topics/{topicId}".replace("{topicId}", topicId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateTopic(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          topicId: paramsOrFirst,
          name: rest[0],
          subscribe: rest[1]
        };
      }
      const topicId = params.topicId;
      const name = params.name;
      const subscribe = params.subscribe;
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      const apiPath = "/messaging/topics/{topicId}".replace("{topicId}", topicId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof subscribe !== "undefined") {
        payload["subscribe"] = subscribe;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    deleteTopic(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          topicId: paramsOrFirst
        };
      }
      const topicId = params.topicId;
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      const apiPath = "/messaging/topics/{topicId}".replace("{topicId}", topicId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    listTopicLogs(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          topicId: paramsOrFirst,
          queries: rest[0],
          total: rest[1]
        };
      }
      const topicId = params.topicId;
      const queries = params.queries;
      const total = params.total;
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      const apiPath = "/messaging/topics/{topicId}/logs".replace("{topicId}", topicId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listSubscribers(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          topicId: paramsOrFirst,
          queries: rest[0],
          search: rest[1],
          total: rest[2]
        };
      }
      const topicId = params.topicId;
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      const apiPath = "/messaging/topics/{topicId}/subscribers".replace("{topicId}", topicId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createSubscriber(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          topicId: paramsOrFirst,
          subscriberId: rest[0],
          targetId: rest[1]
        };
      }
      const topicId = params.topicId;
      const subscriberId = params.subscriberId;
      const targetId = params.targetId;
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      if (typeof subscriberId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "subscriberId"');
      }
      if (typeof targetId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "targetId"');
      }
      const apiPath = "/messaging/topics/{topicId}/subscribers".replace("{topicId}", topicId);
      const payload = {};
      if (typeof subscriberId !== "undefined") {
        payload["subscriberId"] = subscriberId;
      }
      if (typeof targetId !== "undefined") {
        payload["targetId"] = targetId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getSubscriber(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          topicId: paramsOrFirst,
          subscriberId: rest[0]
        };
      }
      const topicId = params.topicId;
      const subscriberId = params.subscriberId;
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      if (typeof subscriberId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "subscriberId"');
      }
      const apiPath = "/messaging/topics/{topicId}/subscribers/{subscriberId}".replace("{topicId}", topicId).replace("{subscriberId}", subscriberId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    deleteSubscriber(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          topicId: paramsOrFirst,
          subscriberId: rest[0]
        };
      }
      const topicId = params.topicId;
      const subscriberId = params.subscriberId;
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      if (typeof subscriberId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "subscriberId"');
      }
      const apiPath = "/messaging/topics/{topicId}/subscribers/{subscriberId}".replace("{topicId}", topicId).replace("{subscriberId}", subscriberId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
  }
  exports.Messaging = Messaging;
});

// node_modules/node-appwrite/dist/services/sites.js
var require_sites = __commonJS((exports) => {
  var client = require_client();

  class Sites {
    constructor(client2) {
      this.client = client2;
    }
    list(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst,
          search: rest[0],
          total: rest[1]
        };
      }
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      const apiPath = "/sites";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          name: rest[0],
          framework: rest[1],
          buildRuntime: rest[2],
          enabled: rest[3],
          logging: rest[4],
          timeout: rest[5],
          installCommand: rest[6],
          buildCommand: rest[7],
          outputDirectory: rest[8],
          adapter: rest[9],
          installationId: rest[10],
          fallbackFile: rest[11],
          providerRepositoryId: rest[12],
          providerBranch: rest[13],
          providerSilentMode: rest[14],
          providerRootDirectory: rest[15],
          specification: rest[16]
        };
      }
      const siteId = params.siteId;
      const name = params.name;
      const framework = params.framework;
      const buildRuntime = params.buildRuntime;
      const enabled = params.enabled;
      const logging = params.logging;
      const timeout = params.timeout;
      const installCommand = params.installCommand;
      const buildCommand = params.buildCommand;
      const outputDirectory = params.outputDirectory;
      const adapter = params.adapter;
      const installationId = params.installationId;
      const fallbackFile = params.fallbackFile;
      const providerRepositoryId = params.providerRepositoryId;
      const providerBranch = params.providerBranch;
      const providerSilentMode = params.providerSilentMode;
      const providerRootDirectory = params.providerRootDirectory;
      const specification = params.specification;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      if (typeof framework === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "framework"');
      }
      if (typeof buildRuntime === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "buildRuntime"');
      }
      const apiPath = "/sites";
      const payload = {};
      if (typeof siteId !== "undefined") {
        payload["siteId"] = siteId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof framework !== "undefined") {
        payload["framework"] = framework;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof logging !== "undefined") {
        payload["logging"] = logging;
      }
      if (typeof timeout !== "undefined") {
        payload["timeout"] = timeout;
      }
      if (typeof installCommand !== "undefined") {
        payload["installCommand"] = installCommand;
      }
      if (typeof buildCommand !== "undefined") {
        payload["buildCommand"] = buildCommand;
      }
      if (typeof outputDirectory !== "undefined") {
        payload["outputDirectory"] = outputDirectory;
      }
      if (typeof buildRuntime !== "undefined") {
        payload["buildRuntime"] = buildRuntime;
      }
      if (typeof adapter !== "undefined") {
        payload["adapter"] = adapter;
      }
      if (typeof installationId !== "undefined") {
        payload["installationId"] = installationId;
      }
      if (typeof fallbackFile !== "undefined") {
        payload["fallbackFile"] = fallbackFile;
      }
      if (typeof providerRepositoryId !== "undefined") {
        payload["providerRepositoryId"] = providerRepositoryId;
      }
      if (typeof providerBranch !== "undefined") {
        payload["providerBranch"] = providerBranch;
      }
      if (typeof providerSilentMode !== "undefined") {
        payload["providerSilentMode"] = providerSilentMode;
      }
      if (typeof providerRootDirectory !== "undefined") {
        payload["providerRootDirectory"] = providerRootDirectory;
      }
      if (typeof specification !== "undefined") {
        payload["specification"] = specification;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    listFrameworks() {
      const apiPath = "/sites/frameworks";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listSpecifications() {
      const apiPath = "/sites/specifications";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst
        };
      }
      const siteId = params.siteId;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      const apiPath = "/sites/{siteId}".replace("{siteId}", siteId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    update(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          name: rest[0],
          framework: rest[1],
          enabled: rest[2],
          logging: rest[3],
          timeout: rest[4],
          installCommand: rest[5],
          buildCommand: rest[6],
          outputDirectory: rest[7],
          buildRuntime: rest[8],
          adapter: rest[9],
          fallbackFile: rest[10],
          installationId: rest[11],
          providerRepositoryId: rest[12],
          providerBranch: rest[13],
          providerSilentMode: rest[14],
          providerRootDirectory: rest[15],
          specification: rest[16]
        };
      }
      const siteId = params.siteId;
      const name = params.name;
      const framework = params.framework;
      const enabled = params.enabled;
      const logging = params.logging;
      const timeout = params.timeout;
      const installCommand = params.installCommand;
      const buildCommand = params.buildCommand;
      const outputDirectory = params.outputDirectory;
      const buildRuntime = params.buildRuntime;
      const adapter = params.adapter;
      const fallbackFile = params.fallbackFile;
      const installationId = params.installationId;
      const providerRepositoryId = params.providerRepositoryId;
      const providerBranch = params.providerBranch;
      const providerSilentMode = params.providerSilentMode;
      const providerRootDirectory = params.providerRootDirectory;
      const specification = params.specification;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      if (typeof framework === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "framework"');
      }
      const apiPath = "/sites/{siteId}".replace("{siteId}", siteId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof framework !== "undefined") {
        payload["framework"] = framework;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof logging !== "undefined") {
        payload["logging"] = logging;
      }
      if (typeof timeout !== "undefined") {
        payload["timeout"] = timeout;
      }
      if (typeof installCommand !== "undefined") {
        payload["installCommand"] = installCommand;
      }
      if (typeof buildCommand !== "undefined") {
        payload["buildCommand"] = buildCommand;
      }
      if (typeof outputDirectory !== "undefined") {
        payload["outputDirectory"] = outputDirectory;
      }
      if (typeof buildRuntime !== "undefined") {
        payload["buildRuntime"] = buildRuntime;
      }
      if (typeof adapter !== "undefined") {
        payload["adapter"] = adapter;
      }
      if (typeof fallbackFile !== "undefined") {
        payload["fallbackFile"] = fallbackFile;
      }
      if (typeof installationId !== "undefined") {
        payload["installationId"] = installationId;
      }
      if (typeof providerRepositoryId !== "undefined") {
        payload["providerRepositoryId"] = providerRepositoryId;
      }
      if (typeof providerBranch !== "undefined") {
        payload["providerBranch"] = providerBranch;
      }
      if (typeof providerSilentMode !== "undefined") {
        payload["providerSilentMode"] = providerSilentMode;
      }
      if (typeof providerRootDirectory !== "undefined") {
        payload["providerRootDirectory"] = providerRootDirectory;
      }
      if (typeof specification !== "undefined") {
        payload["specification"] = specification;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst
        };
      }
      const siteId = params.siteId;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      const apiPath = "/sites/{siteId}".replace("{siteId}", siteId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    updateSiteDeployment(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          deploymentId: rest[0]
        };
      }
      const siteId = params.siteId;
      const deploymentId = params.deploymentId;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/sites/{siteId}/deployment".replace("{siteId}", siteId);
      const payload = {};
      if (typeof deploymentId !== "undefined") {
        payload["deploymentId"] = deploymentId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    listDeployments(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          queries: rest[0],
          search: rest[1],
          total: rest[2]
        };
      }
      const siteId = params.siteId;
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      const apiPath = "/sites/{siteId}/deployments".replace("{siteId}", siteId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createDeployment(paramsOrFirst, ...rest) {
      let params;
      let onProgress;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
        onProgress = paramsOrFirst == null ? undefined : paramsOrFirst.onProgress;
      } else {
        params = {
          siteId: paramsOrFirst,
          code: rest[0],
          activate: rest[1],
          installCommand: rest[2],
          buildCommand: rest[3],
          outputDirectory: rest[4]
        };
        onProgress = rest[5];
      }
      const siteId = params.siteId;
      const code = params.code;
      const activate = params.activate;
      const installCommand = params.installCommand;
      const buildCommand = params.buildCommand;
      const outputDirectory = params.outputDirectory;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof code === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "code"');
      }
      if (typeof activate === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "activate"');
      }
      const apiPath = "/sites/{siteId}/deployments".replace("{siteId}", siteId);
      const payload = {};
      if (typeof installCommand !== "undefined") {
        payload["installCommand"] = installCommand;
      }
      if (typeof buildCommand !== "undefined") {
        payload["buildCommand"] = buildCommand;
      }
      if (typeof outputDirectory !== "undefined") {
        payload["outputDirectory"] = outputDirectory;
      }
      if (typeof code !== "undefined") {
        payload["code"] = code;
      }
      if (typeof activate !== "undefined") {
        payload["activate"] = activate;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "multipart/form-data"
      };
      return this.client.chunkedUpload("post", uri, apiHeaders, payload, onProgress);
    }
    createDuplicateDeployment(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          deploymentId: rest[0]
        };
      }
      const siteId = params.siteId;
      const deploymentId = params.deploymentId;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/sites/{siteId}/deployments/duplicate".replace("{siteId}", siteId);
      const payload = {};
      if (typeof deploymentId !== "undefined") {
        payload["deploymentId"] = deploymentId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createTemplateDeployment(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          repository: rest[0],
          owner: rest[1],
          rootDirectory: rest[2],
          version: rest[3],
          activate: rest[4]
        };
      }
      const siteId = params.siteId;
      const repository = params.repository;
      const owner = params.owner;
      const rootDirectory = params.rootDirectory;
      const version = params.version;
      const activate = params.activate;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof repository === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "repository"');
      }
      if (typeof owner === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "owner"');
      }
      if (typeof rootDirectory === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "rootDirectory"');
      }
      if (typeof version === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "version"');
      }
      const apiPath = "/sites/{siteId}/deployments/template".replace("{siteId}", siteId);
      const payload = {};
      if (typeof repository !== "undefined") {
        payload["repository"] = repository;
      }
      if (typeof owner !== "undefined") {
        payload["owner"] = owner;
      }
      if (typeof rootDirectory !== "undefined") {
        payload["rootDirectory"] = rootDirectory;
      }
      if (typeof version !== "undefined") {
        payload["version"] = version;
      }
      if (typeof activate !== "undefined") {
        payload["activate"] = activate;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createVcsDeployment(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          type: rest[0],
          reference: rest[1],
          activate: rest[2]
        };
      }
      const siteId = params.siteId;
      const type = params.type;
      const reference = params.reference;
      const activate = params.activate;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      if (typeof reference === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "reference"');
      }
      const apiPath = "/sites/{siteId}/deployments/vcs".replace("{siteId}", siteId);
      const payload = {};
      if (typeof type !== "undefined") {
        payload["type"] = type;
      }
      if (typeof reference !== "undefined") {
        payload["reference"] = reference;
      }
      if (typeof activate !== "undefined") {
        payload["activate"] = activate;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getDeployment(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          deploymentId: rest[0]
        };
      }
      const siteId = params.siteId;
      const deploymentId = params.deploymentId;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/sites/{siteId}/deployments/{deploymentId}".replace("{siteId}", siteId).replace("{deploymentId}", deploymentId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    deleteDeployment(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          deploymentId: rest[0]
        };
      }
      const siteId = params.siteId;
      const deploymentId = params.deploymentId;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/sites/{siteId}/deployments/{deploymentId}".replace("{siteId}", siteId).replace("{deploymentId}", deploymentId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    getDeploymentDownload(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          deploymentId: rest[0],
          type: rest[1]
        };
      }
      const siteId = params.siteId;
      const deploymentId = params.deploymentId;
      const type = params.type;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/sites/{siteId}/deployments/{deploymentId}/download".replace("{siteId}", siteId).replace("{deploymentId}", deploymentId);
      const payload = {};
      if (typeof type !== "undefined") {
        payload["type"] = type;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    updateDeploymentStatus(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          deploymentId: rest[0]
        };
      }
      const siteId = params.siteId;
      const deploymentId = params.deploymentId;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/sites/{siteId}/deployments/{deploymentId}/status".replace("{siteId}", siteId).replace("{deploymentId}", deploymentId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    listLogs(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          queries: rest[0],
          total: rest[1]
        };
      }
      const siteId = params.siteId;
      const queries = params.queries;
      const total = params.total;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      const apiPath = "/sites/{siteId}/logs".replace("{siteId}", siteId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getLog(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          logId: rest[0]
        };
      }
      const siteId = params.siteId;
      const logId = params.logId;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof logId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "logId"');
      }
      const apiPath = "/sites/{siteId}/logs/{logId}".replace("{siteId}", siteId).replace("{logId}", logId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    deleteLog(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          logId: rest[0]
        };
      }
      const siteId = params.siteId;
      const logId = params.logId;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof logId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "logId"');
      }
      const apiPath = "/sites/{siteId}/logs/{logId}".replace("{siteId}", siteId).replace("{logId}", logId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    listVariables(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst
        };
      }
      const siteId = params.siteId;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      const apiPath = "/sites/{siteId}/variables".replace("{siteId}", siteId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createVariable(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          key: rest[0],
          value: rest[1],
          secret: rest[2]
        };
      }
      const siteId = params.siteId;
      const key = params.key;
      const value = params.value;
      const secret = params.secret;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof value === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "value"');
      }
      const apiPath = "/sites/{siteId}/variables".replace("{siteId}", siteId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof value !== "undefined") {
        payload["value"] = value;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getVariable(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          variableId: rest[0]
        };
      }
      const siteId = params.siteId;
      const variableId = params.variableId;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof variableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "variableId"');
      }
      const apiPath = "/sites/{siteId}/variables/{variableId}".replace("{siteId}", siteId).replace("{variableId}", variableId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateVariable(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          variableId: rest[0],
          key: rest[1],
          value: rest[2],
          secret: rest[3]
        };
      }
      const siteId = params.siteId;
      const variableId = params.variableId;
      const key = params.key;
      const value = params.value;
      const secret = params.secret;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof variableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "variableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/sites/{siteId}/variables/{variableId}".replace("{siteId}", siteId).replace("{variableId}", variableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof value !== "undefined") {
        payload["value"] = value;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    deleteVariable(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          siteId: paramsOrFirst,
          variableId: rest[0]
        };
      }
      const siteId = params.siteId;
      const variableId = params.variableId;
      if (typeof siteId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "siteId"');
      }
      if (typeof variableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "variableId"');
      }
      const apiPath = "/sites/{siteId}/variables/{variableId}".replace("{siteId}", siteId).replace("{variableId}", variableId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
  }
  exports.Sites = Sites;
});

// node_modules/node-appwrite/dist/services/storage.js
var require_storage = __commonJS((exports) => {
  var client = require_client();

  class Storage {
    constructor(client2) {
      this.client = client2;
    }
    listBuckets(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst,
          search: rest[0],
          total: rest[1]
        };
      }
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      const apiPath = "/storage/buckets";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createBucket(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          bucketId: paramsOrFirst,
          name: rest[0],
          permissions: rest[1],
          fileSecurity: rest[2],
          enabled: rest[3],
          maximumFileSize: rest[4],
          allowedFileExtensions: rest[5],
          compression: rest[6],
          encryption: rest[7],
          antivirus: rest[8]
        };
      }
      const bucketId = params.bucketId;
      const name = params.name;
      const permissions = params.permissions;
      const fileSecurity = params.fileSecurity;
      const enabled = params.enabled;
      const maximumFileSize = params.maximumFileSize;
      const allowedFileExtensions = params.allowedFileExtensions;
      const compression = params.compression;
      const encryption = params.encryption;
      const antivirus = params.antivirus;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/storage/buckets";
      const payload = {};
      if (typeof bucketId !== "undefined") {
        payload["bucketId"] = bucketId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof fileSecurity !== "undefined") {
        payload["fileSecurity"] = fileSecurity;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof maximumFileSize !== "undefined") {
        payload["maximumFileSize"] = maximumFileSize;
      }
      if (typeof allowedFileExtensions !== "undefined") {
        payload["allowedFileExtensions"] = allowedFileExtensions;
      }
      if (typeof compression !== "undefined") {
        payload["compression"] = compression;
      }
      if (typeof encryption !== "undefined") {
        payload["encryption"] = encryption;
      }
      if (typeof antivirus !== "undefined") {
        payload["antivirus"] = antivirus;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getBucket(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          bucketId: paramsOrFirst
        };
      }
      const bucketId = params.bucketId;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      const apiPath = "/storage/buckets/{bucketId}".replace("{bucketId}", bucketId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateBucket(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          bucketId: paramsOrFirst,
          name: rest[0],
          permissions: rest[1],
          fileSecurity: rest[2],
          enabled: rest[3],
          maximumFileSize: rest[4],
          allowedFileExtensions: rest[5],
          compression: rest[6],
          encryption: rest[7],
          antivirus: rest[8]
        };
      }
      const bucketId = params.bucketId;
      const name = params.name;
      const permissions = params.permissions;
      const fileSecurity = params.fileSecurity;
      const enabled = params.enabled;
      const maximumFileSize = params.maximumFileSize;
      const allowedFileExtensions = params.allowedFileExtensions;
      const compression = params.compression;
      const encryption = params.encryption;
      const antivirus = params.antivirus;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/storage/buckets/{bucketId}".replace("{bucketId}", bucketId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof fileSecurity !== "undefined") {
        payload["fileSecurity"] = fileSecurity;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof maximumFileSize !== "undefined") {
        payload["maximumFileSize"] = maximumFileSize;
      }
      if (typeof allowedFileExtensions !== "undefined") {
        payload["allowedFileExtensions"] = allowedFileExtensions;
      }
      if (typeof compression !== "undefined") {
        payload["compression"] = compression;
      }
      if (typeof encryption !== "undefined") {
        payload["encryption"] = encryption;
      }
      if (typeof antivirus !== "undefined") {
        payload["antivirus"] = antivirus;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    deleteBucket(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          bucketId: paramsOrFirst
        };
      }
      const bucketId = params.bucketId;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      const apiPath = "/storage/buckets/{bucketId}".replace("{bucketId}", bucketId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    listFiles(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          bucketId: paramsOrFirst,
          queries: rest[0],
          search: rest[1],
          total: rest[2]
        };
      }
      const bucketId = params.bucketId;
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files".replace("{bucketId}", bucketId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createFile(paramsOrFirst, ...rest) {
      let params;
      let onProgress;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
        onProgress = paramsOrFirst == null ? undefined : paramsOrFirst.onProgress;
      } else {
        params = {
          bucketId: paramsOrFirst,
          fileId: rest[0],
          file: rest[1],
          permissions: rest[2]
        };
        onProgress = rest[3];
      }
      const bucketId = params.bucketId;
      const fileId = params.fileId;
      const file = params.file;
      const permissions = params.permissions;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      if (typeof file === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "file"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files".replace("{bucketId}", bucketId);
      const payload = {};
      if (typeof fileId !== "undefined") {
        payload["fileId"] = fileId;
      }
      if (typeof file !== "undefined") {
        payload["file"] = file;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "multipart/form-data"
      };
      return this.client.chunkedUpload("post", uri, apiHeaders, payload, onProgress);
    }
    getFile(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          bucketId: paramsOrFirst,
          fileId: rest[0]
        };
      }
      const bucketId = params.bucketId;
      const fileId = params.fileId;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateFile(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          bucketId: paramsOrFirst,
          fileId: rest[0],
          name: rest[1],
          permissions: rest[2]
        };
      }
      const bucketId = params.bucketId;
      const fileId = params.fileId;
      const name = params.name;
      const permissions = params.permissions;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    deleteFile(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          bucketId: paramsOrFirst,
          fileId: rest[0]
        };
      }
      const bucketId = params.bucketId;
      const fileId = params.fileId;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    getFileDownload(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          bucketId: paramsOrFirst,
          fileId: rest[0],
          token: rest[1]
        };
      }
      const bucketId = params.bucketId;
      const fileId = params.fileId;
      const token = params.token;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files/{fileId}/download".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      if (typeof token !== "undefined") {
        payload["token"] = token;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    getFilePreview(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          bucketId: paramsOrFirst,
          fileId: rest[0],
          width: rest[1],
          height: rest[2],
          gravity: rest[3],
          quality: rest[4],
          borderWidth: rest[5],
          borderColor: rest[6],
          borderRadius: rest[7],
          opacity: rest[8],
          rotation: rest[9],
          background: rest[10],
          output: rest[11],
          token: rest[12]
        };
      }
      const bucketId = params.bucketId;
      const fileId = params.fileId;
      const width = params.width;
      const height = params.height;
      const gravity = params.gravity;
      const quality = params.quality;
      const borderWidth = params.borderWidth;
      const borderColor = params.borderColor;
      const borderRadius = params.borderRadius;
      const opacity = params.opacity;
      const rotation = params.rotation;
      const background = params.background;
      const output = params.output;
      const token = params.token;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files/{fileId}/preview".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      if (typeof width !== "undefined") {
        payload["width"] = width;
      }
      if (typeof height !== "undefined") {
        payload["height"] = height;
      }
      if (typeof gravity !== "undefined") {
        payload["gravity"] = gravity;
      }
      if (typeof quality !== "undefined") {
        payload["quality"] = quality;
      }
      if (typeof borderWidth !== "undefined") {
        payload["borderWidth"] = borderWidth;
      }
      if (typeof borderColor !== "undefined") {
        payload["borderColor"] = borderColor;
      }
      if (typeof borderRadius !== "undefined") {
        payload["borderRadius"] = borderRadius;
      }
      if (typeof opacity !== "undefined") {
        payload["opacity"] = opacity;
      }
      if (typeof rotation !== "undefined") {
        payload["rotation"] = rotation;
      }
      if (typeof background !== "undefined") {
        payload["background"] = background;
      }
      if (typeof output !== "undefined") {
        payload["output"] = output;
      }
      if (typeof token !== "undefined") {
        payload["token"] = token;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    getFileView(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          bucketId: paramsOrFirst,
          fileId: rest[0],
          token: rest[1]
        };
      }
      const bucketId = params.bucketId;
      const fileId = params.fileId;
      const token = params.token;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files/{fileId}/view".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      if (typeof token !== "undefined") {
        payload["token"] = token;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
  }
  exports.Storage = Storage;
});

// node_modules/node-appwrite/dist/services/tables-db.js
var require_tables_db = __commonJS((exports) => {
  var client = require_client();

  class TablesDB {
    constructor(client2) {
      this.client = client2;
    }
    list(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst,
          search: rest[0],
          total: rest[1]
        };
      }
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      const apiPath = "/tablesdb";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1]
        };
      }
      const databaseId = params.databaseId;
      const name = params.name;
      const enabled = params.enabled;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/tablesdb";
      const payload = {};
      if (typeof databaseId !== "undefined") {
        payload["databaseId"] = databaseId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    listTransactions(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst
        };
      }
      const queries = params.queries;
      const apiPath = "/tablesdb/transactions";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createTransaction(paramsOrFirst) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          ttl: paramsOrFirst
        };
      }
      const ttl = params.ttl;
      const apiPath = "/tablesdb/transactions";
      const payload = {};
      if (typeof ttl !== "undefined") {
        payload["ttl"] = ttl;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getTransaction(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          transactionId: paramsOrFirst
        };
      }
      const transactionId = params.transactionId;
      if (typeof transactionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "transactionId"');
      }
      const apiPath = "/tablesdb/transactions/{transactionId}".replace("{transactionId}", transactionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateTransaction(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          transactionId: paramsOrFirst,
          commit: rest[0],
          rollback: rest[1]
        };
      }
      const transactionId = params.transactionId;
      const commit = params.commit;
      const rollback = params.rollback;
      if (typeof transactionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "transactionId"');
      }
      const apiPath = "/tablesdb/transactions/{transactionId}".replace("{transactionId}", transactionId);
      const payload = {};
      if (typeof commit !== "undefined") {
        payload["commit"] = commit;
      }
      if (typeof rollback !== "undefined") {
        payload["rollback"] = rollback;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    deleteTransaction(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          transactionId: paramsOrFirst
        };
      }
      const transactionId = params.transactionId;
      if (typeof transactionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "transactionId"');
      }
      const apiPath = "/tablesdb/transactions/{transactionId}".replace("{transactionId}", transactionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    createOperations(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          transactionId: paramsOrFirst,
          operations: rest[0]
        };
      }
      const transactionId = params.transactionId;
      const operations = params.operations;
      if (typeof transactionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "transactionId"');
      }
      const apiPath = "/tablesdb/transactions/{transactionId}/operations".replace("{transactionId}", transactionId);
      const payload = {};
      if (typeof operations !== "undefined") {
        payload["operations"] = operations;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst
        };
      }
      const databaseId = params.databaseId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      const apiPath = "/tablesdb/{databaseId}".replace("{databaseId}", databaseId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    update(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          name: rest[0],
          enabled: rest[1]
        };
      }
      const databaseId = params.databaseId;
      const name = params.name;
      const enabled = params.enabled;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/tablesdb/{databaseId}".replace("{databaseId}", databaseId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst
        };
      }
      const databaseId = params.databaseId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      const apiPath = "/tablesdb/{databaseId}".replace("{databaseId}", databaseId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    listTables(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          queries: rest[0],
          search: rest[1],
          total: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables".replace("{databaseId}", databaseId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createTable(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          name: rest[1],
          permissions: rest[2],
          rowSecurity: rest[3],
          enabled: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const name = params.name;
      const permissions = params.permissions;
      const rowSecurity = params.rowSecurity;
      const enabled = params.enabled;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables".replace("{databaseId}", databaseId);
      const payload = {};
      if (typeof tableId !== "undefined") {
        payload["tableId"] = tableId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof rowSecurity !== "undefined") {
        payload["rowSecurity"] = rowSecurity;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getTable(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateTable(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          name: rest[1],
          permissions: rest[2],
          rowSecurity: rest[3],
          enabled: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const name = params.name;
      const permissions = params.permissions;
      const rowSecurity = params.rowSecurity;
      const enabled = params.enabled;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof rowSecurity !== "undefined") {
        payload["rowSecurity"] = rowSecurity;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    deleteTable(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    listColumns(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          queries: rest[1],
          total: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const queries = params.queries;
      const total = params.total;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createBooleanColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          array: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/boolean".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateBooleanColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/boolean/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createDatetimeColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          array: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/datetime".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateDatetimeColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/datetime/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createEmailColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          array: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/email".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateEmailColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/email/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createEnumColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          elements: rest[2],
          required: rest[3],
          xdefault: rest[4],
          array: rest[5]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const elements = params.elements;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof elements === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "elements"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/enum".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof elements !== "undefined") {
        payload["elements"] = elements;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateEnumColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          elements: rest[2],
          required: rest[3],
          xdefault: rest[4],
          newKey: rest[5]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const elements = params.elements;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof elements === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "elements"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/enum/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      if (typeof elements !== "undefined") {
        payload["elements"] = elements;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createFloatColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          min: rest[3],
          max: rest[4],
          xdefault: rest[5],
          array: rest[6]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const min = params.min;
      const max = params.max;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/float".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateFloatColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          min: rest[4],
          max: rest[5],
          newKey: rest[6]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const min = params.min;
      const max = params.max;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/float/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createIntegerColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          min: rest[3],
          max: rest[4],
          xdefault: rest[5],
          array: rest[6]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const min = params.min;
      const max = params.max;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/integer".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateIntegerColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          min: rest[4],
          max: rest[5],
          newKey: rest[6]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const min = params.min;
      const max = params.max;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/integer/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createIpColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          array: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/ip".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateIpColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/ip/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createLineColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/line".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateLineColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/line/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createPointColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/point".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updatePointColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/point/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createPolygonColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/polygon".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updatePolygonColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/polygon/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createRelationshipColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          relatedTableId: rest[1],
          type: rest[2],
          twoWay: rest[3],
          key: rest[4],
          twoWayKey: rest[5],
          onDelete: rest[6]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const relatedTableId = params.relatedTableId;
      const type = params.type;
      const twoWay = params.twoWay;
      const key = params.key;
      const twoWayKey = params.twoWayKey;
      const onDelete = params.onDelete;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof relatedTableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "relatedTableId"');
      }
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/relationship".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof relatedTableId !== "undefined") {
        payload["relatedTableId"] = relatedTableId;
      }
      if (typeof type !== "undefined") {
        payload["type"] = type;
      }
      if (typeof twoWay !== "undefined") {
        payload["twoWay"] = twoWay;
      }
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof twoWayKey !== "undefined") {
        payload["twoWayKey"] = twoWayKey;
      }
      if (typeof onDelete !== "undefined") {
        payload["onDelete"] = onDelete;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createStringColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          size: rest[2],
          required: rest[3],
          xdefault: rest[4],
          array: rest[5],
          encrypt: rest[6]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const size = params.size;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      const encrypt = params.encrypt;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof size === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "size"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/string".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof size !== "undefined") {
        payload["size"] = size;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      if (typeof encrypt !== "undefined") {
        payload["encrypt"] = encrypt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateStringColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          size: rest[4],
          newKey: rest[5]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const size = params.size;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/string/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof size !== "undefined") {
        payload["size"] = size;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createUrlColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          array: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const array = params.array;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/url".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array !== "undefined") {
        payload["array"] = array;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateUrlColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          required: rest[2],
          xdefault: rest[3],
          newKey: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const required = params.required;
      const xdefault = params.xdefault;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/url/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      if (typeof required !== "undefined") {
        payload["required"] = required;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    getColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    deleteColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    updateRelationshipColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          onDelete: rest[2],
          newKey: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const onDelete = params.onDelete;
      const newKey = params.newKey;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/columns/{key}/relationship".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      if (typeof onDelete !== "undefined") {
        payload["onDelete"] = onDelete;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    listIndexes(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          queries: rest[1],
          total: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const queries = params.queries;
      const total = params.total;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/indexes".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createIndex(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1],
          type: rest[2],
          columns: rest[3],
          orders: rest[4],
          lengths: rest[5]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      const type = params.type;
      const columns = params.columns;
      const orders = params.orders;
      const lengths = params.lengths;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      if (typeof columns === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "columns"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/indexes".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof type !== "undefined") {
        payload["type"] = type;
      }
      if (typeof columns !== "undefined") {
        payload["columns"] = columns;
      }
      if (typeof orders !== "undefined") {
        payload["orders"] = orders;
      }
      if (typeof lengths !== "undefined") {
        payload["lengths"] = lengths;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getIndex(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/indexes/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    deleteIndex(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          key: rest[1]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const key = params.key;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/indexes/{key}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{key}", key);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    listRows(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          queries: rest[1],
          transactionId: rest[2],
          total: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const queries = params.queries;
      const transactionId = params.transactionId;
      const total = params.total;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createRow(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          rowId: rest[1],
          data: rest[2],
          permissions: rest[3],
          transactionId: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const rowId = params.rowId;
      const data = params.data;
      const permissions = params.permissions;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof rowId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "rowId"');
      }
      if (typeof data === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "data"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof rowId !== "undefined") {
        payload["rowId"] = rowId;
      }
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createRows(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          rows: rest[1],
          transactionId: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const rows = params.rows;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof rows === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "rows"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof rows !== "undefined") {
        payload["rows"] = rows;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    upsertRows(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          rows: rest[1],
          transactionId: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const rows = params.rows;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof rows === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "rows"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof rows !== "undefined") {
        payload["rows"] = rows;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    updateRows(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          data: rest[1],
          queries: rest[2],
          transactionId: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const data = params.data;
      const queries = params.queries;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    deleteRows(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          queries: rest[1],
          transactionId: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const queries = params.queries;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}", databaseId).replace("{tableId}", tableId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    getRow(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          rowId: rest[1],
          queries: rest[2],
          transactionId: rest[3]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const rowId = params.rowId;
      const queries = params.queries;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof rowId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "rowId"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{rowId}", rowId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    upsertRow(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          rowId: rest[1],
          data: rest[2],
          permissions: rest[3],
          transactionId: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const rowId = params.rowId;
      const data = params.data;
      const permissions = params.permissions;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof rowId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "rowId"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{rowId}", rowId);
      const payload = {};
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    updateRow(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          rowId: rest[1],
          data: rest[2],
          permissions: rest[3],
          transactionId: rest[4]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const rowId = params.rowId;
      const data = params.data;
      const permissions = params.permissions;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof rowId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "rowId"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{rowId}", rowId);
      const payload = {};
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    deleteRow(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          rowId: rest[1],
          transactionId: rest[2]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const rowId = params.rowId;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof rowId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "rowId"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{rowId}", rowId);
      const payload = {};
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    decrementRowColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          rowId: rest[1],
          column: rest[2],
          value: rest[3],
          min: rest[4],
          transactionId: rest[5]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const rowId = params.rowId;
      const column = params.column;
      const value = params.value;
      const min = params.min;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof rowId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "rowId"');
      }
      if (typeof column === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "column"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/decrement".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{rowId}", rowId).replace("{column}", column);
      const payload = {};
      if (typeof value !== "undefined") {
        payload["value"] = value;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    incrementRowColumn(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          databaseId: paramsOrFirst,
          tableId: rest[0],
          rowId: rest[1],
          column: rest[2],
          value: rest[3],
          max: rest[4],
          transactionId: rest[5]
        };
      }
      const databaseId = params.databaseId;
      const tableId = params.tableId;
      const rowId = params.rowId;
      const column = params.column;
      const value = params.value;
      const max = params.max;
      const transactionId = params.transactionId;
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof tableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tableId"');
      }
      if (typeof rowId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "rowId"');
      }
      if (typeof column === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "column"');
      }
      const apiPath = "/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/increment".replace("{databaseId}", databaseId).replace("{tableId}", tableId).replace("{rowId}", rowId).replace("{column}", column);
      const payload = {};
      if (typeof value !== "undefined") {
        payload["value"] = value;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof transactionId !== "undefined") {
        payload["transactionId"] = transactionId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
  }
  exports.TablesDB = TablesDB;
});

// node_modules/node-appwrite/dist/services/teams.js
var require_teams = __commonJS((exports) => {
  var client = require_client();

  class Teams {
    constructor(client2) {
      this.client = client2;
    }
    list(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst,
          search: rest[0],
          total: rest[1]
        };
      }
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      const apiPath = "/teams";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          teamId: paramsOrFirst,
          name: rest[0],
          roles: rest[1]
        };
      }
      const teamId = params.teamId;
      const name = params.name;
      const roles = params.roles;
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/teams";
      const payload = {};
      if (typeof teamId !== "undefined") {
        payload["teamId"] = teamId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof roles !== "undefined") {
        payload["roles"] = roles;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          teamId: paramsOrFirst
        };
      }
      const teamId = params.teamId;
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      const apiPath = "/teams/{teamId}".replace("{teamId}", teamId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateName(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          teamId: paramsOrFirst,
          name: rest[0]
        };
      }
      const teamId = params.teamId;
      const name = params.name;
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/teams/{teamId}".replace("{teamId}", teamId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          teamId: paramsOrFirst
        };
      }
      const teamId = params.teamId;
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      const apiPath = "/teams/{teamId}".replace("{teamId}", teamId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    listMemberships(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          teamId: paramsOrFirst,
          queries: rest[0],
          search: rest[1],
          total: rest[2]
        };
      }
      const teamId = params.teamId;
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      const apiPath = "/teams/{teamId}/memberships".replace("{teamId}", teamId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createMembership(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          teamId: paramsOrFirst,
          roles: rest[0],
          email: rest[1],
          userId: rest[2],
          phone: rest[3],
          url: rest[4],
          name: rest[5]
        };
      }
      const teamId = params.teamId;
      const roles = params.roles;
      const email = params.email;
      const userId = params.userId;
      const phone = params.phone;
      const url = params.url;
      const name = params.name;
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof roles === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "roles"');
      }
      const apiPath = "/teams/{teamId}/memberships".replace("{teamId}", teamId);
      const payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof phone !== "undefined") {
        payload["phone"] = phone;
      }
      if (typeof roles !== "undefined") {
        payload["roles"] = roles;
      }
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getMembership(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          teamId: paramsOrFirst,
          membershipId: rest[0]
        };
      }
      const teamId = params.teamId;
      const membershipId = params.membershipId;
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof membershipId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "membershipId"');
      }
      const apiPath = "/teams/{teamId}/memberships/{membershipId}".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateMembership(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          teamId: paramsOrFirst,
          membershipId: rest[0],
          roles: rest[1]
        };
      }
      const teamId = params.teamId;
      const membershipId = params.membershipId;
      const roles = params.roles;
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof membershipId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "membershipId"');
      }
      if (typeof roles === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "roles"');
      }
      const apiPath = "/teams/{teamId}/memberships/{membershipId}".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
      const payload = {};
      if (typeof roles !== "undefined") {
        payload["roles"] = roles;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    deleteMembership(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          teamId: paramsOrFirst,
          membershipId: rest[0]
        };
      }
      const teamId = params.teamId;
      const membershipId = params.membershipId;
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof membershipId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "membershipId"');
      }
      const apiPath = "/teams/{teamId}/memberships/{membershipId}".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    updateMembershipStatus(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          teamId: paramsOrFirst,
          membershipId: rest[0],
          userId: rest[1],
          secret: rest[2]
        };
      }
      const teamId = params.teamId;
      const membershipId = params.membershipId;
      const userId = params.userId;
      const secret = params.secret;
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof membershipId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "membershipId"');
      }
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      const apiPath = "/teams/{teamId}/memberships/{membershipId}/status".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    getPrefs(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          teamId: paramsOrFirst
        };
      }
      const teamId = params.teamId;
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      const apiPath = "/teams/{teamId}/prefs".replace("{teamId}", teamId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updatePrefs(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          teamId: paramsOrFirst,
          prefs: rest[0]
        };
      }
      const teamId = params.teamId;
      const prefs = params.prefs;
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof prefs === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "prefs"');
      }
      const apiPath = "/teams/{teamId}/prefs".replace("{teamId}", teamId);
      const payload = {};
      if (typeof prefs !== "undefined") {
        payload["prefs"] = prefs;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
  }
  exports.Teams = Teams;
});

// node_modules/node-appwrite/dist/services/tokens.js
var require_tokens = __commonJS((exports) => {
  var client = require_client();

  class Tokens {
    constructor(client2) {
      this.client = client2;
    }
    list(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          bucketId: paramsOrFirst,
          fileId: rest[0],
          queries: rest[1],
          total: rest[2]
        };
      }
      const bucketId = params.bucketId;
      const fileId = params.fileId;
      const queries = params.queries;
      const total = params.total;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/tokens/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createFileToken(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          bucketId: paramsOrFirst,
          fileId: rest[0],
          expire: rest[1]
        };
      }
      const bucketId = params.bucketId;
      const fileId = params.fileId;
      const expire = params.expire;
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/tokens/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      if (typeof expire !== "undefined") {
        payload["expire"] = expire;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          tokenId: paramsOrFirst
        };
      }
      const tokenId = params.tokenId;
      if (typeof tokenId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tokenId"');
      }
      const apiPath = "/tokens/{tokenId}".replace("{tokenId}", tokenId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    update(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          tokenId: paramsOrFirst,
          expire: rest[0]
        };
      }
      const tokenId = params.tokenId;
      const expire = params.expire;
      if (typeof tokenId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tokenId"');
      }
      const apiPath = "/tokens/{tokenId}".replace("{tokenId}", tokenId);
      const payload = {};
      if (typeof expire !== "undefined") {
        payload["expire"] = expire;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          tokenId: paramsOrFirst
        };
      }
      const tokenId = params.tokenId;
      if (typeof tokenId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "tokenId"');
      }
      const apiPath = "/tokens/{tokenId}".replace("{tokenId}", tokenId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
  }
  exports.Tokens = Tokens;
});

// node_modules/node-appwrite/dist/services/users.js
var require_users = __commonJS((exports) => {
  var client = require_client();

  class Users {
    constructor(client2) {
      this.client = client2;
    }
    list(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst,
          search: rest[0],
          total: rest[1]
        };
      }
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      const apiPath = "/users";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          email: rest[0],
          phone: rest[1],
          password: rest[2],
          name: rest[3]
        };
      }
      const userId = params.userId;
      const email = params.email;
      const phone = params.phone;
      const password = params.password;
      const name = params.name;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof phone !== "undefined") {
        payload["phone"] = phone;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createArgon2User(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          email: rest[0],
          password: rest[1],
          name: rest[2]
        };
      }
      const userId = params.userId;
      const email = params.email;
      const password = params.password;
      const name = params.name;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/users/argon2";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createBcryptUser(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          email: rest[0],
          password: rest[1],
          name: rest[2]
        };
      }
      const userId = params.userId;
      const email = params.email;
      const password = params.password;
      const name = params.name;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/users/bcrypt";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    listIdentities(paramsOrFirst, ...rest) {
      let params;
      if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          queries: paramsOrFirst,
          search: rest[0],
          total: rest[1]
        };
      }
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      const apiPath = "/users/identities";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    deleteIdentity(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          identityId: paramsOrFirst
        };
      }
      const identityId = params.identityId;
      if (typeof identityId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "identityId"');
      }
      const apiPath = "/users/identities/{identityId}".replace("{identityId}", identityId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    createMD5User(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          email: rest[0],
          password: rest[1],
          name: rest[2]
        };
      }
      const userId = params.userId;
      const email = params.email;
      const password = params.password;
      const name = params.name;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/users/md5";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createPHPassUser(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          email: rest[0],
          password: rest[1],
          name: rest[2]
        };
      }
      const userId = params.userId;
      const email = params.email;
      const password = params.password;
      const name = params.name;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/users/phpass";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createScryptUser(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          email: rest[0],
          password: rest[1],
          passwordSalt: rest[2],
          passwordCpu: rest[3],
          passwordMemory: rest[4],
          passwordParallel: rest[5],
          passwordLength: rest[6],
          name: rest[7]
        };
      }
      const userId = params.userId;
      const email = params.email;
      const password = params.password;
      const passwordSalt = params.passwordSalt;
      const passwordCpu = params.passwordCpu;
      const passwordMemory = params.passwordMemory;
      const passwordParallel = params.passwordParallel;
      const passwordLength = params.passwordLength;
      const name = params.name;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      if (typeof passwordSalt === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordSalt"');
      }
      if (typeof passwordCpu === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordCpu"');
      }
      if (typeof passwordMemory === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordMemory"');
      }
      if (typeof passwordParallel === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordParallel"');
      }
      if (typeof passwordLength === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordLength"');
      }
      const apiPath = "/users/scrypt";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof passwordSalt !== "undefined") {
        payload["passwordSalt"] = passwordSalt;
      }
      if (typeof passwordCpu !== "undefined") {
        payload["passwordCpu"] = passwordCpu;
      }
      if (typeof passwordMemory !== "undefined") {
        payload["passwordMemory"] = passwordMemory;
      }
      if (typeof passwordParallel !== "undefined") {
        payload["passwordParallel"] = passwordParallel;
      }
      if (typeof passwordLength !== "undefined") {
        payload["passwordLength"] = passwordLength;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createScryptModifiedUser(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          email: rest[0],
          password: rest[1],
          passwordSalt: rest[2],
          passwordSaltSeparator: rest[3],
          passwordSignerKey: rest[4],
          name: rest[5]
        };
      }
      const userId = params.userId;
      const email = params.email;
      const password = params.password;
      const passwordSalt = params.passwordSalt;
      const passwordSaltSeparator = params.passwordSaltSeparator;
      const passwordSignerKey = params.passwordSignerKey;
      const name = params.name;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      if (typeof passwordSalt === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordSalt"');
      }
      if (typeof passwordSaltSeparator === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordSaltSeparator"');
      }
      if (typeof passwordSignerKey === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordSignerKey"');
      }
      const apiPath = "/users/scrypt-modified";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof passwordSalt !== "undefined") {
        payload["passwordSalt"] = passwordSalt;
      }
      if (typeof passwordSaltSeparator !== "undefined") {
        payload["passwordSaltSeparator"] = passwordSaltSeparator;
      }
      if (typeof passwordSignerKey !== "undefined") {
        payload["passwordSignerKey"] = passwordSignerKey;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    createSHAUser(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          email: rest[0],
          password: rest[1],
          passwordVersion: rest[2],
          name: rest[3]
        };
      }
      const userId = params.userId;
      const email = params.email;
      const password = params.password;
      const passwordVersion = params.passwordVersion;
      const name = params.name;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/users/sha";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof passwordVersion !== "undefined") {
        payload["passwordVersion"] = passwordVersion;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst
        };
      }
      const userId = params.userId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst
        };
      }
      const userId = params.userId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    updateEmail(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          email: rest[0]
        };
      }
      const userId = params.userId;
      const email = params.email;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      const apiPath = "/users/{userId}/email".replace("{userId}", userId);
      const payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createJWT(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          sessionId: rest[0],
          duration: rest[1]
        };
      }
      const userId = params.userId;
      const sessionId = params.sessionId;
      const duration = params.duration;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/jwts".replace("{userId}", userId);
      const payload = {};
      if (typeof sessionId !== "undefined") {
        payload["sessionId"] = sessionId;
      }
      if (typeof duration !== "undefined") {
        payload["duration"] = duration;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateLabels(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          labels: rest[0]
        };
      }
      const userId = params.userId;
      const labels = params.labels;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof labels === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "labels"');
      }
      const apiPath = "/users/{userId}/labels".replace("{userId}", userId);
      const payload = {};
      if (typeof labels !== "undefined") {
        payload["labels"] = labels;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    listLogs(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          queries: rest[0],
          total: rest[1]
        };
      }
      const userId = params.userId;
      const queries = params.queries;
      const total = params.total;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/logs".replace("{userId}", userId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listMemberships(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          queries: rest[0],
          search: rest[1],
          total: rest[2]
        };
      }
      const userId = params.userId;
      const queries = params.queries;
      const search = params.search;
      const total = params.total;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/memberships".replace("{userId}", userId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateMfa(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          mfa: rest[0]
        };
      }
      const userId = params.userId;
      const mfa = params.mfa;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof mfa === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "mfa"');
      }
      const apiPath = "/users/{userId}/mfa".replace("{userId}", userId);
      const payload = {};
      if (typeof mfa !== "undefined") {
        payload["mfa"] = mfa;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    updateMFA(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          mfa: rest[0]
        };
      }
      const userId = params.userId;
      const mfa = params.mfa;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof mfa === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "mfa"');
      }
      const apiPath = "/users/{userId}/mfa".replace("{userId}", userId);
      const payload = {};
      if (typeof mfa !== "undefined") {
        payload["mfa"] = mfa;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    deleteMfaAuthenticator(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          type: rest[0]
        };
      }
      const userId = params.userId;
      const type = params.type;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      const apiPath = "/users/{userId}/mfa/authenticators/{type}".replace("{userId}", userId).replace("{type}", type);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    deleteMFAAuthenticator(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          type: rest[0]
        };
      }
      const userId = params.userId;
      const type = params.type;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof type === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      const apiPath = "/users/{userId}/mfa/authenticators/{type}".replace("{userId}", userId).replace("{type}", type);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    listMfaFactors(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst
        };
      }
      const userId = params.userId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/mfa/factors".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    listMFAFactors(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst
        };
      }
      const userId = params.userId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/mfa/factors".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getMfaRecoveryCodes(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst
        };
      }
      const userId = params.userId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    getMFARecoveryCodes(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst
        };
      }
      const userId = params.userId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateMfaRecoveryCodes(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst
        };
      }
      const userId = params.userId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    updateMFARecoveryCodes(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst
        };
      }
      const userId = params.userId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("put", uri, apiHeaders, payload);
    }
    createMfaRecoveryCodes(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst
        };
      }
      const userId = params.userId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    createMFARecoveryCodes(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst
        };
      }
      const userId = params.userId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    updateName(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          name: rest[0]
        };
      }
      const userId = params.userId;
      const name = params.name;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/users/{userId}/name".replace("{userId}", userId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    updatePassword(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          password: rest[0]
        };
      }
      const userId = params.userId;
      const password = params.password;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/users/{userId}/password".replace("{userId}", userId);
      const payload = {};
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    updatePhone(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          number: rest[0]
        };
      }
      const userId = params.userId;
      const number = params.number;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof number === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "number"');
      }
      const apiPath = "/users/{userId}/phone".replace("{userId}", userId);
      const payload = {};
      if (typeof number !== "undefined") {
        payload["number"] = number;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    getPrefs(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst
        };
      }
      const userId = params.userId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/prefs".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updatePrefs(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          prefs: rest[0]
        };
      }
      const userId = params.userId;
      const prefs = params.prefs;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof prefs === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "prefs"');
      }
      const apiPath = "/users/{userId}/prefs".replace("{userId}", userId);
      const payload = {};
      if (typeof prefs !== "undefined") {
        payload["prefs"] = prefs;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    listSessions(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          total: rest[0]
        };
      }
      const userId = params.userId;
      const total = params.total;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/sessions".replace("{userId}", userId);
      const payload = {};
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createSession(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst
        };
      }
      const userId = params.userId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/sessions".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    deleteSessions(paramsOrFirst) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst
        };
      }
      const userId = params.userId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/sessions".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    deleteSession(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          sessionId: rest[0]
        };
      }
      const userId = params.userId;
      const sessionId = params.sessionId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof sessionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "sessionId"');
      }
      const apiPath = "/users/{userId}/sessions/{sessionId}".replace("{userId}", userId).replace("{sessionId}", sessionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    updateStatus(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          status: rest[0]
        };
      }
      const userId = params.userId;
      const status = params.status;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof status === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "status"');
      }
      const apiPath = "/users/{userId}/status".replace("{userId}", userId);
      const payload = {};
      if (typeof status !== "undefined") {
        payload["status"] = status;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    listTargets(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          queries: rest[0],
          total: rest[1]
        };
      }
      const userId = params.userId;
      const queries = params.queries;
      const total = params.total;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/targets".replace("{userId}", userId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof total !== "undefined") {
        payload["total"] = total;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    createTarget(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          targetId: rest[0],
          providerType: rest[1],
          identifier: rest[2],
          providerId: rest[3],
          name: rest[4]
        };
      }
      const userId = params.userId;
      const targetId = params.targetId;
      const providerType = params.providerType;
      const identifier = params.identifier;
      const providerId = params.providerId;
      const name = params.name;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof targetId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "targetId"');
      }
      if (typeof providerType === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerType"');
      }
      if (typeof identifier === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "identifier"');
      }
      const apiPath = "/users/{userId}/targets".replace("{userId}", userId);
      const payload = {};
      if (typeof targetId !== "undefined") {
        payload["targetId"] = targetId;
      }
      if (typeof providerType !== "undefined") {
        payload["providerType"] = providerType;
      }
      if (typeof identifier !== "undefined") {
        payload["identifier"] = identifier;
      }
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    getTarget(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          targetId: rest[0]
        };
      }
      const userId = params.userId;
      const targetId = params.targetId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof targetId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "targetId"');
      }
      const apiPath = "/users/{userId}/targets/{targetId}".replace("{userId}", userId).replace("{targetId}", targetId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {};
      return this.client.call("get", uri, apiHeaders, payload);
    }
    updateTarget(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          targetId: rest[0],
          identifier: rest[1],
          providerId: rest[2],
          name: rest[3]
        };
      }
      const userId = params.userId;
      const targetId = params.targetId;
      const identifier = params.identifier;
      const providerId = params.providerId;
      const name = params.name;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof targetId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "targetId"');
      }
      const apiPath = "/users/{userId}/targets/{targetId}".replace("{userId}", userId).replace("{targetId}", targetId);
      const payload = {};
      if (typeof identifier !== "undefined") {
        payload["identifier"] = identifier;
      }
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    deleteTarget(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          targetId: rest[0]
        };
      }
      const userId = params.userId;
      const targetId = params.targetId;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof targetId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "targetId"');
      }
      const apiPath = "/users/{userId}/targets/{targetId}".replace("{userId}", userId).replace("{targetId}", targetId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("delete", uri, apiHeaders, payload);
    }
    createToken(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          length: rest[0],
          expire: rest[1]
        };
      }
      const userId = params.userId;
      const length = params.length;
      const expire = params.expire;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/tokens".replace("{userId}", userId);
      const payload = {};
      if (typeof length !== "undefined") {
        payload["length"] = length;
      }
      if (typeof expire !== "undefined") {
        payload["expire"] = expire;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("post", uri, apiHeaders, payload);
    }
    updateEmailVerification(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          emailVerification: rest[0]
        };
      }
      const userId = params.userId;
      const emailVerification = params.emailVerification;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof emailVerification === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "emailVerification"');
      }
      const apiPath = "/users/{userId}/verification".replace("{userId}", userId);
      const payload = {};
      if (typeof emailVerification !== "undefined") {
        payload["emailVerification"] = emailVerification;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
    updatePhoneVerification(paramsOrFirst, ...rest) {
      let params;
      if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
        params = paramsOrFirst || {};
      } else {
        params = {
          userId: paramsOrFirst,
          phoneVerification: rest[0]
        };
      }
      const userId = params.userId;
      const phoneVerification = params.phoneVerification;
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof phoneVerification === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "phoneVerification"');
      }
      const apiPath = "/users/{userId}/verification/phone".replace("{userId}", userId);
      const payload = {};
      if (typeof phoneVerification !== "undefined") {
        payload["phoneVerification"] = phoneVerification;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return this.client.call("patch", uri, apiHeaders, payload);
    }
  }
  exports.Users = Users;
});

// node_modules/node-appwrite/dist/permission.js
var require_permission = __commonJS((exports) => {
  class Permission {
  }
  Permission.read = (role) => {
    return `read("${role}")`;
  };
  Permission.write = (role) => {
    return `write("${role}")`;
  };
  Permission.create = (role) => {
    return `create("${role}")`;
  };
  Permission.update = (role) => {
    return `update("${role}")`;
  };
  Permission.delete = (role) => {
    return `delete("${role}")`;
  };
  exports.Permission = Permission;
});

// node_modules/node-appwrite/dist/role.js
var require_role = __commonJS((exports) => {
  class Role {
    static any() {
      return "any";
    }
    static user(id, status = "") {
      if (status === "") {
        return `user:${id}`;
      }
      return `user:${id}/${status}`;
    }
    static users(status = "") {
      if (status === "") {
        return "users";
      }
      return `users/${status}`;
    }
    static guests() {
      return "guests";
    }
    static team(id, role = "") {
      if (role === "") {
        return `team:${id}`;
      }
      return `team:${id}/${role}`;
    }
    static member(id) {
      return `member:${id}`;
    }
    static label(name) {
      return `label:${name}`;
    }
  }
  exports.Role = Role;
});

// node_modules/node-appwrite/dist/id.js
var require_id = __commonJS((exports) => {
  class ID {
    static #hexTimestamp() {
      const now = /* @__PURE__ */ new Date;
      const sec = Math.floor(now.getTime() / 1000);
      const msec = now.getMilliseconds();
      const hexTimestamp = sec.toString(16) + msec.toString(16).padStart(5, "0");
      return hexTimestamp;
    }
    static custom(id) {
      return id;
    }
    static unique(padding = 7) {
      const baseId = ID.#hexTimestamp();
      let randomPadding = "";
      for (let i3 = 0;i3 < padding; i3++) {
        const randomHexDigit = Math.floor(Math.random() * 16).toString(16);
        randomPadding += randomHexDigit;
      }
      return baseId + randomPadding;
    }
  }
  exports.ID = ID;
});

// node_modules/node-appwrite/dist/operator.js
var require_operator = __commonJS((exports) => {
  var Condition = /* @__PURE__ */ ((Condition2) => {
    Condition2["Equal"] = "equal";
    Condition2["NotEqual"] = "notEqual";
    Condition2["GreaterThan"] = "greaterThan";
    Condition2["GreaterThanEqual"] = "greaterThanEqual";
    Condition2["LessThan"] = "lessThan";
    Condition2["LessThanEqual"] = "lessThanEqual";
    Condition2["Contains"] = "contains";
    Condition2["IsNull"] = "isNull";
    Condition2["IsNotNull"] = "isNotNull";
    return Condition2;
  })(Condition || {});
  var _Operator = class _Operator2 {
    constructor(method, values) {
      this.method = method;
      if (values !== undefined) {
        if (Array.isArray(values)) {
          this.values = values;
        } else {
          this.values = [values];
        }
      }
    }
    toString() {
      return JSON.stringify({
        method: this.method,
        values: this.values
      });
    }
  };
  _Operator.increment = (value = 1, max) => {
    if (isNaN(value) || !isFinite(value)) {
      throw new Error("Value cannot be NaN or Infinity");
    }
    if (max !== undefined && (isNaN(max) || !isFinite(max))) {
      throw new Error("Max cannot be NaN or Infinity");
    }
    const values = [value];
    if (max !== undefined) {
      values.push(max);
    }
    return new _Operator("increment", values).toString();
  };
  _Operator.decrement = (value = 1, min) => {
    if (isNaN(value) || !isFinite(value)) {
      throw new Error("Value cannot be NaN or Infinity");
    }
    if (min !== undefined && (isNaN(min) || !isFinite(min))) {
      throw new Error("Min cannot be NaN or Infinity");
    }
    const values = [value];
    if (min !== undefined) {
      values.push(min);
    }
    return new _Operator("decrement", values).toString();
  };
  _Operator.multiply = (factor, max) => {
    if (isNaN(factor) || !isFinite(factor)) {
      throw new Error("Factor cannot be NaN or Infinity");
    }
    if (max !== undefined && (isNaN(max) || !isFinite(max))) {
      throw new Error("Max cannot be NaN or Infinity");
    }
    const values = [factor];
    if (max !== undefined) {
      values.push(max);
    }
    return new _Operator("multiply", values).toString();
  };
  _Operator.divide = (divisor, min) => {
    if (isNaN(divisor) || !isFinite(divisor)) {
      throw new Error("Divisor cannot be NaN or Infinity");
    }
    if (min !== undefined && (isNaN(min) || !isFinite(min))) {
      throw new Error("Min cannot be NaN or Infinity");
    }
    if (divisor === 0) {
      throw new Error("Divisor cannot be zero");
    }
    const values = [divisor];
    if (min !== undefined) {
      values.push(min);
    }
    return new _Operator("divide", values).toString();
  };
  _Operator.modulo = (divisor) => {
    if (isNaN(divisor) || !isFinite(divisor)) {
      throw new Error("Divisor cannot be NaN or Infinity");
    }
    if (divisor === 0) {
      throw new Error("Divisor cannot be zero");
    }
    return new _Operator("modulo", [divisor]).toString();
  };
  _Operator.power = (exponent, max) => {
    if (isNaN(exponent) || !isFinite(exponent)) {
      throw new Error("Exponent cannot be NaN or Infinity");
    }
    if (max !== undefined && (isNaN(max) || !isFinite(max))) {
      throw new Error("Max cannot be NaN or Infinity");
    }
    const values = [exponent];
    if (max !== undefined) {
      values.push(max);
    }
    return new _Operator("power", values).toString();
  };
  _Operator.arrayAppend = (values) => new _Operator("arrayAppend", values).toString();
  _Operator.arrayPrepend = (values) => new _Operator("arrayPrepend", values).toString();
  _Operator.arrayInsert = (index2, value) => new _Operator("arrayInsert", [index2, value]).toString();
  _Operator.arrayRemove = (value) => new _Operator("arrayRemove", [value]).toString();
  _Operator.arrayUnique = () => new _Operator("arrayUnique", []).toString();
  _Operator.arrayIntersect = (values) => new _Operator("arrayIntersect", values).toString();
  _Operator.arrayDiff = (values) => new _Operator("arrayDiff", values).toString();
  _Operator.arrayFilter = (condition, value) => {
    const values = [condition, value === undefined ? null : value];
    return new _Operator("arrayFilter", values).toString();
  };
  _Operator.stringConcat = (value) => new _Operator("stringConcat", [value]).toString();
  _Operator.stringReplace = (search, replace) => new _Operator("stringReplace", [search, replace]).toString();
  _Operator.toggle = () => new _Operator("toggle", []).toString();
  _Operator.dateAddDays = (days) => new _Operator("dateAddDays", [days]).toString();
  _Operator.dateSubDays = (days) => new _Operator("dateSubDays", [days]).toString();
  _Operator.dateSetNow = () => new _Operator("dateSetNow", []).toString();
  var Operator = _Operator;
  exports.Condition = Condition;
  exports.Operator = Operator;
});

// node_modules/node-appwrite/dist/enums/authenticator-type.js
var require_authenticator_type = __commonJS((exports) => {
  var AuthenticatorType = /* @__PURE__ */ ((AuthenticatorType2) => {
    AuthenticatorType2["Totp"] = "totp";
    return AuthenticatorType2;
  })(AuthenticatorType || {});
  exports.AuthenticatorType = AuthenticatorType;
});

// node_modules/node-appwrite/dist/enums/authentication-factor.js
var require_authentication_factor = __commonJS((exports) => {
  var AuthenticationFactor = /* @__PURE__ */ ((AuthenticationFactor2) => {
    AuthenticationFactor2["Email"] = "email";
    AuthenticationFactor2["Phone"] = "phone";
    AuthenticationFactor2["Totp"] = "totp";
    AuthenticationFactor2["Recoverycode"] = "recoverycode";
    return AuthenticationFactor2;
  })(AuthenticationFactor || {});
  exports.AuthenticationFactor = AuthenticationFactor;
});

// node_modules/node-appwrite/dist/enums/o-auth-provider.js
var require_o_auth_provider = __commonJS((exports) => {
  var OAuthProvider = /* @__PURE__ */ ((OAuthProvider2) => {
    OAuthProvider2["Amazon"] = "amazon";
    OAuthProvider2["Apple"] = "apple";
    OAuthProvider2["Auth0"] = "auth0";
    OAuthProvider2["Authentik"] = "authentik";
    OAuthProvider2["Autodesk"] = "autodesk";
    OAuthProvider2["Bitbucket"] = "bitbucket";
    OAuthProvider2["Bitly"] = "bitly";
    OAuthProvider2["Box"] = "box";
    OAuthProvider2["Dailymotion"] = "dailymotion";
    OAuthProvider2["Discord"] = "discord";
    OAuthProvider2["Disqus"] = "disqus";
    OAuthProvider2["Dropbox"] = "dropbox";
    OAuthProvider2["Etsy"] = "etsy";
    OAuthProvider2["Facebook"] = "facebook";
    OAuthProvider2["Figma"] = "figma";
    OAuthProvider2["Github"] = "github";
    OAuthProvider2["Gitlab"] = "gitlab";
    OAuthProvider2["Google"] = "google";
    OAuthProvider2["Linkedin"] = "linkedin";
    OAuthProvider2["Microsoft"] = "microsoft";
    OAuthProvider2["Notion"] = "notion";
    OAuthProvider2["Oidc"] = "oidc";
    OAuthProvider2["Okta"] = "okta";
    OAuthProvider2["Paypal"] = "paypal";
    OAuthProvider2["PaypalSandbox"] = "paypalSandbox";
    OAuthProvider2["Podio"] = "podio";
    OAuthProvider2["Salesforce"] = "salesforce";
    OAuthProvider2["Slack"] = "slack";
    OAuthProvider2["Spotify"] = "spotify";
    OAuthProvider2["Stripe"] = "stripe";
    OAuthProvider2["Tradeshift"] = "tradeshift";
    OAuthProvider2["TradeshiftBox"] = "tradeshiftBox";
    OAuthProvider2["Twitch"] = "twitch";
    OAuthProvider2["Wordpress"] = "wordpress";
    OAuthProvider2["Yahoo"] = "yahoo";
    OAuthProvider2["Yammer"] = "yammer";
    OAuthProvider2["Yandex"] = "yandex";
    OAuthProvider2["Zoho"] = "zoho";
    OAuthProvider2["Zoom"] = "zoom";
    OAuthProvider2["Mock"] = "mock";
    return OAuthProvider2;
  })(OAuthProvider || {});
  exports.OAuthProvider = OAuthProvider;
});

// node_modules/node-appwrite/dist/enums/browser.js
var require_browser = __commonJS((exports) => {
  var Browser = /* @__PURE__ */ ((Browser2) => {
    Browser2["AvantBrowser"] = "aa";
    Browser2["AndroidWebViewBeta"] = "an";
    Browser2["GoogleChrome"] = "ch";
    Browser2["GoogleChromeIOS"] = "ci";
    Browser2["GoogleChromeMobile"] = "cm";
    Browser2["Chromium"] = "cr";
    Browser2["MozillaFirefox"] = "ff";
    Browser2["Safari"] = "sf";
    Browser2["MobileSafari"] = "mf";
    Browser2["MicrosoftEdge"] = "ps";
    Browser2["MicrosoftEdgeIOS"] = "oi";
    Browser2["OperaMini"] = "om";
    Browser2["Opera"] = "op";
    Browser2["OperaNext"] = "on";
    return Browser2;
  })(Browser || {});
  exports.Browser = Browser;
});

// node_modules/node-appwrite/dist/enums/credit-card.js
var require_credit_card = __commonJS((exports) => {
  var CreditCard = /* @__PURE__ */ ((CreditCard2) => {
    CreditCard2["AmericanExpress"] = "amex";
    CreditCard2["Argencard"] = "argencard";
    CreditCard2["Cabal"] = "cabal";
    CreditCard2["Cencosud"] = "cencosud";
    CreditCard2["DinersClub"] = "diners";
    CreditCard2["Discover"] = "discover";
    CreditCard2["Elo"] = "elo";
    CreditCard2["Hipercard"] = "hipercard";
    CreditCard2["JCB"] = "jcb";
    CreditCard2["Mastercard"] = "mastercard";
    CreditCard2["Naranja"] = "naranja";
    CreditCard2["TarjetaShopping"] = "targeta-shopping";
    CreditCard2["UnionPay"] = "unionpay";
    CreditCard2["Visa"] = "visa";
    CreditCard2["MIR"] = "mir";
    CreditCard2["Maestro"] = "maestro";
    CreditCard2["Rupay"] = "rupay";
    return CreditCard2;
  })(CreditCard || {});
  exports.CreditCard = CreditCard;
});

// node_modules/node-appwrite/dist/enums/flag.js
var require_flag = __commonJS((exports) => {
  var Flag = /* @__PURE__ */ ((Flag2) => {
    Flag2["Afghanistan"] = "af";
    Flag2["Angola"] = "ao";
    Flag2["Albania"] = "al";
    Flag2["Andorra"] = "ad";
    Flag2["UnitedArabEmirates"] = "ae";
    Flag2["Argentina"] = "ar";
    Flag2["Armenia"] = "am";
    Flag2["AntiguaAndBarbuda"] = "ag";
    Flag2["Australia"] = "au";
    Flag2["Austria"] = "at";
    Flag2["Azerbaijan"] = "az";
    Flag2["Burundi"] = "bi";
    Flag2["Belgium"] = "be";
    Flag2["Benin"] = "bj";
    Flag2["BurkinaFaso"] = "bf";
    Flag2["Bangladesh"] = "bd";
    Flag2["Bulgaria"] = "bg";
    Flag2["Bahrain"] = "bh";
    Flag2["Bahamas"] = "bs";
    Flag2["BosniaAndHerzegovina"] = "ba";
    Flag2["Belarus"] = "by";
    Flag2["Belize"] = "bz";
    Flag2["Bolivia"] = "bo";
    Flag2["Brazil"] = "br";
    Flag2["Barbados"] = "bb";
    Flag2["BruneiDarussalam"] = "bn";
    Flag2["Bhutan"] = "bt";
    Flag2["Botswana"] = "bw";
    Flag2["CentralAfricanRepublic"] = "cf";
    Flag2["Canada"] = "ca";
    Flag2["Switzerland"] = "ch";
    Flag2["Chile"] = "cl";
    Flag2["China"] = "cn";
    Flag2["CoteDIvoire"] = "ci";
    Flag2["Cameroon"] = "cm";
    Flag2["DemocraticRepublicOfTheCongo"] = "cd";
    Flag2["RepublicOfTheCongo"] = "cg";
    Flag2["Colombia"] = "co";
    Flag2["Comoros"] = "km";
    Flag2["CapeVerde"] = "cv";
    Flag2["CostaRica"] = "cr";
    Flag2["Cuba"] = "cu";
    Flag2["Cyprus"] = "cy";
    Flag2["CzechRepublic"] = "cz";
    Flag2["Germany"] = "de";
    Flag2["Djibouti"] = "dj";
    Flag2["Dominica"] = "dm";
    Flag2["Denmark"] = "dk";
    Flag2["DominicanRepublic"] = "do";
    Flag2["Algeria"] = "dz";
    Flag2["Ecuador"] = "ec";
    Flag2["Egypt"] = "eg";
    Flag2["Eritrea"] = "er";
    Flag2["Spain"] = "es";
    Flag2["Estonia"] = "ee";
    Flag2["Ethiopia"] = "et";
    Flag2["Finland"] = "fi";
    Flag2["Fiji"] = "fj";
    Flag2["France"] = "fr";
    Flag2["MicronesiaFederatedStatesOf"] = "fm";
    Flag2["Gabon"] = "ga";
    Flag2["UnitedKingdom"] = "gb";
    Flag2["Georgia"] = "ge";
    Flag2["Ghana"] = "gh";
    Flag2["Guinea"] = "gn";
    Flag2["Gambia"] = "gm";
    Flag2["GuineaBissau"] = "gw";
    Flag2["EquatorialGuinea"] = "gq";
    Flag2["Greece"] = "gr";
    Flag2["Grenada"] = "gd";
    Flag2["Guatemala"] = "gt";
    Flag2["Guyana"] = "gy";
    Flag2["Honduras"] = "hn";
    Flag2["Croatia"] = "hr";
    Flag2["Haiti"] = "ht";
    Flag2["Hungary"] = "hu";
    Flag2["Indonesia"] = "id";
    Flag2["India"] = "in";
    Flag2["Ireland"] = "ie";
    Flag2["IranIslamicRepublicOf"] = "ir";
    Flag2["Iraq"] = "iq";
    Flag2["Iceland"] = "is";
    Flag2["Israel"] = "il";
    Flag2["Italy"] = "it";
    Flag2["Jamaica"] = "jm";
    Flag2["Jordan"] = "jo";
    Flag2["Japan"] = "jp";
    Flag2["Kazakhstan"] = "kz";
    Flag2["Kenya"] = "ke";
    Flag2["Kyrgyzstan"] = "kg";
    Flag2["Cambodia"] = "kh";
    Flag2["Kiribati"] = "ki";
    Flag2["SaintKittsAndNevis"] = "kn";
    Flag2["SouthKorea"] = "kr";
    Flag2["Kuwait"] = "kw";
    Flag2["LaoPeopleSDemocraticRepublic"] = "la";
    Flag2["Lebanon"] = "lb";
    Flag2["Liberia"] = "lr";
    Flag2["Libya"] = "ly";
    Flag2["SaintLucia"] = "lc";
    Flag2["Liechtenstein"] = "li";
    Flag2["SriLanka"] = "lk";
    Flag2["Lesotho"] = "ls";
    Flag2["Lithuania"] = "lt";
    Flag2["Luxembourg"] = "lu";
    Flag2["Latvia"] = "lv";
    Flag2["Morocco"] = "ma";
    Flag2["Monaco"] = "mc";
    Flag2["Moldova"] = "md";
    Flag2["Madagascar"] = "mg";
    Flag2["Maldives"] = "mv";
    Flag2["Mexico"] = "mx";
    Flag2["MarshallIslands"] = "mh";
    Flag2["NorthMacedonia"] = "mk";
    Flag2["Mali"] = "ml";
    Flag2["Malta"] = "mt";
    Flag2["Myanmar"] = "mm";
    Flag2["Montenegro"] = "me";
    Flag2["Mongolia"] = "mn";
    Flag2["Mozambique"] = "mz";
    Flag2["Mauritania"] = "mr";
    Flag2["Mauritius"] = "mu";
    Flag2["Malawi"] = "mw";
    Flag2["Malaysia"] = "my";
    Flag2["Namibia"] = "na";
    Flag2["Niger"] = "ne";
    Flag2["Nigeria"] = "ng";
    Flag2["Nicaragua"] = "ni";
    Flag2["Netherlands"] = "nl";
    Flag2["Norway"] = "no";
    Flag2["Nepal"] = "np";
    Flag2["Nauru"] = "nr";
    Flag2["NewZealand"] = "nz";
    Flag2["Oman"] = "om";
    Flag2["Pakistan"] = "pk";
    Flag2["Panama"] = "pa";
    Flag2["Peru"] = "pe";
    Flag2["Philippines"] = "ph";
    Flag2["Palau"] = "pw";
    Flag2["PapuaNewGuinea"] = "pg";
    Flag2["Poland"] = "pl";
    Flag2["FrenchPolynesia"] = "pf";
    Flag2["NorthKorea"] = "kp";
    Flag2["Portugal"] = "pt";
    Flag2["Paraguay"] = "py";
    Flag2["Qatar"] = "qa";
    Flag2["Romania"] = "ro";
    Flag2["Russia"] = "ru";
    Flag2["Rwanda"] = "rw";
    Flag2["SaudiArabia"] = "sa";
    Flag2["Sudan"] = "sd";
    Flag2["Senegal"] = "sn";
    Flag2["Singapore"] = "sg";
    Flag2["SolomonIslands"] = "sb";
    Flag2["SierraLeone"] = "sl";
    Flag2["ElSalvador"] = "sv";
    Flag2["SanMarino"] = "sm";
    Flag2["Somalia"] = "so";
    Flag2["Serbia"] = "rs";
    Flag2["SouthSudan"] = "ss";
    Flag2["SaoTomeAndPrincipe"] = "st";
    Flag2["Suriname"] = "sr";
    Flag2["Slovakia"] = "sk";
    Flag2["Slovenia"] = "si";
    Flag2["Sweden"] = "se";
    Flag2["Eswatini"] = "sz";
    Flag2["Seychelles"] = "sc";
    Flag2["Syria"] = "sy";
    Flag2["Chad"] = "td";
    Flag2["Togo"] = "tg";
    Flag2["Thailand"] = "th";
    Flag2["Tajikistan"] = "tj";
    Flag2["Turkmenistan"] = "tm";
    Flag2["TimorLeste"] = "tl";
    Flag2["Tonga"] = "to";
    Flag2["TrinidadAndTobago"] = "tt";
    Flag2["Tunisia"] = "tn";
    Flag2["Turkey"] = "tr";
    Flag2["Tuvalu"] = "tv";
    Flag2["Tanzania"] = "tz";
    Flag2["Uganda"] = "ug";
    Flag2["Ukraine"] = "ua";
    Flag2["Uruguay"] = "uy";
    Flag2["UnitedStates"] = "us";
    Flag2["Uzbekistan"] = "uz";
    Flag2["VaticanCity"] = "va";
    Flag2["SaintVincentAndTheGrenadines"] = "vc";
    Flag2["Venezuela"] = "ve";
    Flag2["Vietnam"] = "vn";
    Flag2["Vanuatu"] = "vu";
    Flag2["Samoa"] = "ws";
    Flag2["Yemen"] = "ye";
    Flag2["SouthAfrica"] = "za";
    Flag2["Zambia"] = "zm";
    Flag2["Zimbabwe"] = "zw";
    return Flag2;
  })(Flag || {});
  exports.Flag = Flag;
});

// node_modules/node-appwrite/dist/enums/relationship-type.js
var require_relationship_type = __commonJS((exports) => {
  var RelationshipType = /* @__PURE__ */ ((RelationshipType2) => {
    RelationshipType2["OneToOne"] = "oneToOne";
    RelationshipType2["ManyToOne"] = "manyToOne";
    RelationshipType2["ManyToMany"] = "manyToMany";
    RelationshipType2["OneToMany"] = "oneToMany";
    return RelationshipType2;
  })(RelationshipType || {});
  exports.RelationshipType = RelationshipType;
});

// node_modules/node-appwrite/dist/enums/relation-mutate.js
var require_relation_mutate = __commonJS((exports) => {
  var RelationMutate = /* @__PURE__ */ ((RelationMutate2) => {
    RelationMutate2["Cascade"] = "cascade";
    RelationMutate2["Restrict"] = "restrict";
    RelationMutate2["SetNull"] = "setNull";
    return RelationMutate2;
  })(RelationMutate || {});
  exports.RelationMutate = RelationMutate;
});

// node_modules/node-appwrite/dist/enums/index-type.js
var require_index_type = __commonJS((exports) => {
  var IndexType = /* @__PURE__ */ ((IndexType2) => {
    IndexType2["Key"] = "key";
    IndexType2["Fulltext"] = "fulltext";
    IndexType2["Unique"] = "unique";
    IndexType2["Spatial"] = "spatial";
    return IndexType2;
  })(IndexType || {});
  exports.IndexType = IndexType;
});

// node_modules/node-appwrite/dist/enums/runtime.js
var require_runtime = __commonJS((exports) => {
  var Runtime = /* @__PURE__ */ ((Runtime2) => {
    Runtime2["Node145"] = "node-14.5";
    Runtime2["Node160"] = "node-16.0";
    Runtime2["Node180"] = "node-18.0";
    Runtime2["Node190"] = "node-19.0";
    Runtime2["Node200"] = "node-20.0";
    Runtime2["Node210"] = "node-21.0";
    Runtime2["Node22"] = "node-22";
    Runtime2["Php80"] = "php-8.0";
    Runtime2["Php81"] = "php-8.1";
    Runtime2["Php82"] = "php-8.2";
    Runtime2["Php83"] = "php-8.3";
    Runtime2["Ruby30"] = "ruby-3.0";
    Runtime2["Ruby31"] = "ruby-3.1";
    Runtime2["Ruby32"] = "ruby-3.2";
    Runtime2["Ruby33"] = "ruby-3.3";
    Runtime2["Python38"] = "python-3.8";
    Runtime2["Python39"] = "python-3.9";
    Runtime2["Python310"] = "python-3.10";
    Runtime2["Python311"] = "python-3.11";
    Runtime2["Python312"] = "python-3.12";
    Runtime2["Pythonml311"] = "python-ml-3.11";
    Runtime2["Pythonml312"] = "python-ml-3.12";
    Runtime2["Deno121"] = "deno-1.21";
    Runtime2["Deno124"] = "deno-1.24";
    Runtime2["Deno135"] = "deno-1.35";
    Runtime2["Deno140"] = "deno-1.40";
    Runtime2["Deno146"] = "deno-1.46";
    Runtime2["Deno20"] = "deno-2.0";
    Runtime2["Dart215"] = "dart-2.15";
    Runtime2["Dart216"] = "dart-2.16";
    Runtime2["Dart217"] = "dart-2.17";
    Runtime2["Dart218"] = "dart-2.18";
    Runtime2["Dart219"] = "dart-2.19";
    Runtime2["Dart30"] = "dart-3.0";
    Runtime2["Dart31"] = "dart-3.1";
    Runtime2["Dart33"] = "dart-3.3";
    Runtime2["Dart35"] = "dart-3.5";
    Runtime2["Dart38"] = "dart-3.8";
    Runtime2["Dotnet60"] = "dotnet-6.0";
    Runtime2["Dotnet70"] = "dotnet-7.0";
    Runtime2["Dotnet80"] = "dotnet-8.0";
    Runtime2["Java80"] = "java-8.0";
    Runtime2["Java110"] = "java-11.0";
    Runtime2["Java170"] = "java-17.0";
    Runtime2["Java180"] = "java-18.0";
    Runtime2["Java210"] = "java-21.0";
    Runtime2["Java22"] = "java-22";
    Runtime2["Swift55"] = "swift-5.5";
    Runtime2["Swift58"] = "swift-5.8";
    Runtime2["Swift59"] = "swift-5.9";
    Runtime2["Swift510"] = "swift-5.10";
    Runtime2["Kotlin16"] = "kotlin-1.6";
    Runtime2["Kotlin18"] = "kotlin-1.8";
    Runtime2["Kotlin19"] = "kotlin-1.9";
    Runtime2["Kotlin20"] = "kotlin-2.0";
    Runtime2["Cpp17"] = "cpp-17";
    Runtime2["Cpp20"] = "cpp-20";
    Runtime2["Bun10"] = "bun-1.0";
    Runtime2["Bun11"] = "bun-1.1";
    Runtime2["Go123"] = "go-1.23";
    Runtime2["Static1"] = "static-1";
    Runtime2["Flutter324"] = "flutter-3.24";
    Runtime2["Flutter327"] = "flutter-3.27";
    Runtime2["Flutter329"] = "flutter-3.29";
    Runtime2["Flutter332"] = "flutter-3.32";
    return Runtime2;
  })(Runtime || {});
  exports.Runtime = Runtime;
});

// node_modules/node-appwrite/dist/enums/vcs-deployment-type.js
var require_vcs_deployment_type = __commonJS((exports) => {
  var VCSDeploymentType = /* @__PURE__ */ ((VCSDeploymentType2) => {
    VCSDeploymentType2["Branch"] = "branch";
    VCSDeploymentType2["Commit"] = "commit";
    VCSDeploymentType2["Tag"] = "tag";
    return VCSDeploymentType2;
  })(VCSDeploymentType || {});
  exports.VCSDeploymentType = VCSDeploymentType;
});

// node_modules/node-appwrite/dist/enums/deployment-download-type.js
var require_deployment_download_type = __commonJS((exports) => {
  var DeploymentDownloadType = /* @__PURE__ */ ((DeploymentDownloadType2) => {
    DeploymentDownloadType2["Source"] = "source";
    DeploymentDownloadType2["Output"] = "output";
    return DeploymentDownloadType2;
  })(DeploymentDownloadType || {});
  exports.DeploymentDownloadType = DeploymentDownloadType;
});

// node_modules/node-appwrite/dist/enums/execution-method.js
var require_execution_method = __commonJS((exports) => {
  var ExecutionMethod = /* @__PURE__ */ ((ExecutionMethod2) => {
    ExecutionMethod2["GET"] = "GET";
    ExecutionMethod2["POST"] = "POST";
    ExecutionMethod2["PUT"] = "PUT";
    ExecutionMethod2["PATCH"] = "PATCH";
    ExecutionMethod2["DELETE"] = "DELETE";
    ExecutionMethod2["OPTIONS"] = "OPTIONS";
    ExecutionMethod2["HEAD"] = "HEAD";
    return ExecutionMethod2;
  })(ExecutionMethod || {});
  exports.ExecutionMethod = ExecutionMethod;
});

// node_modules/node-appwrite/dist/enums/name.js
var require_name = __commonJS((exports) => {
  var Name = /* @__PURE__ */ ((Name2) => {
    Name2["V1database"] = "v1-database";
    Name2["V1deletes"] = "v1-deletes";
    Name2["V1audits"] = "v1-audits";
    Name2["V1mails"] = "v1-mails";
    Name2["V1functions"] = "v1-functions";
    Name2["V1statsresources"] = "v1-stats-resources";
    Name2["V1statsusage"] = "v1-stats-usage";
    Name2["V1webhooks"] = "v1-webhooks";
    Name2["V1certificates"] = "v1-certificates";
    Name2["V1builds"] = "v1-builds";
    Name2["V1messaging"] = "v1-messaging";
    Name2["V1migrations"] = "v1-migrations";
    return Name2;
  })(Name || {});
  exports.Name = Name;
});

// node_modules/node-appwrite/dist/enums/message-priority.js
var require_message_priority = __commonJS((exports) => {
  var MessagePriority = /* @__PURE__ */ ((MessagePriority2) => {
    MessagePriority2["Normal"] = "normal";
    MessagePriority2["High"] = "high";
    return MessagePriority2;
  })(MessagePriority || {});
  exports.MessagePriority = MessagePriority;
});

// node_modules/node-appwrite/dist/enums/smtp-encryption.js
var require_smtp_encryption = __commonJS((exports) => {
  var SmtpEncryption = /* @__PURE__ */ ((SmtpEncryption2) => {
    SmtpEncryption2["None"] = "none";
    SmtpEncryption2["Ssl"] = "ssl";
    SmtpEncryption2["Tls"] = "tls";
    return SmtpEncryption2;
  })(SmtpEncryption || {});
  exports.SmtpEncryption = SmtpEncryption;
});

// node_modules/node-appwrite/dist/enums/framework.js
var require_framework = __commonJS((exports) => {
  var Framework = /* @__PURE__ */ ((Framework2) => {
    Framework2["Analog"] = "analog";
    Framework2["Angular"] = "angular";
    Framework2["Nextjs"] = "nextjs";
    Framework2["React"] = "react";
    Framework2["Nuxt"] = "nuxt";
    Framework2["Vue"] = "vue";
    Framework2["Sveltekit"] = "sveltekit";
    Framework2["Astro"] = "astro";
    Framework2["Tanstackstart"] = "tanstack-start";
    Framework2["Remix"] = "remix";
    Framework2["Lynx"] = "lynx";
    Framework2["Flutter"] = "flutter";
    Framework2["Reactnative"] = "react-native";
    Framework2["Vite"] = "vite";
    Framework2["Other"] = "other";
    return Framework2;
  })(Framework || {});
  exports.Framework = Framework;
});

// node_modules/node-appwrite/dist/enums/build-runtime.js
var require_build_runtime = __commonJS((exports) => {
  var BuildRuntime = /* @__PURE__ */ ((BuildRuntime2) => {
    BuildRuntime2["Node145"] = "node-14.5";
    BuildRuntime2["Node160"] = "node-16.0";
    BuildRuntime2["Node180"] = "node-18.0";
    BuildRuntime2["Node190"] = "node-19.0";
    BuildRuntime2["Node200"] = "node-20.0";
    BuildRuntime2["Node210"] = "node-21.0";
    BuildRuntime2["Node22"] = "node-22";
    BuildRuntime2["Php80"] = "php-8.0";
    BuildRuntime2["Php81"] = "php-8.1";
    BuildRuntime2["Php82"] = "php-8.2";
    BuildRuntime2["Php83"] = "php-8.3";
    BuildRuntime2["Ruby30"] = "ruby-3.0";
    BuildRuntime2["Ruby31"] = "ruby-3.1";
    BuildRuntime2["Ruby32"] = "ruby-3.2";
    BuildRuntime2["Ruby33"] = "ruby-3.3";
    BuildRuntime2["Python38"] = "python-3.8";
    BuildRuntime2["Python39"] = "python-3.9";
    BuildRuntime2["Python310"] = "python-3.10";
    BuildRuntime2["Python311"] = "python-3.11";
    BuildRuntime2["Python312"] = "python-3.12";
    BuildRuntime2["Pythonml311"] = "python-ml-3.11";
    BuildRuntime2["Pythonml312"] = "python-ml-3.12";
    BuildRuntime2["Deno121"] = "deno-1.21";
    BuildRuntime2["Deno124"] = "deno-1.24";
    BuildRuntime2["Deno135"] = "deno-1.35";
    BuildRuntime2["Deno140"] = "deno-1.40";
    BuildRuntime2["Deno146"] = "deno-1.46";
    BuildRuntime2["Deno20"] = "deno-2.0";
    BuildRuntime2["Dart215"] = "dart-2.15";
    BuildRuntime2["Dart216"] = "dart-2.16";
    BuildRuntime2["Dart217"] = "dart-2.17";
    BuildRuntime2["Dart218"] = "dart-2.18";
    BuildRuntime2["Dart219"] = "dart-2.19";
    BuildRuntime2["Dart30"] = "dart-3.0";
    BuildRuntime2["Dart31"] = "dart-3.1";
    BuildRuntime2["Dart33"] = "dart-3.3";
    BuildRuntime2["Dart35"] = "dart-3.5";
    BuildRuntime2["Dart38"] = "dart-3.8";
    BuildRuntime2["Dotnet60"] = "dotnet-6.0";
    BuildRuntime2["Dotnet70"] = "dotnet-7.0";
    BuildRuntime2["Dotnet80"] = "dotnet-8.0";
    BuildRuntime2["Java80"] = "java-8.0";
    BuildRuntime2["Java110"] = "java-11.0";
    BuildRuntime2["Java170"] = "java-17.0";
    BuildRuntime2["Java180"] = "java-18.0";
    BuildRuntime2["Java210"] = "java-21.0";
    BuildRuntime2["Java22"] = "java-22";
    BuildRuntime2["Swift55"] = "swift-5.5";
    BuildRuntime2["Swift58"] = "swift-5.8";
    BuildRuntime2["Swift59"] = "swift-5.9";
    BuildRuntime2["Swift510"] = "swift-5.10";
    BuildRuntime2["Kotlin16"] = "kotlin-1.6";
    BuildRuntime2["Kotlin18"] = "kotlin-1.8";
    BuildRuntime2["Kotlin19"] = "kotlin-1.9";
    BuildRuntime2["Kotlin20"] = "kotlin-2.0";
    BuildRuntime2["Cpp17"] = "cpp-17";
    BuildRuntime2["Cpp20"] = "cpp-20";
    BuildRuntime2["Bun10"] = "bun-1.0";
    BuildRuntime2["Bun11"] = "bun-1.1";
    BuildRuntime2["Go123"] = "go-1.23";
    BuildRuntime2["Static1"] = "static-1";
    BuildRuntime2["Flutter324"] = "flutter-3.24";
    BuildRuntime2["Flutter327"] = "flutter-3.27";
    BuildRuntime2["Flutter329"] = "flutter-3.29";
    BuildRuntime2["Flutter332"] = "flutter-3.32";
    return BuildRuntime2;
  })(BuildRuntime || {});
  exports.BuildRuntime = BuildRuntime;
});

// node_modules/node-appwrite/dist/enums/adapter.js
var require_adapter = __commonJS((exports) => {
  var Adapter = /* @__PURE__ */ ((Adapter2) => {
    Adapter2["Static"] = "static";
    Adapter2["Ssr"] = "ssr";
    return Adapter2;
  })(Adapter || {});
  exports.Adapter = Adapter;
});

// node_modules/node-appwrite/dist/enums/compression.js
var require_compression = __commonJS((exports) => {
  var Compression = /* @__PURE__ */ ((Compression2) => {
    Compression2["None"] = "none";
    Compression2["Gzip"] = "gzip";
    Compression2["Zstd"] = "zstd";
    return Compression2;
  })(Compression || {});
  exports.Compression = Compression;
});

// node_modules/node-appwrite/dist/enums/image-gravity.js
var require_image_gravity = __commonJS((exports) => {
  var ImageGravity = /* @__PURE__ */ ((ImageGravity2) => {
    ImageGravity2["Center"] = "center";
    ImageGravity2["Topleft"] = "top-left";
    ImageGravity2["Top"] = "top";
    ImageGravity2["Topright"] = "top-right";
    ImageGravity2["Left"] = "left";
    ImageGravity2["Right"] = "right";
    ImageGravity2["Bottomleft"] = "bottom-left";
    ImageGravity2["Bottom"] = "bottom";
    ImageGravity2["Bottomright"] = "bottom-right";
    return ImageGravity2;
  })(ImageGravity || {});
  exports.ImageGravity = ImageGravity;
});

// node_modules/node-appwrite/dist/enums/image-format.js
var require_image_format = __commonJS((exports) => {
  var ImageFormat = /* @__PURE__ */ ((ImageFormat2) => {
    ImageFormat2["Jpg"] = "jpg";
    ImageFormat2["Jpeg"] = "jpeg";
    ImageFormat2["Png"] = "png";
    ImageFormat2["Webp"] = "webp";
    ImageFormat2["Heic"] = "heic";
    ImageFormat2["Avif"] = "avif";
    ImageFormat2["Gif"] = "gif";
    return ImageFormat2;
  })(ImageFormat || {});
  exports.ImageFormat = ImageFormat;
});

// node_modules/node-appwrite/dist/enums/password-hash.js
var require_password_hash = __commonJS((exports) => {
  var PasswordHash = /* @__PURE__ */ ((PasswordHash2) => {
    PasswordHash2["Sha1"] = "sha1";
    PasswordHash2["Sha224"] = "sha224";
    PasswordHash2["Sha256"] = "sha256";
    PasswordHash2["Sha384"] = "sha384";
    PasswordHash2["Sha512224"] = "sha512/224";
    PasswordHash2["Sha512256"] = "sha512/256";
    PasswordHash2["Sha512"] = "sha512";
    PasswordHash2["Sha3224"] = "sha3-224";
    PasswordHash2["Sha3256"] = "sha3-256";
    PasswordHash2["Sha3384"] = "sha3-384";
    PasswordHash2["Sha3512"] = "sha3-512";
    return PasswordHash2;
  })(PasswordHash || {});
  exports.PasswordHash = PasswordHash;
});

// node_modules/node-appwrite/dist/enums/messaging-provider-type.js
var require_messaging_provider_type = __commonJS((exports) => {
  var MessagingProviderType = /* @__PURE__ */ ((MessagingProviderType2) => {
    MessagingProviderType2["Email"] = "email";
    MessagingProviderType2["Sms"] = "sms";
    MessagingProviderType2["Push"] = "push";
    return MessagingProviderType2;
  })(MessagingProviderType || {});
  exports.MessagingProviderType = MessagingProviderType;
});

// node_modules/node-appwrite/dist/enums/database-type.js
var require_database_type = __commonJS((exports) => {
  var DatabaseType = /* @__PURE__ */ ((DatabaseType2) => {
    DatabaseType2["Legacy"] = "legacy";
    DatabaseType2["Tablesdb"] = "tablesdb";
    return DatabaseType2;
  })(DatabaseType || {});
  exports.DatabaseType = DatabaseType;
});

// node_modules/node-appwrite/dist/enums/attribute-status.js
var require_attribute_status = __commonJS((exports) => {
  var AttributeStatus = /* @__PURE__ */ ((AttributeStatus2) => {
    AttributeStatus2["Available"] = "available";
    AttributeStatus2["Processing"] = "processing";
    AttributeStatus2["Deleting"] = "deleting";
    AttributeStatus2["Stuck"] = "stuck";
    AttributeStatus2["Failed"] = "failed";
    return AttributeStatus2;
  })(AttributeStatus || {});
  exports.AttributeStatus = AttributeStatus;
});

// node_modules/node-appwrite/dist/enums/column-status.js
var require_column_status = __commonJS((exports) => {
  var ColumnStatus = /* @__PURE__ */ ((ColumnStatus2) => {
    ColumnStatus2["Available"] = "available";
    ColumnStatus2["Processing"] = "processing";
    ColumnStatus2["Deleting"] = "deleting";
    ColumnStatus2["Stuck"] = "stuck";
    ColumnStatus2["Failed"] = "failed";
    return ColumnStatus2;
  })(ColumnStatus || {});
  exports.ColumnStatus = ColumnStatus;
});

// node_modules/node-appwrite/dist/enums/index-status.js
var require_index_status = __commonJS((exports) => {
  var IndexStatus = /* @__PURE__ */ ((IndexStatus2) => {
    IndexStatus2["Available"] = "available";
    IndexStatus2["Processing"] = "processing";
    IndexStatus2["Deleting"] = "deleting";
    IndexStatus2["Stuck"] = "stuck";
    IndexStatus2["Failed"] = "failed";
    return IndexStatus2;
  })(IndexStatus || {});
  exports.IndexStatus = IndexStatus;
});

// node_modules/node-appwrite/dist/enums/deployment-status.js
var require_deployment_status = __commonJS((exports) => {
  var DeploymentStatus = /* @__PURE__ */ ((DeploymentStatus2) => {
    DeploymentStatus2["Waiting"] = "waiting";
    DeploymentStatus2["Processing"] = "processing";
    DeploymentStatus2["Building"] = "building";
    DeploymentStatus2["Ready"] = "ready";
    DeploymentStatus2["Failed"] = "failed";
    return DeploymentStatus2;
  })(DeploymentStatus || {});
  exports.DeploymentStatus = DeploymentStatus;
});

// node_modules/node-appwrite/dist/enums/execution-trigger.js
var require_execution_trigger = __commonJS((exports) => {
  var ExecutionTrigger = /* @__PURE__ */ ((ExecutionTrigger2) => {
    ExecutionTrigger2["Http"] = "http";
    ExecutionTrigger2["Schedule"] = "schedule";
    ExecutionTrigger2["Event"] = "event";
    return ExecutionTrigger2;
  })(ExecutionTrigger || {});
  exports.ExecutionTrigger = ExecutionTrigger;
});

// node_modules/node-appwrite/dist/enums/execution-status.js
var require_execution_status = __commonJS((exports) => {
  var ExecutionStatus = /* @__PURE__ */ ((ExecutionStatus2) => {
    ExecutionStatus2["Waiting"] = "waiting";
    ExecutionStatus2["Processing"] = "processing";
    ExecutionStatus2["Completed"] = "completed";
    ExecutionStatus2["Failed"] = "failed";
    ExecutionStatus2["Scheduled"] = "scheduled";
    return ExecutionStatus2;
  })(ExecutionStatus || {});
  exports.ExecutionStatus = ExecutionStatus;
});

// node_modules/node-appwrite/dist/enums/health-antivirus-status.js
var require_health_antivirus_status = __commonJS((exports) => {
  var HealthAntivirusStatus = /* @__PURE__ */ ((HealthAntivirusStatus2) => {
    HealthAntivirusStatus2["Disabled"] = "disabled";
    HealthAntivirusStatus2["Offline"] = "offline";
    HealthAntivirusStatus2["Online"] = "online";
    return HealthAntivirusStatus2;
  })(HealthAntivirusStatus || {});
  exports.HealthAntivirusStatus = HealthAntivirusStatus;
});

// node_modules/node-appwrite/dist/enums/health-check-status.js
var require_health_check_status = __commonJS((exports) => {
  var HealthCheckStatus = /* @__PURE__ */ ((HealthCheckStatus2) => {
    HealthCheckStatus2["Pass"] = "pass";
    HealthCheckStatus2["Fail"] = "fail";
    return HealthCheckStatus2;
  })(HealthCheckStatus || {});
  exports.HealthCheckStatus = HealthCheckStatus;
});

// node_modules/node-appwrite/dist/enums/message-status.js
var require_message_status = __commonJS((exports) => {
  var MessageStatus = /* @__PURE__ */ ((MessageStatus2) => {
    MessageStatus2["Draft"] = "draft";
    MessageStatus2["Processing"] = "processing";
    MessageStatus2["Scheduled"] = "scheduled";
    MessageStatus2["Sent"] = "sent";
    MessageStatus2["Failed"] = "failed";
    return MessageStatus2;
  })(MessageStatus || {});
  exports.MessageStatus = MessageStatus;
});

// node_modules/node-appwrite/dist/index.js
var require_dist = __commonJS((exports) => {
  var client = require_client();
  var account = require_account();
  var avatars = require_avatars();
  var databases = require_databases();
  var functions = require_functions();
  var graphql = require_graphql();
  var health = require_health();
  var locale = require_locale();
  var messaging = require_messaging();
  var sites = require_sites();
  var storage = require_storage();
  var tablesDb = require_tables_db();
  var teams = require_teams();
  var tokens = require_tokens();
  var users = require_users();
  var permission = require_permission();
  var role = require_role();
  var id = require_id();
  var operator = require_operator();
  var authenticatorType = require_authenticator_type();
  var authenticationFactor = require_authentication_factor();
  var oAuthProvider = require_o_auth_provider();
  var browser = require_browser();
  var creditCard = require_credit_card();
  var flag = require_flag();
  var relationshipType = require_relationship_type();
  var relationMutate = require_relation_mutate();
  var indexType = require_index_type();
  var runtime = require_runtime();
  var vcsDeploymentType = require_vcs_deployment_type();
  var deploymentDownloadType = require_deployment_download_type();
  var executionMethod = require_execution_method();
  var name = require_name();
  var messagePriority = require_message_priority();
  var smtpEncryption = require_smtp_encryption();
  var framework = require_framework();
  var buildRuntime = require_build_runtime();
  var adapter = require_adapter();
  var compression = require_compression();
  var imageGravity = require_image_gravity();
  var imageFormat = require_image_format();
  var passwordHash = require_password_hash();
  var messagingProviderType = require_messaging_provider_type();
  var databaseType = require_database_type();
  var attributeStatus = require_attribute_status();
  var columnStatus = require_column_status();
  var indexStatus = require_index_status();
  var deploymentStatus = require_deployment_status();
  var executionTrigger = require_execution_trigger();
  var executionStatus = require_execution_status();
  var healthAntivirusStatus = require_health_antivirus_status();
  var healthCheckStatus = require_health_check_status();
  var messageStatus = require_message_status();
  Object.defineProperty(exports, "AppwriteException", {
    enumerable: true,
    get: function() {
      return client.AppwriteException;
    }
  });
  Object.defineProperty(exports, "Client", {
    enumerable: true,
    get: function() {
      return client.Client;
    }
  });
  Object.defineProperty(exports, "Query", {
    enumerable: true,
    get: function() {
      return client.Query;
    }
  });
  Object.defineProperty(exports, "Account", {
    enumerable: true,
    get: function() {
      return account.Account;
    }
  });
  Object.defineProperty(exports, "Avatars", {
    enumerable: true,
    get: function() {
      return avatars.Avatars;
    }
  });
  Object.defineProperty(exports, "Databases", {
    enumerable: true,
    get: function() {
      return databases.Databases;
    }
  });
  Object.defineProperty(exports, "Functions", {
    enumerable: true,
    get: function() {
      return functions.Functions;
    }
  });
  Object.defineProperty(exports, "Graphql", {
    enumerable: true,
    get: function() {
      return graphql.Graphql;
    }
  });
  Object.defineProperty(exports, "Health", {
    enumerable: true,
    get: function() {
      return health.Health;
    }
  });
  Object.defineProperty(exports, "Locale", {
    enumerable: true,
    get: function() {
      return locale.Locale;
    }
  });
  Object.defineProperty(exports, "Messaging", {
    enumerable: true,
    get: function() {
      return messaging.Messaging;
    }
  });
  Object.defineProperty(exports, "Sites", {
    enumerable: true,
    get: function() {
      return sites.Sites;
    }
  });
  Object.defineProperty(exports, "Storage", {
    enumerable: true,
    get: function() {
      return storage.Storage;
    }
  });
  Object.defineProperty(exports, "TablesDB", {
    enumerable: true,
    get: function() {
      return tablesDb.TablesDB;
    }
  });
  Object.defineProperty(exports, "Teams", {
    enumerable: true,
    get: function() {
      return teams.Teams;
    }
  });
  Object.defineProperty(exports, "Tokens", {
    enumerable: true,
    get: function() {
      return tokens.Tokens;
    }
  });
  Object.defineProperty(exports, "Users", {
    enumerable: true,
    get: function() {
      return users.Users;
    }
  });
  Object.defineProperty(exports, "Permission", {
    enumerable: true,
    get: function() {
      return permission.Permission;
    }
  });
  Object.defineProperty(exports, "Role", {
    enumerable: true,
    get: function() {
      return role.Role;
    }
  });
  Object.defineProperty(exports, "ID", {
    enumerable: true,
    get: function() {
      return id.ID;
    }
  });
  Object.defineProperty(exports, "Condition", {
    enumerable: true,
    get: function() {
      return operator.Condition;
    }
  });
  Object.defineProperty(exports, "Operator", {
    enumerable: true,
    get: function() {
      return operator.Operator;
    }
  });
  Object.defineProperty(exports, "AuthenticatorType", {
    enumerable: true,
    get: function() {
      return authenticatorType.AuthenticatorType;
    }
  });
  Object.defineProperty(exports, "AuthenticationFactor", {
    enumerable: true,
    get: function() {
      return authenticationFactor.AuthenticationFactor;
    }
  });
  Object.defineProperty(exports, "OAuthProvider", {
    enumerable: true,
    get: function() {
      return oAuthProvider.OAuthProvider;
    }
  });
  Object.defineProperty(exports, "Browser", {
    enumerable: true,
    get: function() {
      return browser.Browser;
    }
  });
  Object.defineProperty(exports, "CreditCard", {
    enumerable: true,
    get: function() {
      return creditCard.CreditCard;
    }
  });
  Object.defineProperty(exports, "Flag", {
    enumerable: true,
    get: function() {
      return flag.Flag;
    }
  });
  Object.defineProperty(exports, "RelationshipType", {
    enumerable: true,
    get: function() {
      return relationshipType.RelationshipType;
    }
  });
  Object.defineProperty(exports, "RelationMutate", {
    enumerable: true,
    get: function() {
      return relationMutate.RelationMutate;
    }
  });
  Object.defineProperty(exports, "IndexType", {
    enumerable: true,
    get: function() {
      return indexType.IndexType;
    }
  });
  Object.defineProperty(exports, "Runtime", {
    enumerable: true,
    get: function() {
      return runtime.Runtime;
    }
  });
  Object.defineProperty(exports, "VCSDeploymentType", {
    enumerable: true,
    get: function() {
      return vcsDeploymentType.VCSDeploymentType;
    }
  });
  Object.defineProperty(exports, "DeploymentDownloadType", {
    enumerable: true,
    get: function() {
      return deploymentDownloadType.DeploymentDownloadType;
    }
  });
  Object.defineProperty(exports, "ExecutionMethod", {
    enumerable: true,
    get: function() {
      return executionMethod.ExecutionMethod;
    }
  });
  Object.defineProperty(exports, "Name", {
    enumerable: true,
    get: function() {
      return name.Name;
    }
  });
  Object.defineProperty(exports, "MessagePriority", {
    enumerable: true,
    get: function() {
      return messagePriority.MessagePriority;
    }
  });
  Object.defineProperty(exports, "SmtpEncryption", {
    enumerable: true,
    get: function() {
      return smtpEncryption.SmtpEncryption;
    }
  });
  Object.defineProperty(exports, "Framework", {
    enumerable: true,
    get: function() {
      return framework.Framework;
    }
  });
  Object.defineProperty(exports, "BuildRuntime", {
    enumerable: true,
    get: function() {
      return buildRuntime.BuildRuntime;
    }
  });
  Object.defineProperty(exports, "Adapter", {
    enumerable: true,
    get: function() {
      return adapter.Adapter;
    }
  });
  Object.defineProperty(exports, "Compression", {
    enumerable: true,
    get: function() {
      return compression.Compression;
    }
  });
  Object.defineProperty(exports, "ImageGravity", {
    enumerable: true,
    get: function() {
      return imageGravity.ImageGravity;
    }
  });
  Object.defineProperty(exports, "ImageFormat", {
    enumerable: true,
    get: function() {
      return imageFormat.ImageFormat;
    }
  });
  Object.defineProperty(exports, "PasswordHash", {
    enumerable: true,
    get: function() {
      return passwordHash.PasswordHash;
    }
  });
  Object.defineProperty(exports, "MessagingProviderType", {
    enumerable: true,
    get: function() {
      return messagingProviderType.MessagingProviderType;
    }
  });
  Object.defineProperty(exports, "DatabaseType", {
    enumerable: true,
    get: function() {
      return databaseType.DatabaseType;
    }
  });
  Object.defineProperty(exports, "AttributeStatus", {
    enumerable: true,
    get: function() {
      return attributeStatus.AttributeStatus;
    }
  });
  Object.defineProperty(exports, "ColumnStatus", {
    enumerable: true,
    get: function() {
      return columnStatus.ColumnStatus;
    }
  });
  Object.defineProperty(exports, "IndexStatus", {
    enumerable: true,
    get: function() {
      return indexStatus.IndexStatus;
    }
  });
  Object.defineProperty(exports, "DeploymentStatus", {
    enumerable: true,
    get: function() {
      return deploymentStatus.DeploymentStatus;
    }
  });
  Object.defineProperty(exports, "ExecutionTrigger", {
    enumerable: true,
    get: function() {
      return executionTrigger.ExecutionTrigger;
    }
  });
  Object.defineProperty(exports, "ExecutionStatus", {
    enumerable: true,
    get: function() {
      return executionStatus.ExecutionStatus;
    }
  });
  Object.defineProperty(exports, "HealthAntivirusStatus", {
    enumerable: true,
    get: function() {
      return healthAntivirusStatus.HealthAntivirusStatus;
    }
  });
  Object.defineProperty(exports, "HealthCheckStatus", {
    enumerable: true,
    get: function() {
      return healthCheckStatus.HealthCheckStatus;
    }
  });
  Object.defineProperty(exports, "MessageStatus", {
    enumerable: true,
    get: function() {
      return messageStatus.MessageStatus;
    }
  });
});

// node_modules/hono/dist/compose.js
var compose = (middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || undefined;
      }
      if (handler) {
        try {
          res = await handler(context, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
  };
};

// node_modules/hono/dist/request/constants.js
var GET_MATCH_RESULT = Symbol();

// node_modules/hono/dist/utils/body.js
var parseBody = async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
};
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
var handleParsingAllValues = (form, key, value) => {
  if (form[key] !== undefined) {
    if (Array.isArray(form[key])) {
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value;
    } else {
      form[key] = [value];
    }
  }
};
var handleParsingNestedValues = (form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
};

// node_modules/hono/dist/utils/url.js
var splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
};
var extractGroupsFromPath = (path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
};
var replaceGroupMarks = (paths, groups) => {
  for (let i = groups.length - 1;i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1;j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label, next) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
};
var tryDecode = (str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder(match);
      } catch {
        return match;
      }
    });
  }
};
var tryDecodeURI = (str) => tryDecode(str, decodeURI);
var getPath = (request) => {
  const url = request.url;
  const start = url.indexOf("/", url.indexOf(":") + 4);
  let i = start;
  for (;i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i);
      const path = url.slice(start, queryIndex === -1 ? undefined : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start, i);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
};
var mergePath = (base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
};
var checkOptionalParameter = (path) => {
  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf("?", 8);
    if (keyIndex2 === -1) {
      return;
    }
    if (!url.startsWith(key, keyIndex2 + 1)) {
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? undefined : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(keyIndex + 1, valueIndex === -1 ? nextKeyIndex === -1 ? undefined : nextKeyIndex : valueIndex);
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? undefined : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// node_modules/hono/dist/request.js
var tryDecodeURIComponent = (str) => tryDecode(str, decodeURIComponent_);
var HonoRequest = class {
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param && /\%/.test(param) ? tryDecodeURIComponent(param) : param;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value !== undefined) {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? undefined;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = (key) => {
    const { bodyCache, raw } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw[key]();
  };
  json() {
    return this.#cachedBody("text").then((text) => JSON.parse(text));
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = (value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
};
var escapeRe = /[&<>'"]/;
var stringBufferToString = async (buffer, callbacks) => {
  let str = "";
  callbacks ||= [];
  const resolvedBuffer = await Promise.all(buffer);
  for (let i = resolvedBuffer.length - 1;; i--) {
    str += resolvedBuffer[i];
    i--;
    if (i < 0) {
      break;
    }
    let r = resolvedBuffer[i];
    if (typeof r === "object") {
      callbacks.push(...r.callbacks || []);
    }
    const isEscaped = r.isEscaped;
    r = await (typeof r === "object" ? r.toString() : r);
    if (typeof r === "object") {
      callbacks.push(...r.callbacks || []);
    }
    if (r.isEscaped ?? isEscaped) {
      str += r;
    } else {
      const buf = [str];
      escapeToBuffer(r, buf);
      str = buf[0];
    }
  }
  return raw(str, callbacks);
};
var escapeToBuffer = (str, buffer) => {
  const match = str.search(escapeRe);
  if (match === -1) {
    buffer[0] += str;
    return;
  }
  let escape;
  let index;
  let lastIndex = 0;
  for (index = match;index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escape = "&quot;";
        break;
      case 39:
        escape = "&#39;";
        break;
      case 38:
        escape = "&amp;";
        break;
      case 60:
        escape = "&lt;";
        break;
      case 62:
        escape = "&gt;";
        break;
      default:
        continue;
    }
    buffer[0] += str.substring(lastIndex, index) + escape;
    lastIndex = index + 1;
  }
  buffer[0] += str.substring(lastIndex, index);
};
var resolveCallbackSync = (str) => {
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return str;
  }
  const buffer = [str];
  const context = {};
  callbacks.forEach((c) => c({ phase: HtmlEscapedCallbackPhase.Stringify, buffer, context }));
  return buffer[0];
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then((res) => Promise.all(res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))).then(() => buffer[0]));
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
};

// node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = (contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
};
var Context = class {
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers
    });
  }
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k, v] of this.#res.headers.entries()) {
        if (k === "content-type") {
          continue;
        }
        if (k === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = (...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  };
  setLayout = (layout) => this.#layout = layout;
  getLayout = () => this.#layout;
  setRenderer = (renderer) => {
    this.#renderer = renderer;
  };
  header = (name, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers;
    if (value === undefined) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value);
    } else {
      headers.set(name, value);
    }
  };
  status = (status) => {
    this.#status = status;
  };
  set = (key, value) => {
    this.#var ??= /* @__PURE__ */ new Map;
    this.#var.set(key, value);
  };
  get = (key) => {
    return this.#var ? this.#var.get(key) : undefined;
  };
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers;
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value);
        } else {
          responseHeaders.set(key, value);
        }
      }
    }
    if (headers) {
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k, v);
        } else {
          responseHeaders.delete(k);
          for (const v2 of v) {
            responseHeaders.append(k, v2);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data, { status, headers: responseHeaders });
  }
  newResponse = (...args) => this.#newResponse(...args);
  body = (data, arg, headers) => this.#newResponse(data, arg, headers);
  text = (text, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(text, arg, setDefaultContentType(TEXT_PLAIN, headers));
  };
  json = (object, arg, headers) => {
    return this.#newResponse(JSON.stringify(object), arg, setDefaultContentType("application/json", headers));
  };
  html = (html, arg, headers) => {
    const res = (html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers));
    return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
  };
  redirect = (location, status) => {
    const locationString = String(location);
    this.header("Location", !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString));
    return this.newResponse(null, status ?? 302);
  };
  notFound = () => {
    this.#notFoundHandler ??= () => new Response;
    return this.#notFoundHandler(this);
  };
};

// node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};

// node_modules/hono/dist/utils/constants.js
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// node_modules/hono/dist/hono-base.js
var notFoundHandler = (c) => {
  return c.text("404 Not Found", 404);
};
var errorHandler = (err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
};
var Hono = class {
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p of [path].flat()) {
        this.#path = p;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.errorHandler = this.errorHandler;
    clone.#notFoundHandler = this.#notFoundHandler;
    clone.routes = this.routes;
    return clone;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app) {
    const subApp = this.basePath(path);
    app.routes.map((r) => {
      let handler;
      if (app.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res;
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = (handler) => {
    this.errorHandler = handler;
    return this;
  };
  notFound = (handler) => {
    this.#notFoundHandler = handler;
    return this;
  };
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = (request) => request;
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = undefined;
      try {
        executionContext = c.executionCtx;
      } catch {}
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    };
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env, "GET")))();
    }
    const path = this.getPath(request, { env });
    const matchResult = this.router.match(method, path);
    const c = new Context(request, {
      path,
      matchResult,
      env,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then((resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c);
        if (!context.finalized) {
          throw new Error("Context is not finalized. Did you forget to return a Response object or `await next()`?");
        }
        return context.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  fetch = (request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  };
  request = (input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(new Request(/^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`, requestInit), Env, executionCtx);
  };
  fire = () => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, undefined, event.request.method));
    });
  };
};

// node_modules/hono/dist/router/reg-exp-router/matcher.js
var emptyParam = [];
function match(method, path) {
  const matchers = this.buildAllMatchers();
  const match2 = (method2, path2) => {
    const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
    const staticMatch = matcher[2][path2];
    if (staticMatch) {
      return staticMatch;
    }
    const match3 = path2.match(matcher[0]);
    if (!match3) {
      return [[], emptyParam];
    }
    const index = match3.indexOf("", 1);
    return [matcher[1][index], match3];
  };
  this.match = match2;
  return match2(method, path);
}

// node_modules/hono/dist/router/reg-exp-router/node.js
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var Node = class {
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== undefined) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        if (regexpStr === ".*") {
          throw PATH_ERROR;
        }
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node;
        if (name !== "") {
          node.#varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node;
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  #context = { varIndex: 0 };
  #root = new Node;
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0;; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1;i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1;j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== undefined) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== undefined) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(path === "*" ? "" : `^${path.replace(/\/\*$|([.\\+*[^\]$()])/g, (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)")}$`);
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie;
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map((route) => [!/\*|\/:/.test(route[0]), ...route]).sort(([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length);
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length;i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (;paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length;i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length;j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length;k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path) {
  if (!middleware) {
    return;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return;
}
var RegExpRouter = class {
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach((p) => re.test(p) && routes[m][p].push([handler, paramCount]));
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length;i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path2] ||= [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match = match;
  buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = undefined;
    clearWildcardRegExpCache();
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]]));
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/reg-exp-router/prepared-router.js
var PreparedRegExpRouter = class {
  name = "PreparedRegExpRouter";
  #matchers;
  #relocateMap;
  constructor(matchers, relocateMap) {
    this.#matchers = matchers;
    this.#relocateMap = relocateMap;
  }
  #addWildcard(method, handlerData) {
    const matcher = this.#matchers[method];
    matcher[1].forEach((list) => list && list.push(handlerData));
    Object.values(matcher[2]).forEach((list) => list[0].push(handlerData));
  }
  #addPath(method, path, handler, indexes, map) {
    const matcher = this.#matchers[method];
    if (!map) {
      matcher[2][path][0].push([handler, {}]);
    } else {
      indexes.forEach((index) => {
        if (typeof index === "number") {
          matcher[1][index].push([handler, map]);
        } else {
          matcher[2][index || path][0].push([handler, map]);
        }
      });
    }
  }
  add(method, path, handler) {
    if (!this.#matchers[method]) {
      const all = this.#matchers[METHOD_NAME_ALL];
      const staticMap = {};
      for (const key in all[2]) {
        staticMap[key] = [all[2][key][0].slice(), emptyParam];
      }
      this.#matchers[method] = [
        all[0],
        all[1].map((list) => Array.isArray(list) ? list.slice() : 0),
        staticMap
      ];
    }
    if (path === "/*" || path === "*") {
      const handlerData = [handler, {}];
      if (method === METHOD_NAME_ALL) {
        for (const m in this.#matchers) {
          this.#addWildcard(m, handlerData);
        }
      } else {
        this.#addWildcard(method, handlerData);
      }
      return;
    }
    const data = this.#relocateMap[path];
    if (!data) {
      throw new Error(`Path ${path} is not registered`);
    }
    for (const [indexes, map] of data) {
      if (method === METHOD_NAME_ALL) {
        for (const m in this.#matchers) {
          this.#addPath(m, path, handler, indexes, map);
        }
      } else {
        this.#addPath(method, path, handler, indexes, map);
      }
    }
  }
  buildAllMatchers() {
    return this.#matchers;
  }
  match = match;
};

// node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (;i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length;i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = undefined;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/node.js
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const p = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new Node2;
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length;i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== undefined) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length;i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length;j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(...this.#getHandlerSets(nextNode.#children["*"], method, node.#params));
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length;k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          const [key, name, matcher] = pattern;
          if (!part && !(matcher instanceof RegExp)) {
            continue;
          }
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(...this.#getHandlerSets(child.#children["*"], method, params, node.#params));
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2;
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length;i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter, new TrieRouter]
    });
  }
};

// node_modules/hono/dist/adapter/bun/serve-static.js
import { stat } from "fs/promises";
import { join } from "path";

// node_modules/hono/dist/utils/compress.js
var COMPRESSIBLE_CONTENT_TYPE_REGEX = /^\s*(?:text\/(?!event-stream(?:[;\s]|$))[^;\s]+|application\/(?:javascript|json|xml|xml-dtd|ecmascript|dart|postscript|rtf|tar|toml|vnd\.dart|vnd\.ms-fontobject|vnd\.ms-opentype|wasm|x-httpd-php|x-javascript|x-ns-proxy-autoconfig|x-sh|x-tar|x-virtualbox-hdd|x-virtualbox-ova|x-virtualbox-ovf|x-virtualbox-vbox|x-virtualbox-vdi|x-virtualbox-vhd|x-virtualbox-vmdk|x-www-form-urlencoded)|font\/(?:otf|ttf)|image\/(?:bmp|vnd\.adobe\.photoshop|vnd\.microsoft\.icon|vnd\.ms-dds|x-icon|x-ms-bmp)|message\/rfc822|model\/gltf-binary|x-shader\/x-fragment|x-shader\/x-vertex|[^;\s]+?\+(?:json|text|xml|yaml))(?:[;\s]|$)/i;

// node_modules/hono/dist/utils/mime.js
var getMimeType = (filename, mimes = baseMimes) => {
  const regexp = /\.([a-zA-Z0-9]+?)$/;
  const match2 = filename.match(regexp);
  if (!match2) {
    return;
  }
  let mimeType = mimes[match2[1]];
  if (mimeType && mimeType.startsWith("text")) {
    mimeType += "; charset=utf-8";
  }
  return mimeType;
};
var _baseMimes = {
  aac: "audio/aac",
  avi: "video/x-msvideo",
  avif: "image/avif",
  av1: "video/av1",
  bin: "application/octet-stream",
  bmp: "image/bmp",
  css: "text/css",
  csv: "text/csv",
  eot: "application/vnd.ms-fontobject",
  epub: "application/epub+zip",
  gif: "image/gif",
  gz: "application/gzip",
  htm: "text/html",
  html: "text/html",
  ico: "image/x-icon",
  ics: "text/calendar",
  jpeg: "image/jpeg",
  jpg: "image/jpeg",
  js: "text/javascript",
  json: "application/json",
  jsonld: "application/ld+json",
  map: "application/json",
  mid: "audio/x-midi",
  midi: "audio/x-midi",
  mjs: "text/javascript",
  mp3: "audio/mpeg",
  mp4: "video/mp4",
  mpeg: "video/mpeg",
  oga: "audio/ogg",
  ogv: "video/ogg",
  ogx: "application/ogg",
  opus: "audio/opus",
  otf: "font/otf",
  pdf: "application/pdf",
  png: "image/png",
  rtf: "application/rtf",
  svg: "image/svg+xml",
  tif: "image/tiff",
  tiff: "image/tiff",
  ts: "video/mp2t",
  ttf: "font/ttf",
  txt: "text/plain",
  wasm: "application/wasm",
  webm: "video/webm",
  weba: "audio/webm",
  webmanifest: "application/manifest+json",
  webp: "image/webp",
  woff: "font/woff",
  woff2: "font/woff2",
  xhtml: "application/xhtml+xml",
  xml: "application/xml",
  zip: "application/zip",
  "3gp": "video/3gpp",
  "3g2": "video/3gpp2",
  gltf: "model/gltf+json",
  glb: "model/gltf-binary"
};
var baseMimes = _baseMimes;

// node_modules/hono/dist/middleware/serve-static/path.js
var defaultJoin = (...paths) => {
  let result = paths.filter((p) => p !== "").join("/");
  result = result.replace(/(?<=\/)\/+/g, "");
  const segments = result.split("/");
  const resolved = [];
  for (const segment of segments) {
    if (segment === ".." && resolved.length > 0 && resolved.at(-1) !== "..") {
      resolved.pop();
    } else if (segment !== ".") {
      resolved.push(segment);
    }
  }
  return resolved.join("/") || ".";
};

// node_modules/hono/dist/middleware/serve-static/index.js
var ENCODINGS = {
  br: ".br",
  zstd: ".zst",
  gzip: ".gz"
};
var ENCODINGS_ORDERED_KEYS = Object.keys(ENCODINGS);
var DEFAULT_DOCUMENT = "index.html";
var serveStatic = (options) => {
  const root = options.root ?? "./";
  const optionPath = options.path;
  const join = options.join ?? defaultJoin;
  return async (c, next) => {
    if (c.finalized) {
      return next();
    }
    let filename;
    if (options.path) {
      filename = options.path;
    } else {
      try {
        filename = decodeURIComponent(c.req.path);
        if (/(?:^|[\/\\])\.\.(?:$|[\/\\])/.test(filename)) {
          throw new Error;
        }
      } catch {
        await options.onNotFound?.(c.req.path, c);
        return next();
      }
    }
    let path = join(root, !optionPath && options.rewriteRequestPath ? options.rewriteRequestPath(filename) : filename);
    if (options.isDir && await options.isDir(path)) {
      path = join(path, DEFAULT_DOCUMENT);
    }
    const getContent = options.getContent;
    let content = await getContent(path, c);
    if (content instanceof Response) {
      return c.newResponse(content.body, content);
    }
    if (content) {
      const mimeType = options.mimes && getMimeType(path, options.mimes) || getMimeType(path);
      c.header("Content-Type", mimeType || "application/octet-stream");
      if (options.precompressed && (!mimeType || COMPRESSIBLE_CONTENT_TYPE_REGEX.test(mimeType))) {
        const acceptEncodingSet = new Set(c.req.header("Accept-Encoding")?.split(",").map((encoding) => encoding.trim()));
        for (const encoding of ENCODINGS_ORDERED_KEYS) {
          if (!acceptEncodingSet.has(encoding)) {
            continue;
          }
          const compressedContent = await getContent(path + ENCODINGS[encoding], c);
          if (compressedContent) {
            content = compressedContent;
            c.header("Content-Encoding", encoding);
            c.header("Vary", "Accept-Encoding", { append: true });
            break;
          }
        }
      }
      await options.onFound?.(path, c);
      return c.body(content);
    }
    await options.onNotFound?.(path, c);
    await next();
    return;
  };
};

// node_modules/hono/dist/adapter/bun/serve-static.js
var serveStatic2 = (options) => {
  return async function serveStatic2(c, next) {
    const getContent = async (path) => {
      const file = Bun.file(path);
      return await file.exists() ? file : null;
    };
    const isDir = async (path) => {
      let isDir2;
      try {
        const stats = await stat(path);
        isDir2 = stats.isDirectory();
      } catch {}
      return isDir2;
    };
    return serveStatic({
      ...options,
      getContent,
      join,
      isDir
    })(c, next);
  };
};

// node_modules/hono/dist/helper/ssg/middleware.js
var X_HONO_DISABLE_SSG_HEADER_KEY = "x-hono-disable-ssg";
var SSG_DISABLED_RESPONSE = (() => {
  try {
    return new Response("SSG is disabled", {
      status: 404,
      headers: { [X_HONO_DISABLE_SSG_HEADER_KEY]: "true" }
    });
  } catch {
    return null;
  }
})();
// node_modules/hono/dist/adapter/bun/ssg.js
var { write } = Bun;

// node_modules/hono/dist/helper/websocket/index.js
var WSContext = class {
  #init;
  constructor(init) {
    this.#init = init;
    this.raw = init.raw;
    this.url = init.url ? new URL(init.url) : null;
    this.protocol = init.protocol ?? null;
  }
  send(source, options) {
    this.#init.send(source, options ?? {});
  }
  raw;
  binaryType = "arraybuffer";
  get readyState() {
    return this.#init.readyState;
  }
  url;
  protocol;
  close(code, reason) {
    this.#init.close(code, reason);
  }
};
var defineWebSocketHelper = (handler) => {
  return (...args) => {
    if (typeof args[0] === "function") {
      const [createEvents, options] = args;
      return async function upgradeWebSocket(c, next) {
        const events = await createEvents(c);
        const result = await handler(c, events, options);
        if (result) {
          return result;
        }
        await next();
      };
    } else {
      const [c, events, options] = args;
      return (async () => {
        const upgraded = await handler(c, events, options);
        if (!upgraded) {
          throw new Error("Failed to upgrade WebSocket");
        }
        return upgraded;
      })();
    }
  };
};

// node_modules/hono/dist/adapter/bun/server.js
var getBunServer = (c) => ("server" in c.env) ? c.env.server : c.env;

// node_modules/hono/dist/adapter/bun/websocket.js
var upgradeWebSocket = defineWebSocketHelper((c, events) => {
  const server = getBunServer(c);
  if (!server) {
    throw new TypeError("env has to include the 2nd argument of fetch.");
  }
  const upgradeResult = server.upgrade(c.req.raw, {
    data: {
      events,
      url: new URL(c.req.url),
      protocol: c.req.url
    }
  });
  if (upgradeResult) {
    return new Response(null);
  }
  return;
});

// node_modules/hono/dist/utils/cookie.js
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse = (cookie, name) => {
  if (name && cookie.indexOf(name) === -1) {
    return {};
  }
  const pairs = cookie.trim().split(";");
  const parsedCookie = {};
  for (let pairStr of pairs) {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1) {
      continue;
    }
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {
      continue;
    }
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
      cookieValue = cookieValue.slice(1, -1);
    }
    if (validCookieValueRegEx.test(cookieValue)) {
      parsedCookie[cookieName] = cookieValue.indexOf("%") !== -1 ? tryDecode(cookieValue, decodeURIComponent_) : cookieValue;
      if (name) {
        break;
      }
    }
  }
  return parsedCookie;
};

// node_modules/hono/dist/helper/cookie/index.js
var getCookie = (c, key, prefix) => {
  const cookie = c.req.raw.headers.get("Cookie");
  if (typeof key === "string") {
    if (!cookie) {
      return;
    }
    let finalKey = key;
    if (prefix === "secure") {
      finalKey = "__Secure-" + key;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key;
    }
    const obj2 = parse(cookie, finalKey);
    return obj2[finalKey];
  }
  if (!cookie) {
    return {};
  }
  const obj = parse(cookie);
  return obj;
};

// node_modules/hono/dist/jsx/constants.js
var DOM_RENDERER = Symbol("RENDERER");
var DOM_ERROR_HANDLER = Symbol("ERROR_HANDLER");
var DOM_STASH = Symbol("STASH");
var DOM_INTERNAL_TAG = Symbol("INTERNAL");
var DOM_MEMO = Symbol("MEMO");
var PERMALINK = Symbol("PERMALINK");

// node_modules/hono/dist/jsx/dom/utils.js
var setInternalTagFlag = (fn) => {
  fn[DOM_INTERNAL_TAG] = true;
  return fn;
};

// node_modules/hono/dist/jsx/dom/context.js
var createContextProviderFunction = (values) => ({ value, children }) => {
  if (!children) {
    return;
  }
  const props = {
    children: [
      {
        tag: setInternalTagFlag(() => {
          values.push(value);
        }),
        props: {}
      }
    ]
  };
  if (Array.isArray(children)) {
    props.children.push(...children.flat());
  } else {
    props.children.push(children);
  }
  props.children.push({
    tag: setInternalTagFlag(() => {
      values.pop();
    }),
    props: {}
  });
  const res = { tag: "", props, type: "" };
  res[DOM_ERROR_HANDLER] = (err) => {
    values.pop();
    throw err;
  };
  return res;
};
var createContext = (defaultValue) => {
  const values = [defaultValue];
  const context = createContextProviderFunction(values);
  context.values = values;
  context.Provider = context;
  globalContexts.push(context);
  return context;
};

// node_modules/hono/dist/jsx/context.js
var globalContexts = [];
var createContext2 = (defaultValue) => {
  const values = [defaultValue];
  const context = (props) => {
    values.push(props.value);
    let string;
    try {
      string = props.children ? (Array.isArray(props.children) ? new JSXFragmentNode("", {}, props.children) : props.children).toString() : "";
    } finally {
      values.pop();
    }
    if (string instanceof Promise) {
      return string.then((resString) => raw(resString, resString.callbacks));
    } else {
      return raw(string);
    }
  };
  context.values = values;
  context.Provider = context;
  context[DOM_RENDERER] = createContextProviderFunction(values);
  globalContexts.push(context);
  return context;
};
var useContext = (context) => {
  return context.values.at(-1);
};

// node_modules/hono/dist/jsx/intrinsic-element/common.js
var deDupeKeyMap = {
  title: [],
  script: ["src"],
  style: ["data-href"],
  link: ["href"],
  meta: ["name", "httpEquiv", "charset", "itemProp"]
};
var domRenderers = {};
var dataPrecedenceAttr = "data-precedence";

// node_modules/hono/dist/jsx/intrinsic-element/components.js
var exports_components = {};
__export(exports_components, {
  title: () => title,
  style: () => style,
  script: () => script,
  meta: () => meta,
  link: () => link,
  input: () => input,
  form: () => form,
  button: () => button
});

// node_modules/hono/dist/jsx/children.js
var toArray = (children) => Array.isArray(children) ? children : [children];

// node_modules/hono/dist/jsx/intrinsic-element/components.js
var metaTagMap = /* @__PURE__ */ new WeakMap;
var insertIntoHead = (tagName, tag, props, precedence) => ({ buffer, context }) => {
  if (!buffer) {
    return;
  }
  const map = metaTagMap.get(context) || {};
  metaTagMap.set(context, map);
  const tags = map[tagName] ||= [];
  let duped = false;
  const deDupeKeys = deDupeKeyMap[tagName];
  if (deDupeKeys.length > 0) {
    LOOP:
      for (const [, tagProps] of tags) {
        for (const key of deDupeKeys) {
          if ((tagProps?.[key] ?? null) === props?.[key]) {
            duped = true;
            break LOOP;
          }
        }
      }
  }
  if (duped) {
    buffer[0] = buffer[0].replaceAll(tag, "");
  } else if (deDupeKeys.length > 0) {
    tags.push([tag, props, precedence]);
  } else {
    tags.unshift([tag, props, precedence]);
  }
  if (buffer[0].indexOf("</head>") !== -1) {
    let insertTags;
    if (precedence === undefined) {
      insertTags = tags.map(([tag2]) => tag2);
    } else {
      const precedences = [];
      insertTags = tags.map(([tag2, , precedence2]) => {
        let order = precedences.indexOf(precedence2);
        if (order === -1) {
          precedences.push(precedence2);
          order = precedences.length - 1;
        }
        return [tag2, order];
      }).sort((a, b) => a[1] - b[1]).map(([tag2]) => tag2);
    }
    insertTags.forEach((tag2) => {
      buffer[0] = buffer[0].replaceAll(tag2, "");
    });
    buffer[0] = buffer[0].replace(/(?=<\/head>)/, insertTags.join(""));
  }
};
var returnWithoutSpecialBehavior = (tag, children, props) => raw(new JSXNode(tag, props, toArray(children ?? [])).toString());
var documentMetadataTag = (tag, children, props, sort) => {
  if ("itemProp" in props) {
    return returnWithoutSpecialBehavior(tag, children, props);
  }
  let { precedence, blocking, ...restProps } = props;
  precedence = sort ? precedence ?? "" : undefined;
  if (sort) {
    restProps[dataPrecedenceAttr] = precedence;
  }
  const string = new JSXNode(tag, restProps, toArray(children || [])).toString();
  if (string instanceof Promise) {
    return string.then((resString) => raw(string, [
      ...resString.callbacks || [],
      insertIntoHead(tag, resString, restProps, precedence)
    ]));
  } else {
    return raw(string, [insertIntoHead(tag, string, restProps, precedence)]);
  }
};
var title = ({ children, ...props }) => {
  const nameSpaceContext = getNameSpaceContext();
  if (nameSpaceContext) {
    const context = useContext(nameSpaceContext);
    if (context === "svg" || context === "head") {
      return new JSXNode("title", props, toArray(children ?? []));
    }
  }
  return documentMetadataTag("title", children, props, false);
};
var script = ({
  children,
  ...props
}) => {
  const nameSpaceContext = getNameSpaceContext();
  if (["src", "async"].some((k) => !props[k]) || nameSpaceContext && useContext(nameSpaceContext) === "head") {
    return returnWithoutSpecialBehavior("script", children, props);
  }
  return documentMetadataTag("script", children, props, false);
};
var style = ({
  children,
  ...props
}) => {
  if (!["href", "precedence"].every((k) => (k in props))) {
    return returnWithoutSpecialBehavior("style", children, props);
  }
  props["data-href"] = props.href;
  delete props.href;
  return documentMetadataTag("style", children, props, true);
};
var link = ({ children, ...props }) => {
  if (["onLoad", "onError"].some((k) => (k in props)) || props.rel === "stylesheet" && (!("precedence" in props) || ("disabled" in props))) {
    return returnWithoutSpecialBehavior("link", children, props);
  }
  return documentMetadataTag("link", children, props, "precedence" in props);
};
var meta = ({ children, ...props }) => {
  const nameSpaceContext = getNameSpaceContext();
  if (nameSpaceContext && useContext(nameSpaceContext) === "head") {
    return returnWithoutSpecialBehavior("meta", children, props);
  }
  return documentMetadataTag("meta", children, props, false);
};
var newJSXNode = (tag, { children, ...props }) => new JSXNode(tag, props, toArray(children ?? []));
var form = (props) => {
  if (typeof props.action === "function") {
    props.action = PERMALINK in props.action ? props.action[PERMALINK] : undefined;
  }
  return newJSXNode("form", props);
};
var formActionableElement = (tag, props) => {
  if (typeof props.formAction === "function") {
    props.formAction = PERMALINK in props.formAction ? props.formAction[PERMALINK] : undefined;
  }
  return newJSXNode(tag, props);
};
var input = (props) => formActionableElement("input", props);
var button = (props) => formActionableElement("button", props);

// node_modules/hono/dist/jsx/utils.js
var normalizeElementKeyMap = /* @__PURE__ */ new Map([
  ["className", "class"],
  ["htmlFor", "for"],
  ["crossOrigin", "crossorigin"],
  ["httpEquiv", "http-equiv"],
  ["itemProp", "itemprop"],
  ["fetchPriority", "fetchpriority"],
  ["noModule", "nomodule"],
  ["formAction", "formaction"]
]);
var normalizeIntrinsicElementKey = (key) => normalizeElementKeyMap.get(key) || key;
var styleObjectForEach = (style2, fn) => {
  for (const [k, v] of Object.entries(style2)) {
    const key = k[0] === "-" || !/[A-Z]/.test(k) ? k : k.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);
    fn(key, v == null ? null : typeof v === "number" ? !key.match(/^(?:a|border-im|column(?:-c|s)|flex(?:$|-[^b])|grid-(?:ar|[^a])|font-w|li|or|sca|st|ta|wido|z)|ty$/) ? `${v}px` : `${v}` : v);
  }
};

// node_modules/hono/dist/jsx/base.js
var nameSpaceContext = undefined;
var getNameSpaceContext = () => nameSpaceContext;
var toSVGAttributeName = (key) => /[A-Z]/.test(key) && key.match(/^(?:al|basel|clip(?:Path|Rule)$|co|do|fill|fl|fo|gl|let|lig|i|marker[EMS]|o|pai|pointe|sh|st[or]|text[^L]|tr|u|ve|w)/) ? key.replace(/([A-Z])/g, "-$1").toLowerCase() : key;
var emptyTags = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var booleanAttributes = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "download",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var childrenToStringToBuffer = (children, buffer) => {
  for (let i = 0, len = children.length;i < len; i++) {
    const child = children[i];
    if (typeof child === "string") {
      escapeToBuffer(child, buffer);
    } else if (typeof child === "boolean" || child === null || child === undefined) {
      continue;
    } else if (child instanceof JSXNode) {
      child.toStringToBuffer(buffer);
    } else if (typeof child === "number" || child.isEscaped) {
      buffer[0] += child;
    } else if (child instanceof Promise) {
      buffer.unshift("", child);
    } else {
      childrenToStringToBuffer(child, buffer);
    }
  }
};
var JSXNode = class {
  tag;
  props;
  key;
  children;
  isEscaped = true;
  localContexts;
  constructor(tag, props, children) {
    this.tag = tag;
    this.props = props;
    this.children = children;
  }
  get type() {
    return this.tag;
  }
  get ref() {
    return this.props.ref || null;
  }
  toString() {
    const buffer = [""];
    this.localContexts?.forEach(([context, value]) => {
      context.values.push(value);
    });
    try {
      this.toStringToBuffer(buffer);
    } finally {
      this.localContexts?.forEach(([context]) => {
        context.values.pop();
      });
    }
    return buffer.length === 1 ? "callbacks" in buffer ? resolveCallbackSync(raw(buffer[0], buffer.callbacks)).toString() : buffer[0] : stringBufferToString(buffer, buffer.callbacks);
  }
  toStringToBuffer(buffer) {
    const tag = this.tag;
    const props = this.props;
    let { children } = this;
    buffer[0] += `<${tag}`;
    const normalizeKey = nameSpaceContext && useContext(nameSpaceContext) === "svg" ? (key) => toSVGAttributeName(normalizeIntrinsicElementKey(key)) : (key) => normalizeIntrinsicElementKey(key);
    for (let [key, v] of Object.entries(props)) {
      key = normalizeKey(key);
      if (key === "children") {} else if (key === "style" && typeof v === "object") {
        let styleStr = "";
        styleObjectForEach(v, (property, value) => {
          if (value != null) {
            styleStr += `${styleStr ? ";" : ""}${property}:${value}`;
          }
        });
        buffer[0] += ' style="';
        escapeToBuffer(styleStr, buffer);
        buffer[0] += '"';
      } else if (typeof v === "string") {
        buffer[0] += ` ${key}="`;
        escapeToBuffer(v, buffer);
        buffer[0] += '"';
      } else if (v === null || v === undefined) {} else if (typeof v === "number" || v.isEscaped) {
        buffer[0] += ` ${key}="${v}"`;
      } else if (typeof v === "boolean" && booleanAttributes.includes(key)) {
        if (v) {
          buffer[0] += ` ${key}=""`;
        }
      } else if (key === "dangerouslySetInnerHTML") {
        if (children.length > 0) {
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        }
        children = [raw(v.__html)];
      } else if (v instanceof Promise) {
        buffer[0] += ` ${key}="`;
        buffer.unshift('"', v);
      } else if (typeof v === "function") {
        if (!key.startsWith("on") && key !== "ref") {
          throw new Error(`Invalid prop '${key}' of type 'function' supplied to '${tag}'.`);
        }
      } else {
        buffer[0] += ` ${key}="`;
        escapeToBuffer(v.toString(), buffer);
        buffer[0] += '"';
      }
    }
    if (emptyTags.includes(tag) && children.length === 0) {
      buffer[0] += "/>";
      return;
    }
    buffer[0] += ">";
    childrenToStringToBuffer(children, buffer);
    buffer[0] += `</${tag}>`;
  }
};
var JSXFunctionNode = class extends JSXNode {
  toStringToBuffer(buffer) {
    const { children } = this;
    const props = { ...this.props };
    if (children.length) {
      props.children = children.length === 1 ? children[0] : children;
    }
    const res = this.tag.call(null, props);
    if (typeof res === "boolean" || res == null) {
      return;
    } else if (res instanceof Promise) {
      if (globalContexts.length === 0) {
        buffer.unshift("", res);
      } else {
        const currentContexts = globalContexts.map((c) => [c, c.values.at(-1)]);
        buffer.unshift("", res.then((childRes) => {
          if (childRes instanceof JSXNode) {
            childRes.localContexts = currentContexts;
          }
          return childRes;
        }));
      }
    } else if (res instanceof JSXNode) {
      res.toStringToBuffer(buffer);
    } else if (typeof res === "number" || res.isEscaped) {
      buffer[0] += res;
      if (res.callbacks) {
        buffer.callbacks ||= [];
        buffer.callbacks.push(...res.callbacks);
      }
    } else {
      escapeToBuffer(res, buffer);
    }
  }
};
var JSXFragmentNode = class extends JSXNode {
  toStringToBuffer(buffer) {
    childrenToStringToBuffer(this.children, buffer);
  }
};
var initDomRenderer = false;
var jsxFn = (tag, props, children) => {
  if (!initDomRenderer) {
    for (const k in domRenderers) {
      exports_components[k][DOM_RENDERER] = domRenderers[k];
    }
    initDomRenderer = true;
  }
  if (typeof tag === "function") {
    return new JSXFunctionNode(tag, props, children);
  } else if (exports_components[tag]) {
    return new JSXFunctionNode(exports_components[tag], props, children);
  } else if (tag === "svg" || tag === "head") {
    nameSpaceContext ||= createContext2("");
    return new JSXNode(tag, props, [
      new JSXFunctionNode(nameSpaceContext, {
        value: tag
      }, children)
    ]);
  } else {
    return new JSXNode(tag, props, children);
  }
};

// node_modules/hono/dist/jsx/jsx-dev-runtime.js
function jsxDEV(tag, props, key) {
  let node;
  if (!props || !("children" in props)) {
    node = jsxFn(tag, props, []);
  } else {
    const children = props.children;
    node = Array.isArray(children) ? jsxFn(tag, props, children) : jsxFn(tag, props, [children]);
  }
  node.key = key;
  return node;
}

// src/pages/Homepage.tsx
function Homepage({ c }) {
  return /* @__PURE__ */ jsxDEV("div", {
    className: "min-h-screen bg-gradient-to-br from-neutral-950 via-neutral-900 to-green-950 flex items-center justify-center p-4",
    children: /* @__PURE__ */ jsxDEV("div", {
      className: "w-full max-w-md",
      children: [
        /* @__PURE__ */ jsxDEV("div", {
          className: "text-center mb-8",
          children: /* @__PURE__ */ jsxDEV("h1", {
            className: "text-5xl font-bold bg-gradient-to-r from-green-500 to-emerald-500 bg-clip-text text-transparent mb-2 font-[Orbitron]",
            children: "MASTER F TOOL"
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV("div", {
          className: "flex gap-3 mb-6",
          children: [
            /* @__PURE__ */ jsxDEV("a", {
              href: "/v1/auth/login",
              className: "flex-1",
              children: /* @__PURE__ */ jsxDEV("button", {
                type: "button",
                className: "w-full px-4 py-2 bg-gradient-to-r from-green-600 to-green-500 hover:from-green-700 hover:to-green-600 text-white font-bold rounded-md transition-all duration-200 font-[Orbitron]",
                children: "LOGIN"
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV("a", {
              href: "/v1/auth/register",
              className: "flex-1",
              children: /* @__PURE__ */ jsxDEV("button", {
                type: "button",
                className: "w-full px-4 py-2 bg-transparent hover:bg-neutral-800 text-white font-bold rounded-md border border-neutral-700 transition-all duration-200 font-[Orbitron]",
                children: "REGISTER"
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV("div", {
          className: "text-center mt-6",
          children: /* @__PURE__ */ jsxDEV("p", {
            className: "text-neutral-500 text-sm font-[Exo_2]",
            children: "Rise to the top of table football glory!"
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
}

// node_modules/hono/dist/jsx/dom/intrinsic-element/components.js
var exports_components2 = {};
__export(exports_components2, {
  title: () => title2,
  style: () => style2,
  script: () => script2,
  meta: () => meta2,
  link: () => link2,
  input: () => input2,
  form: () => form2,
  composeRef: () => composeRef,
  clearCache: () => clearCache,
  button: () => button2
});

// node_modules/hono/dist/jsx/dom/render.js
var HONO_PORTAL_ELEMENT = "_hp";
var eventAliasMap = {
  Change: "Input",
  DoubleClick: "DblClick"
};
var nameSpaceMap = {
  svg: "2000/svg",
  math: "1998/Math/MathML"
};
var buildDataStack = [];
var refCleanupMap = /* @__PURE__ */ new WeakMap;
var nameSpaceContext2 = undefined;
var getNameSpaceContext2 = () => nameSpaceContext2;
var isNodeString = (node) => ("t" in node);
var eventCache = {
  onClick: ["click", false]
};
var getEventSpec = (key) => {
  if (!key.startsWith("on")) {
    return;
  }
  if (eventCache[key]) {
    return eventCache[key];
  }
  const match2 = key.match(/^on([A-Z][a-zA-Z]+?(?:PointerCapture)?)(Capture)?$/);
  if (match2) {
    const [, eventName, capture] = match2;
    return eventCache[key] = [(eventAliasMap[eventName] || eventName).toLowerCase(), !!capture];
  }
  return;
};
var toAttributeName = (element, key) => nameSpaceContext2 && element instanceof SVGElement && /[A-Z]/.test(key) && ((key in element.style) || key.match(/^(?:o|pai|str|u|ve)/)) ? key.replace(/([A-Z])/g, "-$1").toLowerCase() : key;
var applyProps = (container, attributes, oldAttributes) => {
  attributes ||= {};
  for (let key in attributes) {
    const value = attributes[key];
    if (key !== "children" && (!oldAttributes || oldAttributes[key] !== value)) {
      key = normalizeIntrinsicElementKey(key);
      const eventSpec = getEventSpec(key);
      if (eventSpec) {
        if (oldAttributes?.[key] !== value) {
          if (oldAttributes) {
            container.removeEventListener(eventSpec[0], oldAttributes[key], eventSpec[1]);
          }
          if (value != null) {
            if (typeof value !== "function") {
              throw new Error(`Event handler for "${key}" is not a function`);
            }
            container.addEventListener(eventSpec[0], value, eventSpec[1]);
          }
        }
      } else if (key === "dangerouslySetInnerHTML" && value) {
        container.innerHTML = value.__html;
      } else if (key === "ref") {
        let cleanup;
        if (typeof value === "function") {
          cleanup = value(container) || (() => value(null));
        } else if (value && "current" in value) {
          value.current = container;
          cleanup = () => value.current = null;
        }
        refCleanupMap.set(container, cleanup);
      } else if (key === "style") {
        const style2 = container.style;
        if (typeof value === "string") {
          style2.cssText = value;
        } else {
          style2.cssText = "";
          if (value != null) {
            styleObjectForEach(value, style2.setProperty.bind(style2));
          }
        }
      } else {
        if (key === "value") {
          const nodeName = container.nodeName;
          if (nodeName === "INPUT" || nodeName === "TEXTAREA" || nodeName === "SELECT") {
            container.value = value === null || value === undefined || value === false ? null : value;
            if (nodeName === "TEXTAREA") {
              container.textContent = value;
              continue;
            } else if (nodeName === "SELECT") {
              if (container.selectedIndex === -1) {
                container.selectedIndex = 0;
              }
              continue;
            }
          }
        } else if (key === "checked" && container.nodeName === "INPUT" || key === "selected" && container.nodeName === "OPTION") {
          container[key] = value;
        }
        const k = toAttributeName(container, key);
        if (value === null || value === undefined || value === false) {
          container.removeAttribute(k);
        } else if (value === true) {
          container.setAttribute(k, "");
        } else if (typeof value === "string" || typeof value === "number") {
          container.setAttribute(k, value);
        } else {
          container.setAttribute(k, value.toString());
        }
      }
    }
  }
  if (oldAttributes) {
    for (let key in oldAttributes) {
      const value = oldAttributes[key];
      if (key !== "children" && !(key in attributes)) {
        key = normalizeIntrinsicElementKey(key);
        const eventSpec = getEventSpec(key);
        if (eventSpec) {
          container.removeEventListener(eventSpec[0], value, eventSpec[1]);
        } else if (key === "ref") {
          refCleanupMap.get(container)?.();
        } else {
          container.removeAttribute(toAttributeName(container, key));
        }
      }
    }
  }
};
var invokeTag = (context, node) => {
  node[DOM_STASH][0] = 0;
  buildDataStack.push([context, node]);
  const func = node.tag[DOM_RENDERER] || node.tag;
  const props = func.defaultProps ? {
    ...func.defaultProps,
    ...node.props
  } : node.props;
  try {
    return [func.call(null, props)];
  } finally {
    buildDataStack.pop();
  }
};
var getNextChildren = (node, container, nextChildren, childrenToRemove, callbacks) => {
  if (node.vR?.length) {
    childrenToRemove.push(...node.vR);
    delete node.vR;
  }
  if (typeof node.tag === "function") {
    node[DOM_STASH][1][STASH_EFFECT]?.forEach((data) => callbacks.push(data));
  }
  node.vC.forEach((child) => {
    if (isNodeString(child)) {
      nextChildren.push(child);
    } else {
      if (typeof child.tag === "function" || child.tag === "") {
        child.c = container;
        const currentNextChildrenIndex = nextChildren.length;
        getNextChildren(child, container, nextChildren, childrenToRemove, callbacks);
        if (child.s) {
          for (let i = currentNextChildrenIndex;i < nextChildren.length; i++) {
            nextChildren[i].s = true;
          }
          child.s = false;
        }
      } else {
        nextChildren.push(child);
        if (child.vR?.length) {
          childrenToRemove.push(...child.vR);
          delete child.vR;
        }
      }
    }
  });
};
var findInsertBefore = (node) => {
  for (;; node = node.tag === HONO_PORTAL_ELEMENT || !node.vC || !node.pP ? node.nN : node.vC[0]) {
    if (!node) {
      return null;
    }
    if (node.tag !== HONO_PORTAL_ELEMENT && node.e) {
      return node.e;
    }
  }
};
var removeNode = (node) => {
  if (!isNodeString(node)) {
    node[DOM_STASH]?.[1][STASH_EFFECT]?.forEach((data) => data[2]?.());
    refCleanupMap.get(node.e)?.();
    if (node.p === 2) {
      node.vC?.forEach((n) => n.p = 2);
    }
    node.vC?.forEach(removeNode);
  }
  if (!node.p) {
    node.e?.remove();
    delete node.e;
  }
  if (typeof node.tag === "function") {
    updateMap.delete(node);
    fallbackUpdateFnArrayMap.delete(node);
    delete node[DOM_STASH][3];
    node.a = true;
  }
};
var apply = (node, container, isNew) => {
  node.c = container;
  applyNodeObject(node, container, isNew);
};
var findChildNodeIndex = (childNodes, child) => {
  if (!child) {
    return;
  }
  for (let i = 0, len = childNodes.length;i < len; i++) {
    if (childNodes[i] === child) {
      return i;
    }
  }
  return;
};
var cancelBuild = Symbol();
var applyNodeObject = (node, container, isNew) => {
  const next = [];
  const remove = [];
  const callbacks = [];
  getNextChildren(node, container, next, remove, callbacks);
  remove.forEach(removeNode);
  const childNodes = isNew ? undefined : container.childNodes;
  let offset;
  let insertBeforeNode = null;
  if (isNew) {
    offset = -1;
  } else if (!childNodes.length) {
    offset = 0;
  } else {
    const offsetByNextNode = findChildNodeIndex(childNodes, findInsertBefore(node.nN));
    if (offsetByNextNode !== undefined) {
      insertBeforeNode = childNodes[offsetByNextNode];
      offset = offsetByNextNode;
    } else {
      offset = findChildNodeIndex(childNodes, next.find((n) => n.tag !== HONO_PORTAL_ELEMENT && n.e)?.e) ?? -1;
    }
    if (offset === -1) {
      isNew = true;
    }
  }
  for (let i = 0, len = next.length;i < len; i++, offset++) {
    const child = next[i];
    let el;
    if (child.s && child.e) {
      el = child.e;
      child.s = false;
    } else {
      const isNewLocal = isNew || !child.e;
      if (isNodeString(child)) {
        if (child.e && child.d) {
          child.e.textContent = child.t;
        }
        child.d = false;
        el = child.e ||= document.createTextNode(child.t);
      } else {
        el = child.e ||= child.n ? document.createElementNS(child.n, child.tag) : document.createElement(child.tag);
        applyProps(el, child.props, child.pP);
        applyNodeObject(child, el, isNewLocal);
      }
    }
    if (child.tag === HONO_PORTAL_ELEMENT) {
      offset--;
    } else if (isNew) {
      if (!el.parentNode) {
        container.appendChild(el);
      }
    } else if (childNodes[offset] !== el && childNodes[offset - 1] !== el) {
      if (childNodes[offset + 1] === el) {
        container.appendChild(childNodes[offset]);
      } else {
        container.insertBefore(el, insertBeforeNode || childNodes[offset] || null);
      }
    }
  }
  if (node.pP) {
    delete node.pP;
  }
  if (callbacks.length) {
    const useLayoutEffectCbs = [];
    const useEffectCbs = [];
    callbacks.forEach(([, useLayoutEffectCb, , useEffectCb, useInsertionEffectCb]) => {
      if (useLayoutEffectCb) {
        useLayoutEffectCbs.push(useLayoutEffectCb);
      }
      if (useEffectCb) {
        useEffectCbs.push(useEffectCb);
      }
      useInsertionEffectCb?.();
    });
    useLayoutEffectCbs.forEach((cb) => cb());
    if (useEffectCbs.length) {
      requestAnimationFrame(() => {
        useEffectCbs.forEach((cb) => cb());
      });
    }
  }
};
var isSameContext = (oldContexts, newContexts) => !!(oldContexts && oldContexts.length === newContexts.length && oldContexts.every((ctx, i) => ctx[1] === newContexts[i][1]));
var fallbackUpdateFnArrayMap = /* @__PURE__ */ new WeakMap;
var build = (context, node, children) => {
  const buildWithPreviousChildren = !children && node.pC;
  if (children) {
    node.pC ||= node.vC;
  }
  let foundErrorHandler;
  try {
    children ||= typeof node.tag == "function" ? invokeTag(context, node) : toArray(node.props.children);
    if (children[0]?.tag === "" && children[0][DOM_ERROR_HANDLER]) {
      foundErrorHandler = children[0][DOM_ERROR_HANDLER];
      context[5].push([context, foundErrorHandler, node]);
    }
    const oldVChildren = buildWithPreviousChildren ? [...node.pC] : node.vC ? [...node.vC] : undefined;
    const vChildren = [];
    let prevNode;
    for (let i = 0;i < children.length; i++) {
      if (Array.isArray(children[i])) {
        children.splice(i, 1, ...children[i].flat());
      }
      let child = buildNode(children[i]);
      if (child) {
        if (typeof child.tag === "function" && !child.tag[DOM_INTERNAL_TAG]) {
          if (globalContexts.length > 0) {
            child[DOM_STASH][2] = globalContexts.map((c) => [c, c.values.at(-1)]);
          }
          if (context[5]?.length) {
            child[DOM_STASH][3] = context[5].at(-1);
          }
        }
        let oldChild;
        if (oldVChildren && oldVChildren.length) {
          const i2 = oldVChildren.findIndex(isNodeString(child) ? (c) => isNodeString(c) : child.key !== undefined ? (c) => c.key === child.key && c.tag === child.tag : (c) => c.tag === child.tag);
          if (i2 !== -1) {
            oldChild = oldVChildren[i2];
            oldVChildren.splice(i2, 1);
          }
        }
        if (oldChild) {
          if (isNodeString(child)) {
            if (oldChild.t !== child.t) {
              oldChild.t = child.t;
              oldChild.d = true;
            }
            child = oldChild;
          } else {
            const pP = oldChild.pP = oldChild.props;
            oldChild.props = child.props;
            oldChild.f ||= child.f || node.f;
            if (typeof child.tag === "function") {
              const oldContexts = oldChild[DOM_STASH][2];
              oldChild[DOM_STASH][2] = child[DOM_STASH][2] || [];
              oldChild[DOM_STASH][3] = child[DOM_STASH][3];
              if (!oldChild.f && ((oldChild.o || oldChild) === child.o || oldChild.tag[DOM_MEMO]?.(pP, oldChild.props)) && isSameContext(oldContexts, oldChild[DOM_STASH][2])) {
                oldChild.s = true;
              }
            }
            child = oldChild;
          }
        } else if (!isNodeString(child) && nameSpaceContext2) {
          const ns = useContext(nameSpaceContext2);
          if (ns) {
            child.n = ns;
          }
        }
        if (!isNodeString(child) && !child.s) {
          build(context, child);
          delete child.f;
        }
        vChildren.push(child);
        if (prevNode && !prevNode.s && !child.s) {
          for (let p = prevNode;p && !isNodeString(p); p = p.vC?.at(-1)) {
            p.nN = child;
          }
        }
        prevNode = child;
      }
    }
    node.vR = buildWithPreviousChildren ? [...node.vC, ...oldVChildren || []] : oldVChildren || [];
    node.vC = vChildren;
    if (buildWithPreviousChildren) {
      delete node.pC;
    }
  } catch (e) {
    node.f = true;
    if (e === cancelBuild) {
      if (foundErrorHandler) {
        return;
      } else {
        throw e;
      }
    }
    const [errorHandlerContext, errorHandler2, errorHandlerNode] = node[DOM_STASH]?.[3] || [];
    if (errorHandler2) {
      const fallbackUpdateFn = () => update([0, false, context[2]], errorHandlerNode);
      const fallbackUpdateFnArray = fallbackUpdateFnArrayMap.get(errorHandlerNode) || [];
      fallbackUpdateFnArray.push(fallbackUpdateFn);
      fallbackUpdateFnArrayMap.set(errorHandlerNode, fallbackUpdateFnArray);
      const fallback = errorHandler2(e, () => {
        const fnArray = fallbackUpdateFnArrayMap.get(errorHandlerNode);
        if (fnArray) {
          const i = fnArray.indexOf(fallbackUpdateFn);
          if (i !== -1) {
            fnArray.splice(i, 1);
            return fallbackUpdateFn();
          }
        }
      });
      if (fallback) {
        if (context[0] === 1) {
          context[1] = true;
        } else {
          build(context, errorHandlerNode, [fallback]);
          if ((errorHandler2.length === 1 || context !== errorHandlerContext) && errorHandlerNode.c) {
            apply(errorHandlerNode, errorHandlerNode.c, false);
            return;
          }
        }
        throw cancelBuild;
      }
    }
    throw e;
  } finally {
    if (foundErrorHandler) {
      context[5].pop();
    }
  }
};
var buildNode = (node) => {
  if (node === undefined || node === null || typeof node === "boolean") {
    return;
  } else if (typeof node === "string" || typeof node === "number") {
    return { t: node.toString(), d: true };
  } else {
    if ("vR" in node) {
      node = {
        tag: node.tag,
        props: node.props,
        key: node.key,
        f: node.f,
        type: node.tag,
        ref: node.props.ref,
        o: node.o || node
      };
    }
    if (typeof node.tag === "function") {
      node[DOM_STASH] = [0, []];
    } else {
      const ns = nameSpaceMap[node.tag];
      if (ns) {
        nameSpaceContext2 ||= createContext("");
        node.props.children = [
          {
            tag: nameSpaceContext2,
            props: {
              value: node.n = `http://www.w3.org/${ns}`,
              children: node.props.children
            }
          }
        ];
      }
    }
    return node;
  }
};
var updateSync = (context, node) => {
  node[DOM_STASH][2]?.forEach(([c, v]) => {
    c.values.push(v);
  });
  try {
    build(context, node, undefined);
  } catch {
    return;
  }
  if (node.a) {
    delete node.a;
    return;
  }
  node[DOM_STASH][2]?.forEach(([c]) => {
    c.values.pop();
  });
  if (context[0] !== 1 || !context[1]) {
    apply(node, node.c, false);
  }
};
var updateMap = /* @__PURE__ */ new WeakMap;
var currentUpdateSets = [];
var update = async (context, node) => {
  context[5] ||= [];
  const existing = updateMap.get(node);
  if (existing) {
    existing[0](undefined);
  }
  let resolve;
  const promise = new Promise((r) => resolve = r);
  updateMap.set(node, [
    resolve,
    () => {
      if (context[2]) {
        context[2](context, node, (context2) => {
          updateSync(context2, node);
        }).then(() => resolve(node));
      } else {
        updateSync(context, node);
        resolve(node);
      }
    }
  ]);
  if (currentUpdateSets.length) {
    currentUpdateSets.at(-1).add(node);
  } else {
    await Promise.resolve();
    const latest = updateMap.get(node);
    if (latest) {
      updateMap.delete(node);
      latest[1]();
    }
  }
  return promise;
};
var createPortal = (children, container, key) => ({
  tag: HONO_PORTAL_ELEMENT,
  props: {
    children
  },
  key,
  e: container,
  p: 1
});

// node_modules/hono/dist/jsx/hooks/index.js
var STASH_SATE = 0;
var STASH_EFFECT = 1;
var STASH_CALLBACK = 2;
var STASH_MEMO = 3;
var resolvedPromiseValueMap = /* @__PURE__ */ new WeakMap;
var isDepsChanged = (prevDeps, deps) => !prevDeps || !deps || prevDeps.length !== deps.length || deps.some((dep, i) => dep !== prevDeps[i]);
var updateHook = undefined;
var pendingStack = [];
var useState = (initialState) => {
  const resolveInitialState = () => typeof initialState === "function" ? initialState() : initialState;
  const buildData = buildDataStack.at(-1);
  if (!buildData) {
    return [resolveInitialState(), () => {}];
  }
  const [, node] = buildData;
  const stateArray = node[DOM_STASH][1][STASH_SATE] ||= [];
  const hookIndex = node[DOM_STASH][0]++;
  return stateArray[hookIndex] ||= [
    resolveInitialState(),
    (newState) => {
      const localUpdateHook = updateHook;
      const stateData = stateArray[hookIndex];
      if (typeof newState === "function") {
        newState = newState(stateData[0]);
      }
      if (!Object.is(newState, stateData[0])) {
        stateData[0] = newState;
        if (pendingStack.length) {
          const [pendingType, pendingPromise] = pendingStack.at(-1);
          Promise.all([
            pendingType === 3 ? node : update([pendingType, false, localUpdateHook], node),
            pendingPromise
          ]).then(([node2]) => {
            if (!node2 || !(pendingType === 2 || pendingType === 3)) {
              return;
            }
            const lastVC = node2.vC;
            const addUpdateTask = () => {
              setTimeout(() => {
                if (lastVC !== node2.vC) {
                  return;
                }
                update([pendingType === 3 ? 1 : 0, false, localUpdateHook], node2);
              });
            };
            requestAnimationFrame(addUpdateTask);
          });
        } else {
          update([0, false, localUpdateHook], node);
        }
      }
    }
  ];
};
var useCallback = (callback, deps) => {
  const buildData = buildDataStack.at(-1);
  if (!buildData) {
    return callback;
  }
  const [, node] = buildData;
  const callbackArray = node[DOM_STASH][1][STASH_CALLBACK] ||= [];
  const hookIndex = node[DOM_STASH][0]++;
  const prevDeps = callbackArray[hookIndex];
  if (isDepsChanged(prevDeps?.[1], deps)) {
    callbackArray[hookIndex] = [callback, deps];
  } else {
    callback = callbackArray[hookIndex][0];
  }
  return callback;
};
var use = (promise) => {
  const cachedRes = resolvedPromiseValueMap.get(promise);
  if (cachedRes) {
    if (cachedRes.length === 2) {
      throw cachedRes[1];
    }
    return cachedRes[0];
  }
  promise.then((res) => resolvedPromiseValueMap.set(promise, [res]), (e) => resolvedPromiseValueMap.set(promise, [undefined, e]));
  throw promise;
};
var useMemo = (factory, deps) => {
  const buildData = buildDataStack.at(-1);
  if (!buildData) {
    return factory();
  }
  const [, node] = buildData;
  const memoArray = node[DOM_STASH][1][STASH_MEMO] ||= [];
  const hookIndex = node[DOM_STASH][0]++;
  const prevDeps = memoArray[hookIndex];
  if (isDepsChanged(prevDeps?.[1], deps)) {
    memoArray[hookIndex] = [factory(), deps];
  }
  return memoArray[hookIndex][0];
};

// node_modules/hono/dist/jsx/dom/hooks/index.js
var FormContext = createContext({
  pending: false,
  data: null,
  method: null,
  action: null
});
var actions = /* @__PURE__ */ new Set;
var registerAction = (action) => {
  actions.add(action);
  action.finally(() => actions.delete(action));
};

// node_modules/hono/dist/jsx/dom/intrinsic-element/components.js
var clearCache = () => {
  blockingPromiseMap = /* @__PURE__ */ Object.create(null);
  createdElements = /* @__PURE__ */ Object.create(null);
};
var composeRef = (ref, cb) => {
  return useMemo(() => (e) => {
    let refCleanup;
    if (ref) {
      if (typeof ref === "function") {
        refCleanup = ref(e) || (() => {
          ref(null);
        });
      } else if (ref && "current" in ref) {
        ref.current = e;
        refCleanup = () => {
          ref.current = null;
        };
      }
    }
    const cbCleanup = cb(e);
    return () => {
      cbCleanup?.();
      refCleanup?.();
    };
  }, [ref]);
};
var blockingPromiseMap = /* @__PURE__ */ Object.create(null);
var createdElements = /* @__PURE__ */ Object.create(null);
var documentMetadataTag2 = (tag, props, preserveNodeType, supportSort, supportBlocking) => {
  if (props?.itemProp) {
    return {
      tag,
      props,
      type: tag,
      ref: props.ref
    };
  }
  const head = document.head;
  let { onLoad, onError, precedence, blocking, ...restProps } = props;
  let element = null;
  let created = false;
  const deDupeKeys = deDupeKeyMap[tag];
  let existingElements = undefined;
  if (deDupeKeys.length > 0) {
    const tags = head.querySelectorAll(tag);
    LOOP:
      for (const e of tags) {
        for (const key of deDupeKeyMap[tag]) {
          if (e.getAttribute(key) === props[key]) {
            element = e;
            break LOOP;
          }
        }
      }
    if (!element) {
      const cacheKey = deDupeKeys.reduce((acc, key) => props[key] === undefined ? acc : `${acc}-${key}-${props[key]}`, tag);
      created = !createdElements[cacheKey];
      element = createdElements[cacheKey] ||= (() => {
        const e = document.createElement(tag);
        for (const key of deDupeKeys) {
          if (props[key] !== undefined) {
            e.setAttribute(key, props[key]);
          }
          if (props.rel) {
            e.setAttribute("rel", props.rel);
          }
        }
        return e;
      })();
    }
  } else {
    existingElements = head.querySelectorAll(tag);
  }
  precedence = supportSort ? precedence ?? "" : undefined;
  if (supportSort) {
    restProps[dataPrecedenceAttr] = precedence;
  }
  const insert = useCallback((e) => {
    if (deDupeKeys.length > 0) {
      let found = false;
      for (const existingElement of head.querySelectorAll(tag)) {
        if (found && existingElement.getAttribute(dataPrecedenceAttr) !== precedence) {
          head.insertBefore(e, existingElement);
          return;
        }
        if (existingElement.getAttribute(dataPrecedenceAttr) === precedence) {
          found = true;
        }
      }
      head.appendChild(e);
    } else if (existingElements) {
      let found = false;
      for (const existingElement of existingElements) {
        if (existingElement === e) {
          found = true;
          break;
        }
      }
      if (!found) {
        head.insertBefore(e, head.contains(existingElements[0]) ? existingElements[0] : head.querySelector(tag));
      }
      existingElements = undefined;
    }
  }, [precedence]);
  const ref = composeRef(props.ref, (e) => {
    const key = deDupeKeys[0];
    if (preserveNodeType === 2) {
      e.innerHTML = "";
    }
    if (created || existingElements) {
      insert(e);
    }
    if (!onError && !onLoad) {
      return;
    }
    let promise = blockingPromiseMap[e.getAttribute(key)] ||= new Promise((resolve, reject) => {
      e.addEventListener("load", resolve);
      e.addEventListener("error", reject);
    });
    if (onLoad) {
      promise = promise.then(onLoad);
    }
    if (onError) {
      promise = promise.catch(onError);
    }
    promise.catch(() => {});
  });
  if (supportBlocking && blocking === "render") {
    const key = deDupeKeyMap[tag][0];
    if (props[key]) {
      const value = props[key];
      const promise = blockingPromiseMap[value] ||= new Promise((resolve, reject) => {
        insert(element);
        element.addEventListener("load", resolve);
        element.addEventListener("error", reject);
      });
      use(promise);
    }
  }
  const jsxNode = {
    tag,
    type: tag,
    props: {
      ...restProps,
      ref
    },
    ref
  };
  jsxNode.p = preserveNodeType;
  if (element) {
    jsxNode.e = element;
  }
  return createPortal(jsxNode, head);
};
var title2 = (props) => {
  const nameSpaceContext3 = getNameSpaceContext2();
  const ns = nameSpaceContext3 && useContext(nameSpaceContext3);
  if (ns?.endsWith("svg")) {
    return {
      tag: "title",
      props,
      type: "title",
      ref: props.ref
    };
  }
  return documentMetadataTag2("title", props, undefined, false, false);
};
var script2 = (props) => {
  if (!props || ["src", "async"].some((k) => !props[k])) {
    return {
      tag: "script",
      props,
      type: "script",
      ref: props.ref
    };
  }
  return documentMetadataTag2("script", props, 1, false, true);
};
var style2 = (props) => {
  if (!props || !["href", "precedence"].every((k) => (k in props))) {
    return {
      tag: "style",
      props,
      type: "style",
      ref: props.ref
    };
  }
  props["data-href"] = props.href;
  delete props.href;
  return documentMetadataTag2("style", props, 2, true, true);
};
var link2 = (props) => {
  if (!props || ["onLoad", "onError"].some((k) => (k in props)) || props.rel === "stylesheet" && (!("precedence" in props) || ("disabled" in props))) {
    return {
      tag: "link",
      props,
      type: "link",
      ref: props.ref
    };
  }
  return documentMetadataTag2("link", props, 1, "precedence" in props, true);
};
var meta2 = (props) => {
  return documentMetadataTag2("meta", props, undefined, false, false);
};
var customEventFormAction = Symbol();
var form2 = (props) => {
  const { action, ...restProps } = props;
  if (typeof action !== "function") {
    restProps.action = action;
  }
  const [state, setState] = useState([null, false]);
  const onSubmit = useCallback(async (ev) => {
    const currentAction = ev.isTrusted ? action : ev.detail[customEventFormAction];
    if (typeof currentAction !== "function") {
      return;
    }
    ev.preventDefault();
    const formData = new FormData(ev.target);
    setState([formData, true]);
    const actionRes = currentAction(formData);
    if (actionRes instanceof Promise) {
      registerAction(actionRes);
      await actionRes;
    }
    setState([null, true]);
  }, []);
  const ref = composeRef(props.ref, (el) => {
    el.addEventListener("submit", onSubmit);
    return () => {
      el.removeEventListener("submit", onSubmit);
    };
  });
  const [data, isDirty] = state;
  state[1] = false;
  return {
    tag: FormContext,
    props: {
      value: {
        pending: data !== null,
        data,
        method: data ? "post" : null,
        action: data ? action : null
      },
      children: {
        tag: "form",
        props: {
          ...restProps,
          ref
        },
        type: "form",
        ref
      }
    },
    f: isDirty
  };
};
var formActionableElement2 = (tag, {
  formAction,
  ...props
}) => {
  if (typeof formAction === "function") {
    const onClick = useCallback((ev) => {
      ev.preventDefault();
      ev.currentTarget.form.dispatchEvent(new CustomEvent("submit", { detail: { [customEventFormAction]: formAction } }));
    }, []);
    props.ref = composeRef(props.ref, (el) => {
      el.addEventListener("click", onClick);
      return () => {
        el.removeEventListener("click", onClick);
      };
    });
  }
  return {
    tag,
    props,
    type: tag,
    ref: props.ref
  };
};
var input2 = (props) => formActionableElement2("input", props);
var button2 = (props) => formActionableElement2("button", props);
Object.assign(domRenderers, {
  title: title2,
  script: script2,
  style: style2,
  link: link2,
  meta: meta2,
  form: form2,
  input: input2,
  button: button2
});

// node_modules/hono/dist/jsx/dom/jsx-dev-runtime.js
var jsxDEV2 = (tag, props, key) => {
  if (typeof tag === "string" && exports_components2[tag]) {
    tag = exports_components2[tag];
  }
  return {
    tag,
    type: tag,
    props,
    key,
    ref: props.ref
  };
};
var Fragment2 = (props) => jsxDEV2("", props, undefined);

// node_modules/hono/dist/jsx/dom/components.js
var ErrorBoundary = ({ children, fallback, fallbackRender, onError }) => {
  const res = Fragment2({ children });
  res[DOM_ERROR_HANDLER] = (err) => {
    if (err instanceof Promise) {
      throw err;
    }
    onError?.(err);
    return fallbackRender?.(err) || fallback;
  };
  return res;
};
var Suspense = ({
  children,
  fallback
}) => {
  const res = Fragment2({ children });
  res[DOM_ERROR_HANDLER] = (err, retry) => {
    if (!(err instanceof Promise)) {
      throw err;
    }
    err.finally(retry);
    return fallback;
  };
  return res;
};

// node_modules/hono/dist/jsx/streaming.js
var StreamingContext = createContext2(null);
var suspenseCounter = 0;
var Suspense2 = async ({
  children,
  fallback
}) => {
  if (!children) {
    return fallback.toString();
  }
  if (!Array.isArray(children)) {
    children = [children];
  }
  const nonce = useContext(StreamingContext)?.scriptNonce;
  let resArray = [];
  const stackNode = { [DOM_STASH]: [0, []] };
  const popNodeStack = (value) => {
    buildDataStack.pop();
    return value;
  };
  try {
    stackNode[DOM_STASH][0] = 0;
    buildDataStack.push([[], stackNode]);
    resArray = children.map((c) => c == null || typeof c === "boolean" ? "" : c.toString());
  } catch (e) {
    if (e instanceof Promise) {
      resArray = [
        e.then(() => {
          stackNode[DOM_STASH][0] = 0;
          buildDataStack.push([[], stackNode]);
          return childrenToString(children).then(popNodeStack);
        })
      ];
    } else {
      throw e;
    }
  } finally {
    popNodeStack();
  }
  if (resArray.some((res) => res instanceof Promise)) {
    const index = suspenseCounter++;
    const fallbackStr = await fallback.toString();
    return raw(`<template id="H:${index}"></template>${fallbackStr}<!--/$-->`, [
      ...fallbackStr.callbacks || [],
      ({ phase, buffer, context }) => {
        if (phase === HtmlEscapedCallbackPhase.BeforeStream) {
          return;
        }
        return Promise.all(resArray).then(async (htmlArray) => {
          htmlArray = htmlArray.flat();
          const content = htmlArray.join("");
          if (buffer) {
            buffer[0] = buffer[0].replace(new RegExp(`<template id="H:${index}"></template>.*?<!--/\\$-->`), content);
          }
          let html = buffer ? "" : `<template data-hono-target="H:${index}">${content}</template><script${nonce ? ` nonce="${nonce}"` : ""}>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${index}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
</script>`;
          const callbacks = htmlArray.map((html2) => html2.callbacks || []).flat();
          if (!callbacks.length) {
            return html;
          }
          if (phase === HtmlEscapedCallbackPhase.Stream) {
            html = await resolveCallback(html, HtmlEscapedCallbackPhase.BeforeStream, true, context);
          }
          return raw(html, callbacks);
        });
      }
    ]);
  } else {
    return raw(resArray.join(""));
  }
};
Suspense2[DOM_RENDERER] = Suspense;
var textEncoder = new TextEncoder;

// node_modules/hono/dist/jsx/components.js
var errorBoundaryCounter = 0;
var childrenToString = async (children) => {
  try {
    return children.flat().map((c) => c == null || typeof c === "boolean" ? "" : c.toString());
  } catch (e) {
    if (e instanceof Promise) {
      await e;
      return childrenToString(children);
    } else {
      throw e;
    }
  }
};
var ErrorBoundary2 = async ({ children, fallback, fallbackRender, onError }) => {
  if (!children) {
    return raw("");
  }
  if (!Array.isArray(children)) {
    children = [children];
  }
  const nonce = useContext(StreamingContext)?.scriptNonce;
  let fallbackStr;
  const fallbackRes = (error) => {
    onError?.(error);
    return (fallbackStr || fallbackRender?.(error) || "").toString();
  };
  let resArray = [];
  try {
    resArray = children.map((c) => c == null || typeof c === "boolean" ? "" : c.toString());
  } catch (e) {
    fallbackStr = await fallback?.toString();
    if (e instanceof Promise) {
      resArray = [
        e.then(() => childrenToString(children)).catch((e2) => fallbackRes(e2))
      ];
    } else {
      resArray = [fallbackRes(e)];
    }
  }
  if (resArray.some((res) => res instanceof Promise)) {
    fallbackStr ||= await fallback?.toString();
    const index = errorBoundaryCounter++;
    const replaceRe = RegExp(`(<template id="E:${index}"></template>.*?)(.*?)(<!--E:${index}-->)`);
    const caught = false;
    const catchCallback = ({ error: error2, buffer }) => {
      if (caught) {
        return "";
      }
      const fallbackResString = fallbackRes(error2);
      if (buffer) {
        buffer[0] = buffer[0].replace(replaceRe, fallbackResString);
      }
      return buffer ? "" : `<template data-hono-target="E:${index}">${fallbackResString}</template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('E:${index}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='E:${index}')
d.replaceWith(c.content)
})(document)
</script>`;
    };
    let error;
    const promiseAll = Promise.all(resArray).catch((e) => error = e);
    return raw(`<template id="E:${index}"></template><!--E:${index}-->`, [
      ({ phase, buffer, context }) => {
        if (phase === HtmlEscapedCallbackPhase.BeforeStream) {
          return;
        }
        return promiseAll.then(async (htmlArray) => {
          if (error) {
            throw error;
          }
          htmlArray = htmlArray.flat();
          const content = htmlArray.join("");
          let html = buffer ? "" : `<template data-hono-target="E:${index}">${content}</template><script${nonce ? ` nonce="${nonce}"` : ""}>
((d,c) => {
c=d.currentScript.previousSibling
d=d.getElementById('E:${index}')
if(!d)return
d.parentElement.insertBefore(c.content,d.nextSibling)
})(document)
</script>`;
          if (htmlArray.every((html2) => !html2.callbacks?.length)) {
            if (buffer) {
              buffer[0] = buffer[0].replace(replaceRe, content);
            }
            return html;
          }
          if (buffer) {
            buffer[0] = buffer[0].replace(replaceRe, (_all, pre, _, post) => `${pre}${content}${post}`);
          }
          const callbacks = htmlArray.map((html2) => html2.callbacks || []).flat();
          if (phase === HtmlEscapedCallbackPhase.Stream) {
            html = await resolveCallback(html, HtmlEscapedCallbackPhase.BeforeStream, true, context);
          }
          let resolvedCount = 0;
          const promises = callbacks.map((c) => (...args) => c(...args)?.then((content2) => {
            resolvedCount++;
            if (buffer) {
              if (resolvedCount === callbacks.length) {
                buffer[0] = buffer[0].replace(replaceRe, (_all, _pre, content3) => content3);
              }
              buffer[0] += content2;
              return raw("", content2.callbacks);
            }
            return raw(content2 + (resolvedCount !== callbacks.length ? "" : `<script>
((d,c,n) => {
d=d.getElementById('E:${index}')
if(!d)return
n=d.nextSibling
while(n.nodeType!=8||n.nodeValue!='E:${index}'){n=n.nextSibling}
n.remove()
d.remove()
})(document)
</script>`), content2.callbacks);
          }).catch((error2) => catchCallback({ error: error2, buffer })));
          return raw(html, promises);
        }).catch((error2) => catchCallback({ error: error2, buffer }));
      }
    ]);
  } else {
    return raw(resArray.join(""));
  }
};
ErrorBoundary2[DOM_RENDERER] = ErrorBoundary;

// src/layouts/main.tsx
var GameContext = createContext2(null);
function GameContextProvider({ children }) {
  return /* @__PURE__ */ jsxDEV(GameContext.Provider, {
    value: null,
    children
  }, undefined, false, undefined, this);
}
function MainLayout({ children, c }) {
  return /* @__PURE__ */ jsxDEV("html", {
    children: [
      /* @__PURE__ */ jsxDEV("head", {
        children: [
          /* @__PURE__ */ jsxDEV("title", {
            children: "Master F Tool"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("meta", {
            name: "theme-color",
            content: "#0a0a0a"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("meta", {
            name: "msapplication-navbutton-color",
            content: "#0a0a0a"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("meta", {
            name: "apple-mobile-web-app-status-bar-style",
            content: "black-translucent"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("meta", {
            charset: "utf-8"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("meta", {
            name: "viewport",
            content: "width=device-width, initial-scale=1"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("script", {
            src: "https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("script", {
            src: "https://cdn.jsdelivr.net/npm/htmx.org@2.0.8/dist/htmx.min.js",
            integrity: "sha384-/TgkGk7p307TH7EXJDuUlgG3Ce1UVolAOFopFekQkkXihi5u/6OCvVKyz1W+idaz",
            crossorigin: "anonymous"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("link", {
            href: "https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;500;600;700&display=swap",
            rel: "stylesheet"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("link", {
            rel: "stylesheet",
            href: "/static/style.css"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV("body", {
        class: "m-0 p-0 min-h-screen bg-neutral-950",
        children: /* @__PURE__ */ jsxDEV(GameContextProvider, {
          children
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/v1/profile.ts
var sdk = require_dist();
var endpoint = process.env.APPWRITE_ENDPOINT || "https://fra.cloud.appwrite.io/v1";
var projectId = process.env.APPWRITE_PROJECT;
var apiKey = process.env.APPWRITE_KEY;
var databaseId = process.env.APPWRITE_DATABASE_ID;
var collectionId = "players-profile";
async function createPlayerProfile(userId, username) {
  if (!projectId || !apiKey) {
    throw new Error("Appwrite credentials not configured");
  }
  const client = new sdk.Client().setEndpoint(endpoint).setProject(projectId).setKey(apiKey);
  const databases = new sdk.Databases(client);
  try {
    const profile = await databases.createDocument(databaseId, collectionId, username, {
      userId,
      username,
      wins: 0,
      loses: 0,
      ultimate_wins: 0,
      ultimate_loses: 0,
      xp: 0,
      elo: 500
    });
    console.log("Player profile created:", profile.$id);
    return profile;
  } catch (err) {
    console.error("Profile creation error:", err);
    throw new Error(err?.message || "Failed to create player profile");
  }
}
async function getPlayerProfile(userId) {
  if (!projectId || !apiKey) {
    throw new Error("Appwrite credentials not configured");
  }
  const client = new sdk.Client().setEndpoint(endpoint).setProject(projectId).setKey(apiKey);
  const databases = new sdk.Databases(client);
  try {
    const profile = await databases.getDocument(databaseId, collectionId, userId);
    return profile;
  } catch (err) {
    console.error("Profile fetch error:", err);
    return null;
  }
}
async function updatePlayerStats(userId, updates) {
  if (!projectId || !apiKey) {
    throw new Error("Appwrite credentials not configured");
  }
  const client = new sdk.Client().setEndpoint(endpoint).setProject(projectId).setKey(apiKey);
  const databases = new sdk.Databases(client);
  try {
    const profile = await databases.updateDocument(databaseId, collectionId, userId, updates);
    return profile;
  } catch (err) {
    console.error("Profile update error:", err);
    throw new Error(err?.message || "Failed to update player profile");
  }
}
async function getLeaderboard(limit = 50) {
  if (!projectId || !apiKey) {
    throw new Error("Appwrite credentials not configured");
  }
  const client = new sdk.Client().setEndpoint(endpoint).setProject(projectId).setKey(apiKey);
  const databases = new sdk.Databases(client);
  try {
    const result = await databases.listDocuments(databaseId, collectionId, [
      sdk.Query.orderDesc("elo"),
      sdk.Query.limit(limit)
    ]);
    return result.documents || [];
  } catch (err) {
    console.error("Leaderboard fetch error:", err);
    throw new Error(err?.message || "Failed to fetch leaderboard");
  }
}

// src/v1/auth.tsx
var sdk2 = require_dist();
var endpoint2 = process.env.APPWRITE_ENDPOINT || "https://fra.cloud.appwrite.io/v1";
var projectId2 = process.env.APPWRITE_PROJECT;
var apiKey2 = process.env.APPWRITE_KEY;
if (!projectId2 || !apiKey2) {
  console.warn("\u26A0\uFE0F Missing APPWRITE_PROJECT or APPWRITE_KEY env vars");
}
async function registerUser(username, password) {
  if (!projectId2 || !apiKey2) {
    throw new Error("Appwrite credentials not configured");
  }
  const client = new sdk2.Client().setEndpoint(endpoint2).setProject(projectId2).setKey(apiKey2);
  const users = new sdk2.Users(client);
  const email = `${username}@local.example`;
  try {
    const result = await users.create("unique()", email, null, password, username);
    console.log("User created:", result.$id);
    await createPlayerProfile(result.$id, username);
    return result;
  } catch (err) {
    console.error("Appwrite create error:", err);
    throw new Error(err?.message || "Failed to create user");
  }
}
async function loginUser(username, password) {
  if (!projectId2 || !apiKey2) {
    throw new Error("Appwrite credentials not configured");
  }
  const client = new sdk2.Client().setEndpoint(endpoint2).setProject(projectId2).setKey(apiKey2);
  const account = new sdk2.Account(client);
  const email = `${username}@local.example`;
  try {
    const session = await account.createEmailPasswordSession(email, password);
    console.log("Session created:", session.$id);
    return session;
  } catch (err) {
    console.error("Appwrite login error:", err);
    throw new Error("Invalid username or password");
  }
}

// src/v1/login.tsx
function LoginPage({ c }) {
  return /* @__PURE__ */ jsxDEV("div", {
    className: "min-h-screen bg-gradient-to-br from-neutral-950 via-neutral-900 to-green-950 flex items-center justify-center p-4",
    children: /* @__PURE__ */ jsxDEV("div", {
      className: "w-full max-w-md",
      children: [
        /* @__PURE__ */ jsxDEV("div", {
          className: "text-center mb-8",
          children: /* @__PURE__ */ jsxDEV("h1", {
            className: "text-4xl font-bold bg-gradient-to-r from-green-500 to-emerald-500 bg-clip-text text-transparent mb-2 font-[Orbitron]",
            children: "LOGIN"
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV("div", {
          className: "bg-neutral-900/50 backdrop-blur-sm rounded-lg border border-neutral-800 p-6 shadow-2xl",
          children: [
            /* @__PURE__ */ jsxDEV("form", {
              action: "/v1/auth/login",
              method: "post",
              className: "space-y-6",
              children: [
                /* @__PURE__ */ jsxDEV("div", {
                  className: "space-y-2",
                  children: [
                    /* @__PURE__ */ jsxDEV("label", {
                      htmlFor: "username",
                      className: "block text-sm font-medium text-neutral-200 font-[Exo_2]",
                      children: "Username"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV("input", {
                      autoFocus: true,
                      type: "text",
                      id: "username",
                      name: "username",
                      required: true,
                      placeholder: "Enter your username",
                      className: "w-full px-3 py-2 bg-neutral-800 border border-neutral-700 rounded-md text-white placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-200 font-[Exo_2]"
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  className: "space-y-2",
                  children: [
                    /* @__PURE__ */ jsxDEV("label", {
                      htmlFor: "password",
                      className: "block text-sm font-medium text-neutral-200 font-[Exo_2]",
                      children: "Password"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV("input", {
                      type: "password",
                      id: "password",
                      name: "password",
                      required: true,
                      placeholder: "Enter your password",
                      className: "w-full px-3 py-2 bg-neutral-800 border border-neutral-700 rounded-md text-white placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-200 font-[Exo_2]"
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsxDEV("button", {
                  type: "submit",
                  className: "w-full bg-gradient-to-r from-green-600 to-green-500 hover:from-green-700 hover:to-green-600 text-white font-bold py-3 px-4 rounded-md transition-all duration-200 transform hover:scale-[1.02] active:scale-[0.98] shadow-lg hover:shadow-green-500/25 font-[Orbitron] text-lg",
                  children: "LOGIN"
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV("div", {
              className: "mt-4 text-center",
              children: /* @__PURE__ */ jsxDEV("a", {
                href: "/",
                className: "text-sm text-neutral-400 hover:text-neutral-200",
                children: "Back to home"
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
}

// src/v1/register.tsx
function RegisterPage({ c }) {
  return /* @__PURE__ */ jsxDEV("div", {
    className: "min-h-screen bg-gradient-to-br from-neutral-950 via-neutral-900 to-green-950 flex items-center justify-center p-4",
    children: [
      /* @__PURE__ */ jsxDEV("div", {
        className: "w-full max-w-md",
        children: [
          /* @__PURE__ */ jsxDEV("div", {
            className: "text-center mb-8",
            children: /* @__PURE__ */ jsxDEV("h1", {
              className: "text-4xl font-bold bg-gradient-to-r from-green-500 to-emerald-500 bg-clip-text text-transparent mb-2 font-[Orbitron]",
              children: "REGISTER"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("div", {
            className: "bg-neutral-900/50 backdrop-blur-sm rounded-lg border border-neutral-800 p-6 shadow-2xl",
            children: [
              /* @__PURE__ */ jsxDEV("form", {
                id: "registerForm",
                action: "/v1/auth/register",
                method: "post",
                className: "space-y-6",
                children: [
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "space-y-2",
                    children: [
                      /* @__PURE__ */ jsxDEV("label", {
                        htmlFor: "username",
                        className: "block text-sm font-medium text-neutral-200 font-[Exo_2]",
                        children: "Username"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV("input", {
                        autoFocus: true,
                        type: "text",
                        id: "username",
                        name: "username",
                        required: true,
                        placeholder: "Choose a username",
                        className: "w-full px-3 py-2 bg-neutral-800 border border-neutral-700 rounded-md text-white placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-200 font-[Exo_2]"
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "space-y-2",
                    children: [
                      /* @__PURE__ */ jsxDEV("label", {
                        htmlFor: "password",
                        className: "block text-sm font-medium text-neutral-200 font-[Exo_2]",
                        children: "Password"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV("input", {
                        type: "password",
                        id: "password",
                        name: "password",
                        required: true,
                        placeholder: "Enter password",
                        className: "w-full px-3 py-2 bg-neutral-800 border border-neutral-700 rounded-md text-white placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-200 font-[Exo_2]"
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "space-y-2",
                    children: [
                      /* @__PURE__ */ jsxDEV("label", {
                        htmlFor: "confirmPassword",
                        className: "block text-sm font-medium text-neutral-200 font-[Exo_2]",
                        children: "Confirm Password"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV("input", {
                        type: "password",
                        id: "confirmPassword",
                        name: "confirmPassword",
                        required: true,
                        placeholder: "Repeat password",
                        className: "w-full px-3 py-2 bg-neutral-800 border border-neutral-700 rounded-md text-white placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-200 font-[Exo_2]"
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV("div", {
                    id: "regError",
                    className: "text-red-400 text-sm",
                    "aria-live": "polite"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV("button", {
                    type: "submit",
                    className: "w-full bg-gradient-to-r from-green-600 to-green-500 hover:from-green-700 hover:to-green-600 text-white font-bold py-3 px-4 rounded-md transition-all duration-200 transform hover:scale-[1.02] active:scale-[0.98] shadow-lg hover:shadow-green-500/25 font-[Orbitron] text-lg",
                    children: "REGISTER"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV("div", {
                className: "mt-4 text-center",
                children: /* @__PURE__ */ jsxDEV("a", {
                  href: "/",
                  className: "text-sm text-neutral-400 hover:text-neutral-200",
                  children: "Back to home"
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV("script", {
        dangerouslySetInnerHTML: {
          __html: `
            (function(){
              var form = document.getElementById('registerForm');
              var err = document.getElementById('regError');
              form && form.addEventListener('submit', function(e){
                err.textContent = '';
                var p = document.getElementById('password').value;
                var cp = document.getElementById('confirmPassword').value;
                if(!p || !cp || p !== cp){
                  e.preventDefault();
                  err.textContent = 'Passwords must match.';
                }
              });
            })();
          `
        }
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/v1/lobby.tsx
var levelsXp = [0, 15, 45, 95, 170, 270, 300, 480, 600, 1000];
function computeLevel(xp) {
  let level = 1;
  let currentLevelXp = 0;
  let nextLevelXp = levelsXp[1] || 100;
  for (let i3 = 0;i3 < levelsXp.length; i3++) {
    if (xp >= levelsXp[i3]) {
      level = i3 + 1;
      currentLevelXp = levelsXp[i3];
      nextLevelXp = levelsXp[i3 + 1] || levelsXp[levelsXp.length - 1];
    } else {
      break;
    }
  }
  const xpInCurrentLevel = xp - currentLevelXp;
  const xpNeededForNext = nextLevelXp - currentLevelXp;
  const progress = Math.round(xpInCurrentLevel / xpNeededForNext * 100);
  const missing = Math.max(0, nextLevelXp - xp);
  return { level, currentLevelXp, nextLevelXp, xpInCurrentLevel, xpNeededForNext, missing, progress };
}
function getLevelBadgeColor(level) {
  if (level <= 2)
    return { bg: "bg-yellow-600", text: "text-yellow-100" };
  if (level <= 4)
    return { bg: "bg-gray-500", text: "text-gray-100" };
  if (level <= 6)
    return { bg: "bg-amber-500", text: "text-amber-100" };
  if (level <= 8)
    return { bg: "bg-sky-500", text: "text-sky-100" };
  return { bg: "bg-indigo-600", text: "text-indigo-100" };
}
function eloRank(elo) {
  const tiers = [
    { name: "Bronze", min: 0, max: 999, color: "from-yellow-900 to-yellow-500", colorKey: "text-yellow-500" },
    { name: "Silver", min: 1000, max: 1999, color: "from-gray-900 to-gray-500", colorKey: "text-gray-500" },
    { name: "Gold", min: 2000, max: 2999, color: "from-amber-900 to-amber-500", colorKey: "text-amber-500" },
    { name: "Platinum", min: 3000, max: 3999, color: "from-sky-900 to-sky-500", colorKey: "text-sky-500" },
    { name: "Diamond", min: 4000, max: 4999, color: "from-indigo-900 to-indigo-500", colorKey: "text-indigo-500" },
    { name: "Master", min: 5000, max: 99999, color: "from-red-900 to-red-500", colorKey: "text-red-500" }
  ];
  const tier = tiers.find((t2) => elo >= t2.min && elo <= t2.max) ?? tiers[0];
  const span = tier.max - tier.min + 1;
  const progress = Math.round((elo - tier.min) / span * 100);
  const tierIndex = tiers.indexOf(tier);
  const prevTier = tierIndex > 0 ? tiers[tierIndex - 1] : null;
  const nextTier = tierIndex < tiers.length - 1 ? tiers[tierIndex + 1] : null;
  return {
    name: tier.name,
    progress,
    color: tier.color,
    colorKey: tier.colorKey,
    min: tier.min,
    max: tier.max,
    prevTierName: prevTier?.name,
    nextTierName: nextTier?.name
  };
}
function LobbyPage({ c, playerProfile }) {
  const playerData = playerProfile ? {
    username: playerProfile.username,
    elo: playerProfile.elo,
    xp: playerProfile.xp,
    wins: playerProfile.wins,
    loses: playerProfile.loses,
    ultimate_wins: playerProfile.ultimate_wins,
    ultimate_loses: playerProfile.ultimate_loses
  } : {
    username: getCookie(c, "user") ?? "Player",
    elo: 500,
    xp: 0,
    wins: 0,
    loses: 0,
    ultimate_wins: 0,
    ultimate_loses: 0
  };
  const lvl = computeLevel(playerData.xp);
  const rank = eloRank(playerData.elo);
  const badgeColor = getLevelBadgeColor(lvl.level);
  const winRate = playerData.wins + playerData.loses > 0 ? Math.round(playerData.wins / (playerData.wins + playerData.loses) * 100) : 0;
  return /* @__PURE__ */ jsxDEV("div", {
    className: "min-h-screen bg-gradient-to-br from-neutral-950 via-neutral-900 to-green-950 p-4",
    children: [
      /* @__PURE__ */ jsxDEV("div", {
        className: "grid grid-cols-1 lg:grid-cols-4 gap-4 h-screen",
        children: [
          /* @__PURE__ */ jsxDEV("div", {
            className: "lg:col-span-1 bg-neutral-900/50 rounded-lg border border-neutral-800 p-6 flex flex-col justify-between",
            children: /* @__PURE__ */ jsxDEV("div", {
              children: [
                /* @__PURE__ */ jsxDEV("h2", {
                  className: "text-2xl font-bold text-white font-[Orbitron] mb-6",
                  children: playerData.username
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  className: "w-11/12 mb-5 mt-5 mx-auto h-px bg-white/35 my-3 rounded"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  className: "mb-6",
                  children: [
                    /* @__PURE__ */ jsxDEV("div", {
                      className: `${badgeColor.bg} ${badgeColor.text} px-4 py-2 rounded-md font-bold text-center text-2xl mb-3`,
                      children: [
                        "Level ",
                        lvl.level
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "relative group",
                      children: [
                        /* @__PURE__ */ jsxDEV("div", {
                          className: "flex items-center gap-2 mb-2",
                          children: [
                            /* @__PURE__ */ jsxDEV("p", {
                              className: "text-sm text-neutral-300 cursor-help",
                              children: [
                                lvl.xpInCurrentLevel,
                                "/",
                                lvl.xpNeededForNext,
                                " XP"
                              ]
                            }, undefined, true, undefined, this),
                            /* @__PURE__ */ jsxDEV("div", {
                              className: "w-5 h-5 rounded-full bg-neutral-700 text-neutral-300 flex items-center justify-center text-xs font-bold cursor-help group-hover:bg-neutral-600",
                              children: "i"
                            }, undefined, false, undefined, this)
                          ]
                        }, undefined, true, undefined, this),
                        /* @__PURE__ */ jsxDEV("div", {
                          className: "absolute left-0 bottom-full mb-2 hidden group-hover:block bg-neutral-800 text-neutral-200 text-xs rounded p-2 w-48 border border-neutral-700 z-10",
                          children: [
                            /* @__PURE__ */ jsxDEV("p", {
                              className: "font-bold mb-1",
                              children: "XP Gains:"
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsxDEV("p", {
                              children: "\u2022 Win: +15 XP"
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsxDEV("p", {
                              children: "\u2022 Lose: +5 XP"
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsxDEV("p", {
                              children: "\u2022 Ultimate Winner: +25 XP"
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsxDEV("p", {
                              children: "\u2022 Perfect Win (10-0): +50 XP"
                            }, undefined, false, undefined, this)
                          ]
                        }, undefined, true, undefined, this)
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "w-full bg-neutral-800 rounded-full h-2 mt-2 overflow-hidden",
                      children: /* @__PURE__ */ jsxDEV("div", {
                        className: "h-2 rounded-full bg-gradient-to-r from-green-400 to-emerald-400",
                        style: { width: `${lvl.progress}%` }
                      }, undefined, false, undefined, this)
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  className: "w-11/12 mb-5 mt-5 mx-auto h-px bg-white/35 my-3 rounded"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  className: "mb-6",
                  children: [
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "flex items-center gap-2 mb-2",
                      children: /* @__PURE__ */ jsxDEV("p", {
                        className: `text-sm font-bold ${rank.colorKey}`,
                        children: "Rank"
                      }, undefined, false, undefined, this)
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV("p", {
                      className: `text-xl font-bold ${rank.colorKey} mb-1`,
                      children: rank.name
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV("p", {
                      className: "text-xs text-neutral-400 mb-2",
                      children: [
                        rank.min,
                        " - ",
                        rank.max,
                        " ELO"
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV("p", {
                      className: "text-xs text-neutral-500 mb-2",
                      children: [
                        rank.prevTierName && /* @__PURE__ */ jsxDEV("span", {
                          children: [
                            "\u2190 ",
                            rank.prevTierName,
                            " | "
                          ]
                        }, undefined, true, undefined, this),
                        rank.nextTierName && /* @__PURE__ */ jsxDEV("span", {
                          children: [
                            rank.nextTierName,
                            " \u2192"
                          ]
                        }, undefined, true, undefined, this)
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "relative group",
                      children: [
                        /* @__PURE__ */ jsxDEV("div", {
                          className: "flex items-center gap-2 mb-2",
                          children: [
                            /* @__PURE__ */ jsxDEV("p", {
                              className: "text-sm text-neutral-300 cursor-help",
                              children: [
                                playerData.elo,
                                " ELO"
                              ]
                            }, undefined, true, undefined, this),
                            /* @__PURE__ */ jsxDEV("div", {
                              className: "w-5 h-5 rounded-full bg-neutral-700 text-neutral-300 flex items-center justify-center text-xs font-bold cursor-help group-hover:bg-neutral-600",
                              children: "i"
                            }, undefined, false, undefined, this)
                          ]
                        }, undefined, true, undefined, this),
                        /* @__PURE__ */ jsxDEV("div", {
                          className: "absolute left-0 bottom-full mb-2 hidden group-hover:block bg-neutral-800 text-neutral-200 text-xs rounded p-2 w-56 border border-neutral-700 z-10",
                          children: [
                            /* @__PURE__ */ jsxDEV("p", {
                              className: "font-bold mb-1",
                              children: "ELO Changes:"
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsxDEV("p", {
                              children: "\u2022 Win: +20 ELO"
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsxDEV("p", {
                              children: "\u2022 Lose: -20 ELO"
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsxDEV("p", {
                              children: "\u2022 Opponent avg \xB125 ELO: \xB11 (max \xB110)"
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsxDEV("p", {
                              children: "\u2022 Ultimate Winner: 2 ELO from each opponent (total +6) "
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsxDEV("p", {
                              children: "\u2022 Ultimate Loser: 1 ELO to each opponent (total -3)"
                            }, undefined, false, undefined, this)
                          ]
                        }, undefined, true, undefined, this)
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "w-full bg-neutral-800 rounded-full h-2 mt-2 overflow-hidden",
                      children: /* @__PURE__ */ jsxDEV("div", {
                        className: `h-2 rounded-full bg-gradient-to-r ${rank.color}`,
                        style: { width: `${rank.progress}%` }
                      }, undefined, false, undefined, this)
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  className: "w-11/12 mb-5 mt-5 mx-auto h-px bg-white/35 my-3 rounded"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  className: "space-y-2 text-sm",
                  children: [
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "flex justify-between text-neutral-300",
                      children: [
                        /* @__PURE__ */ jsxDEV("span", {
                          className: "text-blue-400",
                          children: "Total Games:"
                        }, undefined, false, undefined, this),
                        /* @__PURE__ */ jsxDEV("span", {
                          className: "text-blue-400",
                          children: playerData.wins + playerData.loses
                        }, undefined, false, undefined, this)
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV("div", {
                      children: [
                        /* @__PURE__ */ jsxDEV("div", {
                          className: "flex justify-between text-neutral-300",
                          children: [
                            /* @__PURE__ */ jsxDEV("span", {
                              className: "text-green-400",
                              children: "Wins:"
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsxDEV("span", {
                              className: "text-green-400",
                              children: [
                                playerData.wins,
                                " (",
                                winRate,
                                "%)"
                              ]
                            }, undefined, true, undefined, this)
                          ]
                        }, undefined, true, undefined, this),
                        /* @__PURE__ */ jsxDEV("div", {
                          className: "flex justify-between ml-4 text-sm text-neutral-400",
                          children: [
                            /* @__PURE__ */ jsxDEV("span", {
                              className: "text-green-400",
                              children: "\u2022 Ultimate Wins"
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsxDEV("span", {
                              className: "text-green-400",
                              children: playerData.ultimate_wins
                            }, undefined, false, undefined, this)
                          ]
                        }, undefined, true, undefined, this)
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV("div", {
                      children: [
                        /* @__PURE__ */ jsxDEV("div", {
                          className: "flex justify-between text-neutral-300",
                          children: [
                            /* @__PURE__ */ jsxDEV("span", {
                              className: "text-red-400",
                              children: "Loses:"
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsxDEV("span", {
                              className: "text-red-400",
                              children: [
                                playerData.loses,
                                " (",
                                100 - winRate,
                                "%)"
                              ]
                            }, undefined, true, undefined, this)
                          ]
                        }, undefined, true, undefined, this),
                        /* @__PURE__ */ jsxDEV("div", {
                          className: "flex justify-between ml-4 text-sm text-neutral-400",
                          children: [
                            /* @__PURE__ */ jsxDEV("span", {
                              className: "text-red-400",
                              children: "\u2022 Ultimate Loses"
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsxDEV("span", {
                              className: "text-red-400",
                              children: playerData.ultimate_loses
                            }, undefined, false, undefined, this)
                          ]
                        }, undefined, true, undefined, this)
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, undefined, true, undefined, this)
              ]
            }, undefined, true, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("div", {
            className: "lg:col-span-2 flex flex-col justify-center items-center gap-6",
            children: [
              /* @__PURE__ */ jsxDEV("form", {
                action: "/v1/match/join",
                method: "post",
                className: "w-full max-w-sm",
                children: /* @__PURE__ */ jsxDEV("button", {
                  type: "submit",
                  className: "w-full py-4 bg-gradient-to-r from-green-600 to-green-500 hover:from-green-700 hover:to-green-600 text-white font-bold text-lg rounded-md transition-all",
                  children: "JOIN MATCH"
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV("a", {
                href: "/v1/leaderboard",
                className: "w-full max-w-sm",
                children: /* @__PURE__ */ jsxDEV("button", {
                  className: "w-full py-4 bg-transparent border-2 border-neutral-700 hover:border-green-500 text-white font-bold text-lg rounded-md transition-all",
                  children: "LEADERBOARDS"
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV("button", {
                disabled: true,
                className: "w-full max-w-sm py-4 bg-neutral-700/40 text-neutral-400 font-bold text-lg rounded-md cursor-not-allowed opacity-60",
                children: [
                  "\uD83C\uDFC6 TOURNAMENTS",
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "text-xs mt-1",
                    children: "Coming Soon"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV("div", {
            className: "lg:col-span-1"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV("form", {
        action: "/v1/auth/logout",
        method: "post",
        className: "fixed top-4 right-4 z-50",
        children: /* @__PURE__ */ jsxDEV("button", {
          type: "submit",
          className: "px-3 py-2 bg-red-400 hover:bg-red-500 text-white rounded-md font-semibold shadow-sm",
          children: "Logout"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/v1/leaderboard.tsx
function LeaderboardPage({ players }) {
  function eloColor(elo) {
    if (elo >= 5000)
      return "text-red-500";
    if (elo >= 4000)
      return "text-indigo-500";
    if (elo >= 3000)
      return "text-sky-500";
    if (elo >= 2000)
      return "text-amber-500";
    if (elo >= 1000)
      return "text-gray-400";
    return "text-yellow-600";
  }
  return /* @__PURE__ */ jsxDEV("div", {
    className: "min-h-screen bg-gradient-to-br from-neutral-950 via-neutral-900 to-green-950 p-6",
    children: /* @__PURE__ */ jsxDEV("div", {
      className: "max-w-4xl mx-auto",
      children: [
        /* @__PURE__ */ jsxDEV("div", {
          className: "mb-8",
          children: [
            /* @__PURE__ */ jsxDEV("h1", {
              className: "text-5xl font-bold text-white font-[Orbitron] mb-2",
              children: "Leaderboard"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV("p", {
              className: "text-neutral-400",
              children: "Top players by ELO rating"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV("div", {
          className: "bg-neutral-900/50 rounded-lg border border-neutral-800 overflow-hidden",
          children: [
            /* @__PURE__ */ jsxDEV("div", {
              className: "grid grid-cols-7 gap-4 px-6 py-4 bg-neutral-800/50 font-bold text-neutral-200 text-sm",
              children: [
                /* @__PURE__ */ jsxDEV("div", {
                  children: "Rank"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  children: "Player"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  children: "ELO"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  children: "Wins"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  children: "Loses"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  children: "Ultimate Wins"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  children: "Ultimate Loses"
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV("div", {
              className: "divide-y divide-neutral-800",
              children: players.map((player, idx) => /* @__PURE__ */ jsxDEV("div", {
                className: "grid grid-cols-7 gap-4 px-6 py-4 text-neutral-300 hover:bg-neutral-800/30 transition-colors",
                children: [
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "font-bold text-lg",
                    children: [
                      "#",
                      idx + 1
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "text-white font-semibold",
                    children: player.username
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV("div", {
                    className: `font-bold ${eloColor(player.elo)}`,
                    children: player.elo
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "text-green-400",
                    children: player.wins
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "text-red-400",
                    children: player.loses
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "text-yellow-400",
                    children: player.ultimate_wins
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "text-red-300",
                    children: player.ultimate_loses
                  }, undefined, false, undefined, this)
                ]
              }, player.$id, true, undefined, this))
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV("div", {
          className: "mt-6",
          children: /* @__PURE__ */ jsxDEV("a", {
            href: "/v1/lobby",
            children: /* @__PURE__ */ jsxDEV("button", {
              className: "px-6 py-2 bg-neutral-800/60 hover:bg-neutral-800 text-white rounded-md",
              children: "\u2190 Back to Lobby"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
}

// src/v1/match.ts
var sdk3 = require_dist();
var endpoint3 = process.env.APPWRITE_ENDPOINT || "https://fra.cloud.appwrite.io/v1";
var projectId3 = process.env.APPWRITE_PROJECT;
var apiKey3 = process.env.APPWRITE_KEY;
var databaseId2 = process.env.APPWRITE_DATABASE_ID;
var collectionId2 = "matches";
if (!projectId3 || !apiKey3) {
  console.warn("\u26A0\uFE0F Missing APPWRITE_PROJECT or APPWRITE_KEY env vars for match logic");
}
function client() {
  if (!projectId3 || !apiKey3 || !databaseId2)
    throw new Error("Appwrite credentials/database not configured");
  return new sdk3.Client().setEndpoint(endpoint3).setProject(projectId3).setKey(apiKey3);
}
function parseDoc(raw2) {
  const playersJson = raw2.players_json ?? raw2.players ?? "[]";
  const scoresJsonRaw = raw2.scores_json ?? "[]";
  let players = [];
  let scores = [];
  try {
    if (typeof playersJson === "string") {
      players = JSON.parse(playersJson || "[]");
    } else {
      players = playersJson;
    }
  } catch (e2) {
    console.warn("Failed to parse players_json", e2);
    players = [];
  }
  try {
    if (typeof scoresJsonRaw === "string") {
      scores = JSON.parse(scoresJsonRaw || "[]");
    } else {
      scores = scoresJsonRaw;
    }
  } catch (e2) {
    console.warn("Failed to parse scores_json", e2);
    scores = [];
  }
  return {
    $id: raw2.$id,
    state: raw2.state,
    players,
    maxPlayers: raw2.maxPlayers ?? 4,
    createdAt: raw2.$createdAt ?? raw2.createdAt,
    scores
  };
}
async function findOpenMatch() {
  const c = client();
  const databases = new sdk3.Databases(c);
  try {
    const res = await databases.listDocuments(databaseId2, collectionId2, [
      sdk3.Query.equal("state", "open"),
      sdk3.Query.limit(1)
    ]);
    if (res.documents && res.documents.length)
      return parseDoc(res.documents[0]);
    return null;
  } catch (err) {
    console.error("findOpenMatch error", err);
    throw err;
  }
}
async function createMatch(creator, maxPlayers = 4) {
  const c = client();
  const databases = new sdk3.Databases(c);
  try {
    const doc = await databases.createDocument(databaseId2, collectionId2, "unique()", {
      state: maxPlayers === 1 ? "full" : "open",
      players_json: JSON.stringify([creator]),
      maxPlayers
    });
    return parseDoc(doc);
  } catch (err) {
    console.error("createMatch error", err);
    throw err;
  }
}
async function getMatch(matchId) {
  const c = client();
  const databases = new sdk3.Databases(c);
  try {
    const doc = await databases.getDocument(databaseId2, collectionId2, matchId);
    return parseDoc(doc);
  } catch (err) {
    console.error("getMatch error", err);
    return null;
  }
}
async function joinMatch(matchId, player) {
  const c = client();
  const databases = new sdk3.Databases(c);
  const doc = await getMatch(matchId);
  if (!doc)
    throw new Error("Match not found");
  if (doc.state === "playing" || doc.state === "full")
    throw new Error("Match not joinable");
  const exists = (doc.players || []).some((p) => p.id === player.id);
  if (exists)
    return doc;
  const players = [...doc.players || [], player];
  const newState = players.length >= (doc.maxPlayers || 4) ? "full" : "open";
  try {
    const updated = await databases.updateDocument(databaseId2, collectionId2, matchId, {
      players_json: JSON.stringify(players),
      state: newState
    });
    return parseDoc(updated);
  } catch (err) {
    console.error("joinMatch update error", err);
    throw err;
  }
}
async function findOrCreateAndJoin(player) {
  const open = await findOpenMatch();
  if (open) {
    try {
      return await joinMatch(open.$id, player);
    } catch (err) {
      console.warn("join existing failed, creating new", err);
    }
  }
  return await createMatch(player, 4);
}
function createInitialScoresForPlayers(players) {
  const ids = players.map((p) => p.id);
  const pairings = [];
  if (ids.length >= 4) {
    pairings.push({ a: [ids[0], ids[1]], b: [ids[2], ids[3]], scoreA: 0, scoreB: 0 });
    pairings.push({ a: [ids[0], ids[2]], b: [ids[1], ids[3]], scoreA: 0, scoreB: 0 });
    pairings.push({ a: [ids[0], ids[3]], b: [ids[1], ids[2]], scoreA: 0, scoreB: 0 });
  } else {
    const a2 = ids.slice(0, Math.ceil(ids.length / 2));
    const b = ids.slice(Math.ceil(ids.length / 2));
    pairings.push({ a: a2, b, scoreA: 0, scoreB: 0 });
  }
  return pairings;
}
async function startMatch(matchId) {
  const c = client();
  const databases = new sdk3.Databases(c);
  try {
    const raw2 = await databases.getDocument(databaseId2, collectionId2, matchId);
    const parsed = parseDoc(raw2);
    let scores = parsed.scores ?? [];
    if (!scores || scores.length === 0) {
      scores = createInitialScoresForPlayers(parsed.players);
    }
    const updated = await databases.updateDocument(databaseId2, collectionId2, matchId, {
      state: "playing",
      scores_json: JSON.stringify(scores)
    });
    return parseDoc(updated);
  } catch (err) {
    console.error("startMatch error", err);
    throw err;
  }
}
async function updateGameScores(matchId, scores) {
  const c = client();
  const databases = new sdk3.Databases(c);
  try {
    const updated = await databases.updateDocument(databaseId2, collectionId2, matchId, {
      scores_json: JSON.stringify(scores)
    });
    return parseDoc(updated);
  } catch (err) {
    console.error("updateGameScores error", err);
    throw err;
  }
}
async function leaveMatch(matchId, playerId) {
  const c = client();
  const databases = new sdk3.Databases(c);
  const doc = await getMatch(matchId);
  if (!doc)
    throw new Error("Match not found");
  const players = (doc.players || []).filter((p) => p.id !== playerId);
  if (players.length === 0) {
    try {
      await databases.deleteDocument(databaseId2, collectionId2, matchId);
      return null;
    } catch (err) {
      console.error("deleteMatch error", err);
      throw err;
    }
  }
  const newState = players.length >= (doc.maxPlayers || 4) ? "full" : "open";
  try {
    const updated = await databases.updateDocument(databaseId2, collectionId2, matchId, {
      players_json: JSON.stringify(players),
      state: newState
    });
    return parseDoc(updated);
  } catch (err) {
    console.error("leaveMatch update error", err);
    throw err;
  }
}
async function findPlayingMatch() {
  const c = client();
  const databases = new sdk3.Databases(c);
  try {
    const res = await databases.listDocuments(databaseId2, collectionId2, [
      sdk3.Query.equal("state", "playing"),
      sdk3.Query.limit(1)
    ]);
    if (res.documents && res.documents.length)
      return parseDoc(res.documents[0]);
    return null;
  } catch (err) {
    console.error("findPlayingMatch error", err);
    return null;
  }
}
async function deleteMatch(matchId) {
  const c = client();
  const databases = new sdk3.Databases(c);
  try {
    await databases.deleteDocument(databaseId2, collectionId2, matchId);
    console.log("Match deleted:", matchId);
  } catch (err) {
    console.error("deleteMatch error", err);
    throw err;
  }
}

// src/v1/matchLobby.tsx
function MatchLobbyPage({ c, matchId, currentUser }) {
  return /* @__PURE__ */ jsxDEV("div", {
    className: "min-h-screen bg-gradient-to-br from-neutral-950 via-neutral-900 to-green-950 p-6",
    children: [
      /* @__PURE__ */ jsxDEV("div", {
        className: "max-w-3xl mx-auto",
        children: [
          /* @__PURE__ */ jsxDEV("h1", {
            className: "text-4xl font-bold text-white mb-4 font-[Orbitron]",
            children: "Match Lobby"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("p", {
            className: "text-neutral-400 mb-6",
            children: [
              "Match ID: ",
              matchId
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV("div", {
            id: "players",
            className: "bg-neutral-900/50 rounded-lg p-4 border border-neutral-800 mb-4",
            children: [
              /* @__PURE__ */ jsxDEV("h3", {
                className: "text-lg text-white mb-2",
                children: "Players"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV("div", {
                id: "playersList",
                className: "space-y-2 text-neutral-200",
                children: /* @__PURE__ */ jsxDEV("div", {
                  className: "text-neutral-400",
                  children: "Loading players\u2026"
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV("div", {
            className: "flex gap-3",
            children: [
              /* @__PURE__ */ jsxDEV("form", {
                id: "startForm",
                action: "/v1/match/start",
                method: "post",
                className: "flex-1",
                children: [
                  /* @__PURE__ */ jsxDEV("input", {
                    type: "hidden",
                    name: "matchId",
                    value: matchId
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV("button", {
                    id: "startBtn",
                    disabled: true,
                    className: "w-full py-3 bg-neutral-700/40 text-neutral-400 rounded-md cursor-not-allowed",
                    children: "Start Match"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV("form", {
                id: "leaveForm",
                action: "/v1/match/leave",
                method: "post",
                className: "flex-1",
                children: [
                  /* @__PURE__ */ jsxDEV("input", {
                    type: "hidden",
                    name: "matchId",
                    value: matchId
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV("button", {
                    type: "submit",
                    className: "w-full py-3 bg-transparent border border-neutral-700 text-white rounded-md",
                    children: "Leave"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV("script", {
        dangerouslySetInnerHTML: {
          __html: `
(function(){
  var matchId = ${JSON.stringify(matchId)};
  var currentUser = ${JSON.stringify(currentUser)};
  var decodedUser = (typeof currentUser === 'string' && currentUser.length) ? decodeURIComponent(currentUser) : currentUser;
  var playersList = document.getElementById('playersList');
  var startBtn = document.getElementById('startBtn');

  function safeDecode(s){
    try{
      if(typeof s === 'string' && s.length){
        return decodeURIComponent(s);
      }
    }catch(e){}
    return s;
  }

  function renderPlayers(doc){
    playersList.innerHTML = '';
    const players = (doc.players || []);
    players.forEach((p, idx) => {
      const displayName = safeDecode(p.username) || p.id;
      const div = document.createElement('div');
      div.className = 'flex justify-between items-center bg-neutral-800/30 p-2 rounded';
      div.innerHTML = '<div><div class="font-semibold text-white">'+(displayName)+'</div><div class="text-xs text-neutral-400">ELO: '+(p.elo||0)+' \u2014 Wins: '+(p.wins||0)+' \u2014 Losses: '+(p.loses||0)+'</div></div><div class="text-sm text-neutral-300">#'+(idx+1)+'</div>';
      playersList.appendChild(div);
    });

    if(players.length >= 4) {
      startBtn.disabled = false;
      startBtn.className = 'w-full py-3 bg-red-600 text-white rounded-md';
    } else {
      startBtn.disabled = true;
      startBtn.className = 'w-full py-3 bg-neutral-700/40 text-neutral-400 rounded-md';
    }
  }

  async function fetchState(){
    try{
      const res = await fetch('/v1/match/state?matchId=' + encodeURIComponent(matchId));
      if(res.ok){
        const doc = await res.json();
        renderPlayers(doc);
      }
    }catch(e){ console.error(e); }
  }

  // initial load + polling
  fetchState();
  const poll = setInterval(fetchState, 2000);

  // stop polling when navigating away
  window.addEventListener('beforeunload', function(){ clearInterval(poll); });
})();
          `
        }
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/v1/matchGame.tsx
function MatchGamePage({ c, match: match2 }) {
  const players = match2.players || [];
  const scores = match2.scores || [];
  return /* @__PURE__ */ jsxDEV("div", {
    className: "min-h-screen bg-gradient-to-br from-neutral-950 via-neutral-900 to-green-950 p-6",
    children: [
      /* @__PURE__ */ jsxDEV("div", {
        className: "max-w-4xl mx-auto",
        children: [
          /* @__PURE__ */ jsxDEV("h1", {
            className: "text-4xl font-bold text-white mb-4 font-[Orbitron]",
            children: "Match Game"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("p", {
            className: "text-neutral-400 mb-4",
            children: [
              "Match ID: ",
              match2.$id
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV("div", {
            className: "bg-neutral-900/50 rounded-lg p-4 mb-6 border border-neutral-800",
            children: [
              /* @__PURE__ */ jsxDEV("h3", {
                className: "text-lg text-white mb-2",
                children: "Players"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV("div", {
                className: "grid grid-cols-2 gap-2 text-sm text-neutral-200",
                children: players.map((p) => /* @__PURE__ */ jsxDEV("div", {
                  className: "p-2 bg-neutral-800/40 rounded",
                  children: [
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "font-semibold text-white",
                      children: p.username
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "text-xs text-neutral-400",
                      children: [
                        "ELO: ",
                        p.elo,
                        " \u2014 W:",
                        p.wins,
                        " L:",
                        p.loses
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, p.id, true, undefined, this))
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV("div", {
            id: "pairings",
            className: "space-y-4",
            children: scores.map((s2, idx) => /* @__PURE__ */ jsxDEV("div", {
              className: "bg-neutral-900/50 rounded-lg p-4 border border-neutral-800 flex items-center justify-between",
              children: [
                /* @__PURE__ */ jsxDEV("div", {
                  className: "flex flex-col items-start gap-2 w-1/3",
                  children: [
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "font-semibold text-white",
                      children: s2.a.map((id, i3) => {
                        const p = players.find((x) => x.id === id);
                        return /* @__PURE__ */ jsxDEV("span", {
                          children: [
                            p ? p.username : id,
                            i3 < s2.a.length - 1 ? " / " : ""
                          ]
                        }, i3, true, undefined, this);
                      })
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "flex gap-2",
                      children: [
                        /* @__PURE__ */ jsxDEV("button", {
                          className: "px-3 py-1 bg-green-600 rounded text-sm",
                          "data-idx": idx,
                          "data-side": "a",
                          "data-delta": "10",
                          children: "+10"
                        }, undefined, false, undefined, this),
                        /* @__PURE__ */ jsxDEV("button", {
                          className: "px-3 py-1 bg-green-500 rounded text-sm",
                          "data-idx": idx,
                          "data-side": "a",
                          "data-delta": "5",
                          children: "+5"
                        }, undefined, false, undefined, this),
                        /* @__PURE__ */ jsxDEV("button", {
                          className: "px-3 py-1 bg-green-400 rounded text-sm",
                          "data-idx": idx,
                          "data-side": "a",
                          "data-delta": "1",
                          children: "+1"
                        }, undefined, false, undefined, this)
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "flex gap-2 mt-1",
                      children: [
                        /* @__PURE__ */ jsxDEV("button", {
                          className: "px-3 py-1 bg-red-600 rounded text-sm",
                          "data-idx": idx,
                          "data-side": "a",
                          "data-delta": "-10",
                          children: "-10"
                        }, undefined, false, undefined, this),
                        /* @__PURE__ */ jsxDEV("button", {
                          className: "px-3 py-1 bg-red-500 rounded text-sm",
                          "data-idx": idx,
                          "data-side": "a",
                          "data-delta": "-5",
                          children: "-5"
                        }, undefined, false, undefined, this),
                        /* @__PURE__ */ jsxDEV("button", {
                          className: "px-3 py-1 bg-red-400 rounded text-sm",
                          "data-idx": idx,
                          "data-side": "a",
                          "data-delta": "-1",
                          children: "-1"
                        }, undefined, false, undefined, this)
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  className: "text-2xl font-bold text-white",
                  children: [
                    /* @__PURE__ */ jsxDEV("span", {
                      id: `scoreA-${idx}`,
                      children: s2.scoreA
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV("span", {
                      className: "mx-4 text-neutral-400",
                      children: ":"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV("span", {
                      id: `scoreB-${idx}`,
                      children: s2.scoreB
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsxDEV("div", {
                  className: "flex flex-col items-end gap-2 w-1/3",
                  children: [
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "font-semibold text-white",
                      children: s2.b.map((id, i3) => {
                        const p = players.find((x) => x.id === id);
                        return /* @__PURE__ */ jsxDEV("span", {
                          children: [
                            p ? p.username : id,
                            i3 < s2.b.length - 1 ? " / " : ""
                          ]
                        }, i3, true, undefined, this);
                      })
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "flex gap-2",
                      children: [
                        /* @__PURE__ */ jsxDEV("button", {
                          className: "px-3 py-1 bg-green-600 rounded text-sm",
                          "data-idx": idx,
                          "data-side": "b",
                          "data-delta": "10",
                          children: "+10"
                        }, undefined, false, undefined, this),
                        /* @__PURE__ */ jsxDEV("button", {
                          className: "px-3 py-1 bg-green-500 rounded text-sm",
                          "data-idx": idx,
                          "data-side": "b",
                          "data-delta": "5",
                          children: "+5"
                        }, undefined, false, undefined, this),
                        /* @__PURE__ */ jsxDEV("button", {
                          className: "px-3 py-1 bg-green-400 rounded text-sm",
                          "data-idx": idx,
                          "data-side": "b",
                          "data-delta": "1",
                          children: "+1"
                        }, undefined, false, undefined, this)
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV("div", {
                      className: "flex gap-2 mt-1",
                      children: [
                        /* @__PURE__ */ jsxDEV("button", {
                          className: "px-3 py-1 bg-red-600 rounded text-sm",
                          "data-idx": idx,
                          "data-side": "b",
                          "data-delta": "-10",
                          children: "-10"
                        }, undefined, false, undefined, this),
                        /* @__PURE__ */ jsxDEV("button", {
                          className: "px-3 py-1 bg-red-500 rounded text-sm",
                          "data-idx": idx,
                          "data-side": "b",
                          "data-delta": "-5",
                          children: "-5"
                        }, undefined, false, undefined, this),
                        /* @__PURE__ */ jsxDEV("button", {
                          className: "px-3 py-1 bg-red-400 rounded text-sm",
                          "data-idx": idx,
                          "data-side": "b",
                          "data-delta": "-1",
                          children: "-1"
                        }, undefined, false, undefined, this)
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, undefined, true, undefined, this)
              ]
            }, idx, true, undefined, this))
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV("div", {
            className: "mt-6 flex gap-3",
            children: [
              /* @__PURE__ */ jsxDEV("a", {
                href: "/v1/match/lobby",
                className: "flex-1",
                children: /* @__PURE__ */ jsxDEV("button", {
                  className: "w-full px-6 py-2 bg-neutral-800/60 hover:bg-neutral-800 text-white rounded-md",
                  children: "\u2190 Back to Lobby"
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV("form", {
                id: "finishForm",
                action: "/v1/match/game/finish",
                method: "post",
                className: "flex-1",
                children: [
                  /* @__PURE__ */ jsxDEV("input", {
                    type: "hidden",
                    name: "matchId",
                    value: match2.$id
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV("button", {
                    id: "finishBtn",
                    type: "button",
                    className: "w-full px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md",
                    children: "Finish Match"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV("script", {
        dangerouslySetInnerHTML: {
          __html: `
(function(){
  const matchId = ${JSON.stringify(match2.$id)};
  async function sendUpdate(idx, side, delta){
    try{
      const form = new FormData();
      form.append('matchId', matchId);
      form.append('index', String(idx));
      form.append('side', side);
      form.append('delta', String(delta));
      const res = await fetch('/v1/match/game/score', { method: 'POST', body: form });
      if(!res.ok) {
        const txt = await res.text().catch(()=>null);
        console.error('score update failed', txt);
        return;
      }
      const data = await res.json();
      // update DOM scores
      (data.scores || []).forEach((s, i) => {
        const a = document.getElementById('scoreA-'+i);
        const b = document.getElementById('scoreB-'+i);
        if(a) a.textContent = String(s.scoreA);
        if(b) b.textContent = String(s.scoreB);
      });
    }catch(e){ console.error(e); }
  }

  document.addEventListener('click', function(e){
    const el = e.target;
    if(!(el instanceof HTMLElement)) return;
    const idx = el.getAttribute('data-idx');
    const side = el.getAttribute('data-side');
    const delta = el.getAttribute('data-delta');
    if(idx && side && delta){
      // optimistic client-side clamp (server also enforces)
      const scoreEl = document.getElementById((side==='a'?'scoreA-':'scoreB-')+idx);
      let cur = scoreEl ? Number(scoreEl.textContent || '0') : 0;
      const newVal = Math.min(10, Math.max(0, cur + Number(delta)));
      // send delta = newVal - cur
      sendUpdate(Number(idx), side, newVal - cur);
    }

    // finish button
    if(el.id === 'finishBtn'){
      if(!confirm('Are you sure you want to finish the match and apply results? This is irreversible.')) return;
      // submit finish form
      const form = document.getElementById('finishForm');
      form && form.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
      // actually submit normally
      form && form.submit();
    }
  });
})();
          `
        }
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/v1/matchResult.tsx
function MatchResultPage({ c, result }) {
  const players = result.players || [];
  const scores = result.scores || [];
  return /* @__PURE__ */ jsxDEV("div", {
    className: "min-h-screen bg-gradient-to-br from-neutral-950 via-neutral-900 to-green-950 p-6",
    children: /* @__PURE__ */ jsxDEV("div", {
      className: "max-w-5xl mx-auto",
      children: [
        /* @__PURE__ */ jsxDEV("h1", {
          className: "text-4xl font-bold text-white mb-2 font-[Orbitron]",
          children: "Match Results"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV("p", {
          className: "text-neutral-400 mb-6",
          children: [
            "Match ID: ",
            result.matchId
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV("div", {
          className: "bg-neutral-900/50 rounded-lg p-4 border border-neutral-800 mb-6",
          children: [
            /* @__PURE__ */ jsxDEV("h3", {
              className: "text-lg text-white mb-2",
              children: "Players & Changes"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV("div", {
              className: "space-y-4",
              children: players.map((p) => /* @__PURE__ */ jsxDEV("div", {
                className: "p-4 bg-neutral-800/30 rounded border border-neutral-700",
                children: [
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "flex justify-between mb-3",
                    children: [
                      /* @__PURE__ */ jsxDEV("div", {
                        children: [
                          /* @__PURE__ */ jsxDEV("div", {
                            className: "font-semibold text-white text-lg",
                            children: p.username
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsxDEV("div", {
                            className: "text-xs text-neutral-400",
                            children: [
                              "Games +",
                              p.gamesAdded,
                              " \u2014 Wins +",
                              p.winsAdded,
                              " \u2014 Loses +",
                              p.losesAdded
                            ]
                          }, undefined, true, undefined, this)
                        ]
                      }, undefined, true, undefined, this),
                      /* @__PURE__ */ jsxDEV("div", {
                        className: "text-right",
                        children: [
                          /* @__PURE__ */ jsxDEV("div", {
                            className: "text-sm text-neutral-300",
                            children: [
                              "ELO: ",
                              /* @__PURE__ */ jsxDEV("span", {
                                className: "font-bold text-yellow-400",
                                children: p.oldElo
                              }, undefined, false, undefined, this),
                              " \u2192 ",
                              /* @__PURE__ */ jsxDEV("span", {
                                className: "font-bold text-green-400",
                                children: p.newElo
                              }, undefined, false, undefined, this),
                              " (",
                              p.newElo - p.oldElo >= 0 ? "+" : "",
                              p.newElo - p.oldElo,
                              ")"
                            ]
                          }, undefined, true, undefined, this),
                          /* @__PURE__ */ jsxDEV("div", {
                            className: "text-sm text-neutral-300",
                            children: [
                              "XP: ",
                              /* @__PURE__ */ jsxDEV("span", {
                                className: "font-bold text-green-400",
                                children: [
                                  "+",
                                  p.xpGained
                                ]
                              }, undefined, true, undefined, this)
                            ]
                          }, undefined, true, undefined, this)
                        ]
                      }, undefined, true, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "bg-neutral-900/50 rounded p-2 mb-2",
                    children: [
                      /* @__PURE__ */ jsxDEV("div", {
                        className: "text-xs font-semibold text-neutral-300 mb-1",
                        children: "ELO Breakdown:"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV("div", {
                        className: "space-y-1",
                        children: [
                          (p.eloBreakdown?.breakdown || []).map((item, i3) => /* @__PURE__ */ jsxDEV("div", {
                            className: "text-xs text-neutral-400 flex justify-between",
                            children: [
                              /* @__PURE__ */ jsxDEV("span", {
                                children: item.reason
                              }, undefined, false, undefined, this),
                              /* @__PURE__ */ jsxDEV("span", {
                                className: item.delta >= 0 ? "text-green-400" : "text-red-400",
                                children: [
                                  item.delta >= 0 ? "+" : "",
                                  item.delta
                                ]
                              }, undefined, true, undefined, this)
                            ]
                          }, i3, true, undefined, this)),
                          /* @__PURE__ */ jsxDEV("div", {
                            className: "text-xs font-semibold text-neutral-200 flex justify-between border-t border-neutral-700 pt-1 mt-1",
                            children: [
                              /* @__PURE__ */ jsxDEV("span", {
                                children: "Total ELO"
                              }, undefined, false, undefined, this),
                              /* @__PURE__ */ jsxDEV("span", {
                                className: "text-green-400",
                                children: [
                                  "+",
                                  p.eloBreakdown?.total || 0
                                ]
                              }, undefined, true, undefined, this)
                            ]
                          }, undefined, true, undefined, this)
                        ]
                      }, undefined, true, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "bg-neutral-900/50 rounded p-2",
                    children: [
                      /* @__PURE__ */ jsxDEV("div", {
                        className: "text-xs font-semibold text-neutral-300 mb-1",
                        children: "XP Breakdown:"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV("div", {
                        className: "space-y-1",
                        children: [
                          (p.xpBreakdown?.breakdown || []).map((item, i3) => /* @__PURE__ */ jsxDEV("div", {
                            className: "text-xs text-neutral-400 flex justify-between",
                            children: [
                              /* @__PURE__ */ jsxDEV("span", {
                                children: item.reason
                              }, undefined, false, undefined, this),
                              /* @__PURE__ */ jsxDEV("span", {
                                className: "text-green-400",
                                children: [
                                  "+",
                                  item.delta
                                ]
                              }, undefined, true, undefined, this)
                            ]
                          }, i3, true, undefined, this)),
                          /* @__PURE__ */ jsxDEV("div", {
                            className: "text-xs font-semibold text-neutral-200 flex justify-between border-t border-neutral-700 pt-1 mt-1",
                            children: [
                              /* @__PURE__ */ jsxDEV("span", {
                                children: "Total XP"
                              }, undefined, false, undefined, this),
                              /* @__PURE__ */ jsxDEV("span", {
                                className: "text-green-400",
                                children: [
                                  "+",
                                  p.xpBreakdown?.total || 0
                                ]
                              }, undefined, true, undefined, this)
                            ]
                          }, undefined, true, undefined, this)
                        ]
                      }, undefined, true, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, p.id, true, undefined, this))
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV("div", {
          className: "bg-neutral-900/50 rounded-lg p-4 border border-neutral-800 mb-6",
          children: [
            /* @__PURE__ */ jsxDEV("h3", {
              className: "text-lg text-white mb-2",
              children: "Per-match scores"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV("div", {
              className: "space-y-3",
              children: scores.map((s2, i3) => /* @__PURE__ */ jsxDEV("div", {
                className: "p-3 bg-neutral-800/30 rounded flex items-center justify-between",
                children: [
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "text-white font-semibold",
                    children: [
                      s2.aNames.join(" / "),
                      " ",
                      /* @__PURE__ */ jsxDEV("span", {
                        className: "text-neutral-300",
                        children: "vs"
                      }, undefined, false, undefined, this),
                      " ",
                      s2.bNames.join(" / ")
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV("div", {
                    className: "text-xl font-bold text-white",
                    children: [
                      s2.scoreA,
                      " : ",
                      s2.scoreB
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, i3, true, undefined, this))
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV("div", {
          className: "mt-6",
          children: /* @__PURE__ */ jsxDEV("a", {
            href: "/v1/lobby",
            children: /* @__PURE__ */ jsxDEV("button", {
              className: "px-6 py-2 bg-green-600 hover:bg-green-700 text-white rounded-md",
              children: "Back to Lobby"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
}

// src/server.tsx
var sdk4 = require_dist();
var app = new Hono2;
app.use("/static/*", serveStatic2({ root: "./" }));
app.use(async (c, next) => {
  if (c.req.path == "/" || c.req.path == "/v1/auth/login" || c.req.path == "/v1/auth/register" || c.req.path == "/v1/auth/logout") {
    await next();
    return;
  }
  const user = getCookie(c, "user") ?? "";
  if (!user && c.req.path.startsWith("/v1/")) {
    return c.redirect("/v1/auth/login");
  }
  await next();
});
app.get("/", (c) => {
  return c.html(/* @__PURE__ */ jsxDEV(MainLayout, {
    c,
    children: /* @__PURE__ */ jsxDEV(Homepage, {
      c
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this));
});
app.get("/v1/auth/login", (c) => {
  return c.html(/* @__PURE__ */ jsxDEV(MainLayout, {
    c,
    children: /* @__PURE__ */ jsxDEV(LoginPage, {
      c
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this));
});
app.get("/v1/auth/register", (c) => {
  return c.html(/* @__PURE__ */ jsxDEV(MainLayout, {
    c,
    children: /* @__PURE__ */ jsxDEV(RegisterPage, {
      c
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this));
});
app.get("/v1/lobby", async (c) => {
  try {
    const username = getCookie(c, "user") ?? "Player";
    const playerData = await getPlayerProfile(username);
    return c.html(/* @__PURE__ */ jsxDEV(MainLayout, {
      c,
      children: /* @__PURE__ */ jsxDEV(LobbyPage, {
        c,
        playerProfile: playerData
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this));
  } catch (err) {
    console.error("Lobby error:", err);
    return c.html(/* @__PURE__ */ jsxDEV(MainLayout, {
      c,
      children: /* @__PURE__ */ jsxDEV(LobbyPage, {
        c,
        playerProfile: null
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this));
  }
});
app.get("/v1/leaderboard", async (c) => {
  try {
    const players = await getLeaderboard(100);
    return c.html(/* @__PURE__ */ jsxDEV(MainLayout, {
      c,
      children: /* @__PURE__ */ jsxDEV(LeaderboardPage, {
        players
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this));
  } catch (err) {
    console.error("Leaderboard error:", err);
    return c.text("Failed to load leaderboard", 500);
  }
});
app.post("/v1/auth/register", async (c) => {
  try {
    const form3 = await c.req.formData();
    const username = String(form3.get("username") ?? "").trim();
    const password = String(form3.get("password") ?? "").trim();
    const confirm = String(form3.get("confirmPassword") ?? "").trim();
    if (!username || username.length < 3) {
      return c.text("Username must be at least 3 characters", 400);
    }
    if (!password || password.length < 6) {
      return c.text("Password must be at least 6 characters", 400);
    }
    if (password !== confirm) {
      return c.text("Passwords do not match", 400);
    }
    await registerUser(username, password);
    c.res.headers.set("Set-Cookie", `user=${encodeURIComponent(username)}; Path=/; HttpOnly; SameSite=Lax`);
    return c.redirect("/v1/lobby");
  } catch (err) {
    console.error("register error:", err);
    const msg = err?.message || "Registration failed";
    return c.text(msg, 500);
  }
});
app.post("/v1/auth/login", async (c) => {
  try {
    const form3 = await c.req.formData();
    const username = String(form3.get("username") ?? "").trim();
    const password = String(form3.get("password") ?? "").trim();
    if (!username || !password) {
      return c.text("Username and password required", 400);
    }
    await loginUser(username, password);
    c.res.headers.set("Set-Cookie", `user=${encodeURIComponent(username)}; Path=/; HttpOnly; SameSite=Lax`);
    return c.redirect("/v1/lobby");
  } catch (err) {
    console.error("login error:", err);
    return c.text("Invalid credentials", 401);
  }
});
app.post("/v1/auth/logout", (c) => {
  c.res.headers.set("Set-Cookie", "user=; Path=/; Max-Age=0; HttpOnly");
  c.res.headers.set("HX-Redirect", "/");
  return c.redirect("/");
});
app.post("/v1/match/join", async (c) => {
  try {
    const username = getCookie(c, "user") ?? null;
    if (!username)
      return c.redirect("/v1/auth/login");
    const playingMatch = await findPlayingMatch();
    if (playingMatch) {
      return c.text("A match is already in progress. Please wait for it to finish.", 409);
    }
    const profile = await getPlayerProfile(username);
    const player = {
      id: profile ? profile.$id : username,
      username,
      wins: profile ? profile.wins : 0,
      loses: profile ? profile.loses : 0,
      elo: profile ? profile.elo : 500
    };
    const match2 = await findOrCreateAndJoin(player);
    c.res.headers.set("Set-Cookie", `match_id=${encodeURIComponent(match2.$id)}; Path=/; HttpOnly; SameSite=Lax`);
    return c.redirect("/v1/match/lobby");
  } catch (err) {
    console.error("join match error:", err);
    return c.text("Failed to join match", 500);
  }
});
app.get("/v1/match/lobby", async (c) => {
  try {
    const matchId = getCookie(c, "match_id") ?? "";
    const username = getCookie(c, "user") ?? "Player";
    if (!matchId)
      return c.redirect("/v1/lobby");
    return c.html(/* @__PURE__ */ jsxDEV(MainLayout, {
      c,
      children: /* @__PURE__ */ jsxDEV(MatchLobbyPage, {
        c,
        matchId,
        currentUser: username
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this));
  } catch (err) {
    console.error("match lobby error", err);
    return c.redirect("/v1/lobby");
  }
});
app.get("/v1/match/state", async (c) => {
  const matchId = String(c.req.query("matchId") ?? "");
  if (!matchId)
    return c.json({ error: "missing matchId" }, 400);
  try {
    const match2 = await getMatch(matchId);
    if (!match2)
      return c.json({ error: "not found" }, 404);
    return c.json(match2);
  } catch (err) {
    console.error("state error", err);
    return c.json({ error: "failed" }, 500);
  }
});
app.post("/v1/match/leave", async (c) => {
  try {
    const matchIdFromCookie = getCookie(c, "match_id") ?? "";
    const form3 = await c.req.formData();
    const matchId = String(form3.get("matchId") ?? matchIdFromCookie ?? "");
    const username = getCookie(c, "user") ?? null;
    if (!matchId)
      return c.text("missing matchId", 400);
    if (!username) {
      c.res.headers.set("Set-Cookie", "match_id=; Path=/; Max-Age=0; HttpOnly");
      return c.redirect("/v1/lobby");
    }
    const profile = await getPlayerProfile(username);
    const playerId = profile ? profile.$id : username;
    const res = await leaveMatch(matchId, playerId);
    c.res.headers.set("Set-Cookie", "match_id=; Path=/; Max-Age=0; HttpOnly");
    return c.redirect("/v1/lobby");
  } catch (err) {
    console.error("leave match error:", err);
    return c.text("Failed to leave match", 500);
  }
});
app.post("/v1/match/start", async (c) => {
  try {
    const form3 = await c.req.formData();
    const matchId = String(form3.get("matchId") ?? "");
    const username = getCookie(c, "user") ?? "";
    if (!matchId)
      return c.text("missing matchId", 400);
    await startMatch(matchId);
    return c.redirect("/v1/match/game");
  } catch (err) {
    console.error("start error", err);
    return c.text("Failed to start", 500);
  }
});
app.get("/v1/match/game", async (c) => {
  try {
    const matchId = getCookie(c, "match_id") ?? "";
    if (!matchId)
      return c.redirect("/v1/lobby");
    const match2 = await getMatch(matchId);
    if (!match2)
      return c.redirect("/v1/lobby");
    return c.html(/* @__PURE__ */ jsxDEV(MainLayout, {
      c,
      children: /* @__PURE__ */ jsxDEV(MatchGamePage, {
        c,
        match: match2
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this));
  } catch (err) {
    console.error("match game error", err);
    return c.redirect("/v1/lobby");
  }
});
app.post("/v1/match/game/score", async (c) => {
  try {
    const form3 = await c.req.formData();
    const matchId = String(form3.get("matchId") ?? "");
    const index2 = Number(form3.get("index") ?? 0);
    const side = String(form3.get("side") ?? "a");
    const delta = Number(form3.get("delta") ?? 0);
    if (!matchId)
      return c.json({ error: "missing matchId" }, 400);
    const match2 = await getMatch(matchId);
    if (!match2)
      return c.json({ error: "match not found" }, 404);
    const scores = match2.scores || [];
    if (!scores[index2])
      return c.json({ error: "invalid index" }, 400);
    const s2 = scores[index2];
    if (side === "a") {
      s2.scoreA = Math.min(10, Math.max(0, (s2.scoreA || 0) + delta));
    } else {
      s2.scoreB = Math.min(10, Math.max(0, (s2.scoreB || 0) + delta));
    }
    const updated = await updateGameScores(matchId, scores);
    return c.json({ ok: true, scores: updated.scores });
  } catch (err) {
    console.error("update score error", err);
    return c.json({ error: "failed" }, 500);
  }
});
function avgElo(ids, players) {
  const vals = ids.map((id) => {
    const p = players.find((x) => x.id === id);
    return p ? p.elo : 0;
  });
  if (!vals.length)
    return 0;
  return Math.round(vals.reduce((a2, b) => a2 + b, 0) / vals.length);
}
app.post("/v1/match/game/finish", async (c) => {
  const endpoint4 = process.env.APPWRITE_ENDPOINT || "https://fra.cloud.appwrite.io/v1";
  const projectId4 = process.env.APPWRITE_PROJECT;
  const apiKey4 = process.env.APPWRITE_KEY;
  const databaseId3 = process.env.APPWRITE_DATABASE_ID;
  try {
    const form3 = await c.req.formData();
    const matchId = String(form3.get("matchId") ?? c.req.query("matchId") ?? "");
    if (!matchId)
      return c.text("missing matchId", 400);
    const match2 = await getMatch(matchId);
    if (!match2)
      return c.text("match not found", 404);
    const scores = match2.scores || [];
    const players = match2.players || [];
    const byId = {};
    players.forEach((p) => {
      byId[p.id] = {
        id: p.id,
        username: p.username,
        oldElo: p.elo,
        newElo: p.elo,
        xpGained: 0,
        winsAdded: 0,
        losesAdded: 0,
        perfectWins: 0,
        gamesAdded: 0
      };
    });
    scores.forEach((s2) => {
      const a2 = s2.a || [];
      const b = s2.b || [];
      const aScore = Number(s2.scoreA || 0);
      const bScore = Number(s2.scoreB || 0);
      let winnerSide = null;
      if (aScore > bScore)
        winnerSide = "a";
      else if (bScore > aScore)
        winnerSide = "b";
      const avgA = avgElo(a2, players);
      const avgB = avgElo(b, players);
      const diff = Math.abs(avgA - avgB);
      const adj = Math.min(10, Math.floor(diff / 25));
      if (winnerSide === "a") {
        a2.forEach((id) => {
          byId[id].winsAdded += 1;
          byId[id].xpGained += 15;
          byId[id].newElo += 20;
          byId[id].gamesAdded += 1;
          if (aScore === 10 && bScore === 0) {
            byId[id].xpGained += 50;
            byId[id].perfectWins = (byId[id].perfectWins || 0) + 1;
          }
        });
        b.forEach((id) => {
          byId[id].losesAdded += 1;
          byId[id].xpGained += 5;
          byId[id].newElo -= 20;
          byId[id].gamesAdded += 1;
        });
        if (avgA > avgB) {
          a2.forEach((id) => byId[id].newElo -= adj);
        } else if (avgA < avgB) {
          a2.forEach((id) => byId[id].newElo += adj);
        }
      } else if (winnerSide === "b") {
        b.forEach((id) => {
          byId[id].winsAdded += 1;
          byId[id].xpGained += 15;
          byId[id].newElo += 20;
          byId[id].gamesAdded += 1;
          if (bScore === 10 && aScore === 0) {
            byId[id].xpGained += 50;
            byId[id].perfectWins = (byId[id].perfectWins || 0) + 1;
          }
        });
        a2.forEach((id) => {
          byId[id].losesAdded += 1;
          byId[id].xpGained += 5;
          byId[id].newElo -= 20;
          byId[id].gamesAdded += 1;
        });
        if (avgB > avgA) {
          b.forEach((id) => byId[id].newElo -= adj);
        } else if (avgB < avgA) {
          b.forEach((id) => byId[id].newElo += adj);
        }
      } else {
        a2.forEach((id) => byId[id].gamesAdded += 1);
        b.forEach((id) => byId[id].gamesAdded += 1);
      }
    });
    const totalRounds = scores.length || 0;
    const ids = Object.keys(byId);
    let ultimateWinnerId = null;
    let ultimateLoserId = null;
    ids.forEach((id) => {
      if (byId[id].winsAdded === totalRounds && totalRounds > 0)
        ultimateWinnerId = id;
      if (byId[id].losesAdded === totalRounds && totalRounds > 0)
        ultimateLoserId = id;
    });
    if (ultimateWinnerId) {
      ids.forEach((id) => {
        if (id === ultimateWinnerId) {
          byId[id].xpGained += 25;
          byId[id].newElo += 6;
        } else {
          byId[id].newElo -= 2;
        }
      });
    }
    if (ultimateLoserId) {
      ids.forEach((id) => {
        if (id === ultimateLoserId) {
          byId[id].newElo -= 3;
        } else {
          byId[id].newElo += 1;
        }
      });
    }
    const historyPlayers = [];
    for (const id of ids) {
      const rec = byId[id];
      const oldElo = rec.oldElo;
      const newElo = Math.max(0, Math.round(rec.newElo));
      const xpGain = Math.max(0, Math.round(rec.xpGained));
      const winsAdd = rec.winsAdded || 0;
      const losesAdd = rec.losesAdded || 0;
      const ultimateWinInc = ultimateWinnerId === id ? 1 : 0;
      const ultimateLoseInc = ultimateLoserId === id ? 1 : 0;
      const gamesAdded = rec.gamesAdded || 0;
      try {
        const profile = await getPlayerProfile(id);
        if (profile) {
          await updatePlayerStats(profile.$id, {
            xp: (profile.xp || 0) + xpGain,
            elo: (profile.elo || 0) + (newElo - oldElo),
            wins: (profile.wins || 0) + winsAdd,
            loses: (profile.loses || 0) + losesAdd,
            ultimate_wins: (profile.ultimate_wins || 0) + ultimateWinInc,
            ultimate_loses: (profile.ultimate_loses || 0) + ultimateLoseInc
          });
        }
      } catch (e2) {
        console.error("failed updating profile", id, e2);
      }
      historyPlayers.push({
        id,
        username: rec.username,
        oldElo,
        newElo,
        xpGain,
        winsAdd,
        losesAdd,
        ultimateWinInc,
        ultimateLoseInc,
        gamesAdded
      });
      byId[id].oldElo = oldElo;
      byId[id].newElo = newElo;
      byId[id].xpGained = xpGain;
    }
    try {
      if (!projectId4 || !apiKey4 || !databaseId3)
        throw new Error("Appwrite not configured for history");
      const client2 = new sdk4.Client().setEndpoint(process.env.APPWRITE_ENDPOINT || "https://fra.cloud.appwrite.io/v1").setProject(process.env.APPWRITE_PROJECT).setKey(process.env.APPWRITE_KEY);
      const databases = new sdk4.Databases(client2);
      const historyDoc = await databases.createDocument(databaseId3, "matches_history", "unique()", {
        matchId,
        players_json: JSON.stringify(historyPlayers),
        scores_json: JSON.stringify(scores)
      });
    } catch (e2) {
      console.error("failed to write match history", e2);
    }
    try {
      await deleteMatch(matchId);
    } catch (e2) {
      console.error("failed to delete match after finish", e2);
    }
    const result = {
      matchId,
      players: ids.map((id) => ({
        id,
        username: byId[id].username,
        oldElo: byId[id].oldElo,
        newElo: byId[id].newElo,
        xpGained: byId[id].xpGained,
        winsAdded: byId[id].winsAdded,
        losesAdded: byId[id].losesAdded,
        gamesAdded: byId[id].gamesAdded,
        eloBreakdown: computeEloBreakdown(id, byId[id], scores, players, totalRounds, ultimateWinnerId, ultimateLoserId),
        xpBreakdown: computeXpBreakdown(id, byId[id], scores, players, totalRounds, ultimateWinnerId)
      })),
      scores: scores.map((s2) => {
        const aNames = (s2.a || []).map((id) => {
          const p = players.find((x) => x.id === id);
          return p ? p.username : id;
        });
        const bNames = (s2.b || []).map((id) => {
          const p = players.find((x) => x.id === id);
          return p ? p.username : id;
        });
        return {
          aNames,
          bNames,
          scoreA: s2.scoreA,
          scoreB: s2.scoreB
        };
      })
    };
    return c.html(/* @__PURE__ */ jsxDEV(MainLayout, {
      c,
      children: /* @__PURE__ */ jsxDEV(MatchResultPage, {
        c,
        result
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this));
  } catch (err) {
    console.error("finish match error", err);
    return c.text("Failed to finish match", 500);
  }
});
function computeEloBreakdown(playerId, rec, scores, players, totalRounds, ultimateWinnerId, ultimateLoserId) {
  const breakdown = [];
  let total = 0;
  scores.forEach((s2, idx) => {
    const a2 = s2.a || [];
    const b = s2.b || [];
    const aScore = Number(s2.scoreA || 0);
    const bScore = Number(s2.scoreB || 0);
    let isWinner = false;
    let isLoser = false;
    let delta = 0;
    if (aScore > bScore) {
      isWinner = a2.includes(playerId);
      isLoser = b.includes(playerId);
    } else if (bScore > aScore) {
      isWinner = b.includes(playerId);
      isLoser = a2.includes(playerId);
    }
    if (isWinner) {
      delta = 20;
      breakdown.push({ match: idx + 1, reason: `Won match ${idx + 1}`, delta });
      total += delta;
      const avgWinner = avgElo(isWinner ? a2 : b, players);
      const avgLoser = avgElo(isLoser ? b : a2, players);
      const diff = Math.abs(avgWinner - avgLoser);
      const adj = Math.min(10, Math.floor(diff / 25));
      if (avgWinner > avgLoser) {
        breakdown.push({ match: idx + 1, reason: `Stronger team penalty`, delta: -adj });
        total -= adj;
      } else if (avgWinner < avgLoser) {
        breakdown.push({ match: idx + 1, reason: `Weaker team bonus`, delta: adj });
        total += adj;
      }
    } else if (isLoser) {
      delta = -20;
      breakdown.push({ match: idx + 1, reason: `Lost match ${idx + 1}`, delta });
      total += delta;
    }
  });
  if (ultimateWinnerId === playerId) {
    breakdown.push({ match: null, reason: `Ultimate winner bonus`, delta: 6 });
    total += 6;
  } else if (ultimateWinnerId && playerId !== ultimateWinnerId) {
    breakdown.push({ match: null, reason: `Ultimate winner penalty`, delta: -2 });
    total -= 2;
  }
  if (ultimateLoserId === playerId) {
    breakdown.push({ match: null, reason: `Ultimate loser penalty`, delta: -3 });
    total -= 3;
  } else if (ultimateLoserId && playerId !== ultimateLoserId) {
    breakdown.push({ match: null, reason: `Ultimate loser bonus`, delta: 1 });
    total += 1;
  }
  return { breakdown, total };
}
function computeXpBreakdown(playerId, rec, scores, players, totalRounds, ultimateWinnerId) {
  const breakdown = [];
  let total = 0;
  scores.forEach((s2, idx) => {
    const a2 = s2.a || [];
    const b = s2.b || [];
    const aScore = Number(s2.scoreA || 0);
    const bScore = Number(s2.scoreB || 0);
    let isWinner = false;
    let isLoser = false;
    if (aScore > bScore) {
      isWinner = a2.includes(playerId);
      isLoser = b.includes(playerId);
    } else if (bScore > aScore) {
      isWinner = b.includes(playerId);
      isLoser = a2.includes(playerId);
    }
    if (isWinner) {
      breakdown.push({ match: idx + 1, reason: `Won match ${idx + 1}`, delta: 15 });
      total += 15;
      if (aScore === 10 && bScore === 0) {
        breakdown.push({ match: idx + 1, reason: `Perfect win (10-0)`, delta: 50 });
        total += 50;
      } else if (bScore === 10 && aScore === 0) {
        breakdown.push({ match: idx + 1, reason: `Perfect win (10-0)`, delta: 50 });
        total += 50;
      }
    } else if (isLoser) {
      breakdown.push({ match: idx + 1, reason: `Lost match ${idx + 1}`, delta: 5 });
      total += 5;
    }
  });
  if (ultimateWinnerId === playerId) {
    breakdown.push({ match: null, reason: `Ultimate winner bonus`, delta: 25 });
    total += 25;
  }
  return { breakdown, total };
}
var server_default = app;

// src/appwrite.tsx
async function appwrite_default(context) {
  const request = requestFromContext(context);
  const response = await server_default.request(request);
  return await responseForContext(context, response);
}
function requestFromContext(context) {
  const headers = new Headers;
  for (const header of Object.keys(context.req.headers)) {
    headers.set(header, context.req.headers[header]);
  }
  let body = context.req.bodyRaw;
  if (context.req.method === "GET" || context.req.method === "HEAD") {
    body = undefined;
  }
  const request = new Request(context.req.url, {
    method: context.req.method,
    body,
    headers
  });
  return request;
}
async function responseForContext(context, response) {
  const headers = {};
  for (const pair of response.headers.entries()) {
    const [key, value] = pair;
    if (!headers[key]) {
      headers[key] = value;
    } else {
      headers[key] = [
        ...Array.isArray(headers[key]) ? headers[key] : [headers[key]],
        value
      ];
    }
  }
  return context.res.send(await response.text(), response.status, headers);
}
export {
  responseForContext,
  requestFromContext,
  appwrite_default as default
};
